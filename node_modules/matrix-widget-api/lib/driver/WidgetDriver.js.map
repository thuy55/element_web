{"version":3,"file":"WidgetDriver.js","names":["_","require","_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_toPropertyKey","key","_createClass","protoProps","staticProps","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","call","Number","WidgetDriver","value","validateCapabilities","requested","Promise","resolve","Set","sendEvent","eventType","content","stateKey","arguments","roomId","reject","Error","sendDelayedEvent","delay","parentDelayId","updateDelayedEvent","delayId","action","sendToDevice","encrypted","contentMap","readRoomAccountData","roomIds","readRoomEvents","msgtype","limit","since","readStateEvents","readRoomTimeline","readRoomState","MAX_SAFE_INTEGER","readEventRelations","eventId","relationType","from","to","direction","chunk","askOpenID","observer","update","state","OpenIDRequestState","Blocked","navigate","uri","getTurnServers","searchUserDirectory","searchTerm","limited","results","getMediaConfig","uploadFile","file","downloadFile","contentUri","getKnownRooms","processError","error","exports"],"sources":["../../src/driver/WidgetDriver.ts"],"sourcesContent":["/*\n * Copyright 2020 - 2024 The Matrix.org Foundation C.I.C.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n    Capability,\n    IOpenIDCredentials,\n    OpenIDRequestState,\n    SimpleObservable,\n    IRoomEvent,\n    IRoomAccountData,\n    ITurnServer,\n    IWidgetApiErrorResponseDataDetails,\n    UpdateDelayedEventAction,\n} from \"..\";\n\nexport interface ISendEventDetails {\n    roomId: string;\n    eventId: string;\n}\n\nexport interface ISendDelayedEventDetails {\n    roomId: string;\n    delayId: string;\n}\n\nexport interface IOpenIDUpdate {\n    state: OpenIDRequestState;\n    token?: IOpenIDCredentials;\n}\n\nexport interface IReadEventRelationsResult {\n    chunk: IRoomEvent[];\n    nextBatch?: string;\n    prevBatch?: string;\n}\n\nexport interface ISearchUserDirectoryResult {\n    limited: boolean;\n    results: Array<{\n        userId: string;\n        displayName?: string;\n        avatarUrl?: string;\n    }>;\n}\n\nexport interface IGetMediaConfigResult {\n    [key: string]: unknown;\n    \"m.upload.size\"?: number;\n}\n\n/**\n * Represents the functions and behaviour the widget-api is unable to\n * do, such as prompting the user for information or interacting with\n * the UI. Clients are expected to implement this class and override\n * any functions they need/want to support.\n *\n * This class assumes the client will have a context of a Widget\n * instance already.\n */\nexport abstract class WidgetDriver {\n    /**\n     * Verifies the widget's requested capabilities, returning the ones\n     * it is approved to use. Mutating the requested capabilities will\n     * have no effect.\n     *\n     * This SHOULD result in the user being prompted to approve/deny\n     * capabilities.\n     *\n     * By default this rejects all capabilities (returns an empty set).\n     * @param {Set<Capability>} requested The set of requested capabilities.\n     * @returns {Promise<Set<Capability>>} Resolves to the allowed capabilities.\n     */\n    public validateCapabilities(requested: Set<Capability>): Promise<Set<Capability>> {\n        return Promise.resolve(new Set());\n    }\n\n    /**\n     * Sends an event into a room. If `roomId` is falsy, the client should send the event\n     * into the room the user is currently looking at. The widget API will have already\n     * verified that the widget is capable of sending the event to that room.\n     * @param {string} eventType The event type to be sent.\n     * @param {*} content The content for the event.\n     * @param {string|null} stateKey The state key if this is a state event, otherwise null.\n     * May be an empty string.\n     * @param {string|null} roomId The room ID to send the event to. If falsy, the room the\n     * user is currently looking at.\n     * @returns {Promise<ISendEventDetails>} Resolves when the event has been sent with\n     * details of that event.\n     * @throws Rejected when the event could not be sent.\n     */\n    public sendEvent(\n        eventType: string,\n        content: unknown,\n        stateKey: string | null = null,\n        roomId: string | null = null,\n    ): Promise<ISendEventDetails> {\n        return Promise.reject(new Error(\"Failed to override function\"));\n    }\n\n    /**\n     * @experimental Part of MSC4140 & MSC4157\n     * Sends a delayed event into a room. If `roomId` is falsy, the client should send it\n     * into the room the user is currently looking at. The widget API will have already\n     * verified that the widget is capable of sending the event to that room.\n     * @param {number|null} delay How much later to send the event, or null to not send the\n     * event automatically. May not be null if {@link parentDelayId} is null.\n     * @param {string|null} parentDelayId The ID of the delayed event this one is grouped with,\n     * or null if it will be put in a new group. May not be null if {@link delay} is null.\n     * @param {string} eventType The event type of the event to be sent.\n     * @param {*} content The content for the event to be sent.\n     * @param {string|null} stateKey The state key if the event to be sent a state event,\n     * otherwise null. May be an empty string.\n     * @param {string|null} roomId The room ID to send the event to. If falsy, the room the\n     * user is currently looking at.\n     * @returns {Promise<ISendDelayedEventDetails>} Resolves when the delayed event has been\n     * prepared with details of how to refer to it for updating/sending/canceling it later.\n     * @throws Rejected when the delayed event could not be sent.\n     */\n    public sendDelayedEvent(\n        delay: number | null,\n        parentDelayId: string | null,\n        eventType: string,\n        content: unknown,\n        stateKey: string | null = null,\n        roomId: string | null = null,\n    ): Promise<ISendDelayedEventDetails> {\n        return Promise.reject(new Error(\"Failed to override function\"));\n    }\n\n    /**\n     * @experimental Part of MSC4140 & MSC4157\n     * Run the specified {@link action} for the delayed event matching the provided {@link delayId}.\n     * @throws Rejected when there is no matching delayed event, or when the action failed to run.\n     */\n    public updateDelayedEvent(delayId: string, action: UpdateDelayedEventAction): Promise<void> {\n        return Promise.reject(new Error(\"Failed to override function\"));\n    }\n\n    /**\n     * Sends a to-device event. The widget API will have already verified that the widget\n     * is capable of sending the event.\n     * @param {string} eventType The event type to be sent.\n     * @param {boolean} encrypted Whether to encrypt the message contents.\n     * @param {Object} contentMap A map from user ID and device ID to event content.\n     * @returns {Promise<void>} Resolves when the event has been sent.\n     * @throws Rejected when the event could not be sent.\n     */\n    public sendToDevice(\n        eventType: string,\n        encrypted: boolean,\n        contentMap: { [userId: string]: { [deviceId: string]: object } },\n    ): Promise<void> {\n        return Promise.reject(new Error(\"Failed to override function\"));\n    }\n    /**\n     * Reads an element of room account data. The widget API will have already verified that the widget is\n     * capable of receiving the `eventType` of the requested information. If `roomIds` is supplied, it may\n     * contain `Symbols.AnyRoom` to denote that the piece of room account data in each of the client's known\n     * rooms should be returned. When `null`, only the room the user is currently looking at should be considered.\n     * @param eventType The event type to be read.\n     * @param roomIds When null, the user's currently viewed room. Otherwise, the list of room IDs\n     * to look within, possibly containing Symbols.AnyRoom to denote all known rooms.\n     * @returns {Promise<IRoomAccountData[]>} Resolves to the element of room account data, or an empty array.\n     */\n    public readRoomAccountData(eventType: string, roomIds: string[] | null = null): Promise<IRoomAccountData[]> {\n        return Promise.resolve([]);\n    }\n\n    /**\n     * Reads all events of the given type, and optionally `msgtype` (if applicable/defined),\n     * the user has access to. The widget API will have already verified that the widget is\n     * capable of receiving the events. Less events than the limit are allowed to be returned,\n     * but not more. If `roomIds` is supplied, it may contain `Symbols.AnyRoom` to denote that\n     * `limit` in each of the client's known rooms should be returned. When `null`, only the\n     * room the user is currently looking at should be considered. If `since` is specified but\n     * the event ID isn't present in the number of events fetched by the client due to `limit`,\n     * the client will return all the events.\n     * @param eventType The event type to be read.\n     * @param msgtype The msgtype of the events to be read, if applicable/defined.\n     * @param stateKey The state key of the events to be read, if applicable/defined.\n     * @param limit The maximum number of events to retrieve per room. Will be zero to denote \"as many\n     * as possible\".\n     * @param roomIds When null, the user's currently viewed room. Otherwise, the list of room IDs\n     * to look within, possibly containing Symbols.AnyRoom to denote all known rooms.\n     * @param since When null, retrieves the number of events specified by the \"limit\" parameter.\n     * Otherwise, the event ID at which only subsequent events will be returned, as many as specified\n     * in \"limit\".\n     * @returns {Promise<IRoomEvent[]>} Resolves to the room events, or an empty array.\n     * @deprecated Clients are advised to implement {@link WidgetDriver.readRoomTimeline} instead.\n     */\n    public readRoomEvents(\n        eventType: string,\n        msgtype: string | undefined,\n        limit: number,\n        roomIds: string[] | null = null,\n        since?: string,\n    ): Promise<IRoomEvent[]> {\n        return Promise.resolve([]);\n    }\n\n    /**\n     * Reads all events of the given type, and optionally state key (if applicable/defined),\n     * the user has access to. The widget API will have already verified that the widget is\n     * capable of receiving the events. Less events than the limit are allowed to be returned,\n     * but not more. If `roomIds` is supplied, it may contain `Symbols.AnyRoom` to denote that\n     * `limit` in each of the client's known rooms should be returned. When `null`, only the\n     * room the user is currently looking at should be considered.\n     * @param eventType The event type to be read.\n     * @param stateKey The state key of the events to be read, if applicable/defined.\n     * @param limit The maximum number of events to retrieve. Will be zero to denote \"as many\n     * as possible\".\n     * @param roomIds When null, the user's currently viewed room. Otherwise, the list of room IDs\n     * to look within, possibly containing Symbols.AnyRoom to denote all known rooms.\n     * @returns {Promise<IRoomEvent[]>} Resolves to the state events, or an empty array.\n     * @deprecated Clients are advised to implement {@link WidgetDriver.readRoomTimeline} instead.\n     */\n    public readStateEvents(\n        eventType: string,\n        stateKey: string | undefined,\n        limit: number,\n        roomIds: string[] | null = null,\n    ): Promise<IRoomEvent[]> {\n        return Promise.resolve([]);\n    }\n\n    /**\n     * Reads all events of the given type, and optionally `msgtype` (if applicable/defined),\n     * the user has access to. The widget API will have already verified that the widget is\n     * capable of receiving the events. Less events than the limit are allowed to be returned,\n     * but not more.\n     * @param roomId The ID of the room to look within.\n     * @param eventType The event type to be read.\n     * @param msgtype The msgtype of the events to be read, if applicable/defined.\n     * @param stateKey The state key of the events to be read, if applicable/defined.\n     * @param limit The maximum number of events to retrieve. Will be zero to denote \"as many as\n     * possible\".\n     * @param since When null, retrieves the number of events specified by the \"limit\" parameter.\n     * Otherwise, the event ID at which only subsequent events will be returned, as many as specified\n     * in \"limit\".\n     * @returns {Promise<IRoomEvent[]>} Resolves to the room events, or an empty array.\n     */\n    public readRoomTimeline(\n        roomId: string,\n        eventType: string,\n        msgtype: string | undefined,\n        stateKey: string | undefined,\n        limit: number,\n        since: string | undefined,\n    ): Promise<IRoomEvent[]> {\n        // For backward compatibility we try the deprecated methods, in case\n        // they're implemented\n        if (stateKey === undefined) return this.readRoomEvents(eventType, msgtype, limit, [roomId], since);\n        else return this.readStateEvents(eventType, stateKey, limit, [roomId]);\n    }\n\n    /**\n     * Reads the current values of all matching room state entries.\n     * @param roomId The ID of the room.\n     * @param eventType The event type of the entries to be read.\n     * @param stateKey The state key of the entry to be read. If undefined,\n     * all room state entries with a matching event type should be returned.\n     * @returns {Promise<IRoomEvent[]>} Resolves to the events representing the\n     * current values of the room state entries.\n     */\n    public readRoomState(roomId: string, eventType: string, stateKey: string | undefined): Promise<IRoomEvent[]> {\n        return this.readStateEvents(eventType, stateKey, Number.MAX_SAFE_INTEGER, [roomId]);\n    }\n\n    /**\n     * Reads all events that are related to a given event. The widget API will\n     * have already verified that the widget is capable of receiving the event,\n     * or will make sure to reject access to events which are returned from this\n     * function, but are not capable of receiving. If `relationType` or `eventType`\n     * are set, the returned events should already be filtered. Less events than\n     * the limit are allowed to be returned, but not more.\n     * @param eventId The id of the parent event to be read.\n     * @param roomId The room to look within. When undefined, the user's\n     * currently viewed room.\n     * @param relationType The relationship type of child events to search for.\n     * When undefined, all relations are returned.\n     * @param eventType The event type of child events to search for. When undefined,\n     * all related events are returned.\n     * @param from The pagination token to start returning results from, as\n     * received from a previous call. If not supplied, results start at the most\n     * recent topological event known to the server.\n     * @param to The pagination token to stop returning results at. If not\n     * supplied, results continue up to limit or until there are no more events.\n     * @param limit The maximum number of events to retrieve per room. If not\n     * supplied, the server will apply a default limit.\n     * @param direction The direction to search for according to MSC3715\n     * @returns Resolves to the room relations.\n     */\n    public readEventRelations(\n        eventId: string,\n        roomId?: string,\n        relationType?: string,\n        eventType?: string,\n        from?: string,\n        to?: string,\n        limit?: number,\n        direction?: \"f\" | \"b\",\n    ): Promise<IReadEventRelationsResult> {\n        return Promise.resolve({ chunk: [] });\n    }\n\n    /**\n     * Asks the user for permission to validate their identity through OpenID Connect. The\n     * interface for this function is an observable which accepts the state machine of the\n     * OIDC exchange flow. For example, if the client/user blocks the request then it would\n     * feed back a `{state: Blocked}` into the observable. Similarly, if the user already\n     * approved the widget then a `{state: Allowed}` would be fed into the observable alongside\n     * the token itself. If the client is asking for permission, it should feed in a\n     * `{state: PendingUserConfirmation}` followed by the relevant Allowed or Blocked state.\n     *\n     * The widget API will reject the widget's request with an error if this contract is not\n     * met properly. By default, the widget driver will block all OIDC requests.\n     * @param {SimpleObservable<IOpenIDUpdate>} observer The observable to feed updates into.\n     */\n    public askOpenID(observer: SimpleObservable<IOpenIDUpdate>): void {\n        observer.update({ state: OpenIDRequestState.Blocked });\n    }\n\n    /**\n     * Navigates the client with a matrix.to URI. In future this function will also be provided\n     * with the Matrix URIs once matrix.to is replaced. The given URI will have already been\n     * lightly checked to ensure it looks like a valid URI, though the implementation is recommended\n     * to do further checks on the URI.\n     * @param {string} uri The URI to navigate to.\n     * @returns {Promise<void>} Resolves when complete.\n     * @throws Throws if there's a problem with the navigation, such as invalid format.\n     */\n    public navigate(uri: string): Promise<void> {\n        throw new Error(\"Navigation is not implemented\");\n    }\n\n    /**\n     * Polls for TURN server data, yielding an initial set of credentials as soon as possible, and\n     * thereafter yielding new credentials whenever the previous ones expire. The widget API will\n     * have already verified that the widget has permission to access TURN servers.\n     * @yields {ITurnServer} The TURN server URIs and credentials currently available to the client.\n     */\n    public getTurnServers(): AsyncGenerator<ITurnServer> {\n        throw new Error(\"TURN server support is not implemented\");\n    }\n\n    /**\n     * Search for users in the user directory.\n     * @param searchTerm The term to search for.\n     * @param limit The maximum number of results to return. If not supplied, the\n     * @returns Resolves to the search results.\n     */\n    public searchUserDirectory(searchTerm: string, limit?: number): Promise<ISearchUserDirectoryResult> {\n        return Promise.resolve({ limited: false, results: [] });\n    }\n\n    /**\n     * Get the config for the media repository.\n     * @returns Promise which resolves with an object containing the config.\n     */\n    public getMediaConfig(): Promise<IGetMediaConfigResult> {\n        throw new Error(\"Get media config is not implemented\");\n    }\n\n    /**\n     * Upload a file to the media repository on the homeserver.\n     * @param file - The object to upload. Something that can be sent to\n     *               XMLHttpRequest.send (typically a File).\n     * @returns Resolves to the location of the uploaded file.\n     */\n    public uploadFile(file: XMLHttpRequestBodyInit): Promise<{ contentUri: string }> {\n        throw new Error(\"Upload file is not implemented\");\n    }\n\n    /**\n     * Download a file from the media repository on the homeserver.\n     * @param contentUri - MXC URI of the file to download.\n     * @returns Resolves to the contents of the file.\n     */\n    public downloadFile(contentUri: string): Promise<{ file: XMLHttpRequestBodyInit }> {\n        throw new Error(\"Download file is not implemented\");\n    }\n\n    /**\n     * Gets the IDs of all joined or invited rooms currently known to the\n     * client.\n     * @returns The room IDs.\n     */\n    public getKnownRooms(): string[] {\n        throw new Error(\"Querying known rooms is not implemented\");\n    }\n\n    /**\n     * Expresses an error thrown by this driver in a format compatible with the Widget API.\n     * @param error The error to handle.\n     * @returns The error expressed as a {@link IWidgetApiErrorResponseDataDetails},\n     * or undefined if it cannot be expressed as one.\n     */\n    public processError(error: unknown): IWidgetApiErrorResponseDataDetails | undefined {\n        return undefined;\n    }\n}\n"],"mappings":"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"}