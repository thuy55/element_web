{"version":3,"file":"lazy-loaded-session-recorder.js","sourceRoot":"","sources":["../../../../../src/extensions/replay/external/lazy-loaded-session-recorder.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4OA,kCAsBC;AAjQD,sCAOqB;AACrB,mCAAqD;AACrD,qDAoB0B;AAC1B,mEAAkH;AAClH,iCAAqD;AACrD,kDAAgH;AAChH,wCAAiD;AACjD,2DAAwD;AACxD,gDAAoD;AACpD,sCAUsB;AACtB,gDAK2B;AAY3B,8DAA0D;AAC1D,2DAAoC;AACpC,2CAAiD;AAEjD,IAAM,aAAa,GAAG,KAAK,CAAA;AAC3B,IAAM,sBAAsB,GAAG,GAAG,CAAA;AAClC,IAAM,kBAAkB,GAAG,CAAC,CAAA;AAC5B,IAAM,cAAc,GAAG,EAAE,CAAA;AACzB,IAAM,kBAAkB,GAAG,CAAC,CAAA;AAC5B,IAAM,WAAW,GAAG,IAAI,CAAA;AACxB,IAAM,MAAM,GAAG,IAAI,CAAA;AAEnB,IAAM,UAAU,GAAG,IAAI,GAAG,EAAE,CAAA;AAC5B,IAAM,YAAY,GAAG,UAAU,GAAG,CAAC,CAAA;AAEtB,QAAA,2BAA2B,GAAG,YAAY,CAAA;AAE1C,QAAA,wBAAwB,GAAG,MAAM,GAAG,MAAM,GAAG,GAAG,CAAA,CAAC,+BAA+B;AAChF,QAAA,wBAAwB,GAAG,IAAI,CAAA,CAAC,YAAY;AAC5C,QAAA,2BAA2B,GAAG,YAAY,CAAA;AAEvD,IAAM,aAAa,GAAG,oBAAoB,CAAA;AAC1C,IAAM,MAAM,GAAG,IAAA,qBAAY,EAAC,aAAa,CAAC,CAAA;AAwB1C,IAAM,cAAc,GAAG;IACnB,yBAAiB,CAAC,SAAS;IAC3B,yBAAiB,CAAC,gBAAgB;IAClC,yBAAiB,CAAC,MAAM;IACxB,yBAAiB,CAAC,cAAc;IAChC,yBAAiB,CAAC,KAAK;IACvB,yBAAiB,CAAC,SAAS;IAC3B,yBAAiB,CAAC,gBAAgB;IAClC,yBAAiB,CAAC,IAAI;CACzB,CAAA;AAED,IAAM,cAAc,GAAG,UAAC,WAAuB,IAAuB,OAAA,CAAC;IACnE,WAAW,aAAA;IACX,UAAU,EAAE,IAAI,CAAC,GAAG,EAAE;IACtB,OAAO,EAAE,CAAC;CACb,CAAC,EAJoE,CAIpE,CAAA;AAEF,SAAS,cAAc;;IACnB,OAAO,MAAA,MAAA,0BAAgB,aAAhB,0BAAgB,uBAAhB,0BAAgB,CAAE,qBAAqB,0CAAE,KAAK,0CAAE,MAAM,CAAA;AACjE,CAAC;AA0CD,SAAS,YAAY,CAAC,IAAa;IAC/B,OAAO,IAAA,kBAAS,EAAC,IAAA,iBAAQ,EAAC,IAAA,gBAAO,EAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAA;AACnE,CAAC;AAED;;;;;GAKG;AACH,SAAS,aAAa,CAAC,KAAoB;IACvC,IAAI,CAAC;QACD,IAAI,KAAK,CAAC,IAAI,KAAK,iBAAS,CAAC,YAAY,EAAE,CAAC;YACxC,6BACO,KAAK,KACR,IAAI,EAAE,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,EAC9B,EAAE,EAAE,SAAS,IAChB;QACL,CAAC;QACD,IAAI,KAAK,CAAC,IAAI,KAAK,iBAAS,CAAC,mBAAmB,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,KAAK,yBAAiB,CAAC,QAAQ,EAAE,CAAC;YACnG,6BACO,KAAK,KACR,EAAE,EAAE,SAAS,EACb,IAAI,wBACG,KAAK,CAAC,IAAI,KACb,KAAK,EAAE,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,EACrC,UAAU,EAAE,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,EAC/C,OAAO,EAAE,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,EACzC,IAAI,EAAE,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,OAE1C;QACL,CAAC;QACD,IAAI,KAAK,CAAC,IAAI,KAAK,iBAAS,CAAC,mBAAmB,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,KAAK,yBAAiB,CAAC,cAAc,EAAE,CAAC;YACzG,6BACO,KAAK,KACR,EAAE,EAAE,SAAS,EACb,IAAI,wBACG,KAAK,CAAC,IAAI,KACb,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS,EACjE,OAAO,EAAE,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,OAEjF;QACL,CAAC;IACL,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QACT,MAAM,CAAC,KAAK,CAAC,wDAAwD,EAAE,CAAC,CAAC,CAAA;IAC7E,CAAC;IACD,OAAO,KAAK,CAAA;AAChB,CAAC;AAED,SAAS,kBAAkB,CAAC,CAAgB;IACxC,OAAO,CAAC,CAAC,IAAI,KAAK,iBAAS,CAAC,MAAM,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,KAAK,aAAa,CAAA;AACtE,CAAC;AAED;;kDAEkD;AAClD,SAAS,sBAAsB,CAAC,CAAgB;IAC5C,OAAO,CAAC,CAAC,IAAI,KAAK,iBAAS,CAAC,MAAM,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,KAAK,kBAAkB,CAAA;AAC3E,CAAC;AAEY,QAAA,eAAe,GAAG,IAAI,GAAG,IAAI,GAAG,CAAC,GAAG,GAAG,CAAA,CAAC,+BAA+B;AAEpF,qDAAqD;AACrD,4DAA4D;AAC5D,SAAgB,WAAW,CAAC,MAAsB,EAAE,SAAmC;IAAnC,0BAAA,EAAA,YAAoB,uBAAe;IACnF,IAAI,MAAM,CAAC,IAAI,IAAI,SAAS,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACrD,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;QAC/C,IAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,CAAA;QAC5C,IAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA;QAC1C,OAAO;YACH,WAAW,CAAC;gBACR,IAAI,EAAE,IAAA,qCAAY,EAAC,SAAS,CAAC;gBAC7B,IAAI,EAAE,SAAS;gBACf,SAAS,EAAE,MAAM,CAAC,SAAS;gBAC3B,QAAQ,EAAE,MAAM,CAAC,QAAQ;aAC5B,CAAC;YACF,WAAW,CAAC;gBACR,IAAI,EAAE,IAAA,qCAAY,EAAC,UAAU,CAAC;gBAC9B,IAAI,EAAE,UAAU;gBAChB,SAAS,EAAE,MAAM,CAAC,SAAS;gBAC3B,QAAQ,EAAE,MAAM,CAAC,QAAQ;aAC5B,CAAC;SACL,CAAC,OAAO,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,EAAD,CAAC,CAAC,CAAA;IACvB,CAAC;SAAM,CAAC;QACJ,OAAO,CAAC,MAAM,CAAC,CAAA;IACnB,CAAC;AACL,CAAC;AAED;IA+EI,oCAA6B,SAAkB;QAA/C,iBAiBC;QAjB4B,cAAS,GAAT,SAAS,CAAS;QA9EvC,cAAS,GAAW,aAAa,CAAA;QAEzC;;WAEG;QACK,uCAAkC,GAAG,KAAK,CAAA;QAC1C,eAAU,GAAgC,SAAS,CAAA;QACnD,2BAAsB,GAAW,IAAI,CAAC,GAAG,EAAE,CAAA;QAMnD;;WAEG;QACK,uBAAkB,GAAuB,EAAE,CAAA;QAC3C,YAAO,GAAwB,SAAS,CAAA;QAKhD,iFAAiF;QACjF,6EAA6E;QACrE,qBAAgB,GAA0B,IAAI,wCAAsB,EAAE,CAAA;QAatE,+BAA0B,GAA6B,SAAS,CAAA;QAEhE,mCAA8B,GAA6B,SAAS,CAAA;QA+BpE,mBAAc,GAClB,iDAA+B,CAAA;QAE3B,yBAAoB,GAA6B,SAAS,CAAA;QAC1D,sCAAiC,GAA6B,SAAS,CAAA;QACvE,6BAAwB,GAA6B,SAAS,CAAA;QAC9D,gCAA2B,GAA6B,SAAS,CAAA;QAqZjE,yBAAoB,GAA6B,UAAC,SAAS,EAAE,QAAQ,EAAE,YAAY;YACvF,IAAI,YAAY,EAAE,CAAC;gBACf,KAAI,CAAC,kBAAkB,CAAC,oBAAoB,EAAE,EAAE,SAAS,WAAA,EAAE,QAAQ,UAAA,EAAE,YAAY,cAAA,EAAE,CAAC,CAAA;gBAEpF,KAAI,CAAC,qCAAqC,EAAE,CAAA;gBAE5C,IAAI,CAAC,KAAI,CAAC,UAAU,EAAE,CAAC;oBACnB,KAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,CAAA;gBACpC,CAAC;gBAED,IAAI,IAAA,eAAQ,EAAC,KAAI,CAAC,WAAW,CAAC,IAAI,IAAA,gBAAS,EAAC,KAAI,CAAC,wBAAwB,CAAC,EAAE,CAAC;oBACzE,KAAI,CAAC,qBAAqB,CAAC,SAAS,CAAC,CAAA;gBACzC,CAAC;YACL,CAAC;QACL,CAAC,CAAA;QAkTO,oBAAe,GAAG;YACtB,KAAI,CAAC,YAAY,EAAE,CAAA;QACvB,CAAC,CAAA;QAEO,eAAU,GAAG;YACjB,KAAI,CAAC,kBAAkB,CAAC,iBAAiB,EAAE,EAAE,CAAC,CAAA;QAClD,CAAC,CAAA;QAEO,cAAS,GAAG;YAChB,KAAI,CAAC,kBAAkB,CAAC,gBAAgB,EAAE,EAAE,CAAC,CAAA;QACjD,CAAC,CAAA;QAEO,wBAAmB,GAAG;YAC1B,IAAI,kBAAQ,aAAR,kBAAQ,uBAAR,kBAAQ,CAAE,eAAe,EAAE,CAAC;gBAC5B,IAAM,KAAK,GAAG,SAAS,GAAG,kBAAQ,CAAC,eAAe,CAAA;gBAClD,KAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,EAAE,CAAC,CAAA;YACtC,CAAC;QACL,CAAC,CAAA;QAnuBG,gFAAgF;QAC1E,IAAA,KAA0B,IAAI,CAAC,eAAe,CAAC,6BAA6B,EAAE,EAA5E,SAAS,eAAA,EAAE,QAAQ,cAAyD,CAAA;QACpF,IAAI,CAAC,UAAU,GAAG,SAAS,CAAA;QAC3B,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAA;QAEzB,IAAI,CAAC,mBAAmB,GAAG,IAAI,oCAAkB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;QACjE,IAAI,CAAC,mBAAmB,GAAG,IAAI,oCAAkB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;QACjE,IAAI,CAAC,qBAAqB,GAAG,IAAI,sCAAoB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;QAErE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,YAAY,EAAE,CAAA;QAElC,IAAI,IAAI,CAAC,iCAAiC,IAAI,IAAI,CAAC,eAAe,CAAC,gBAAgB,EAAE,CAAC;YAClF,MAAM,CAAC,IAAI,CACP,qCAA8B,IAAI,CAAC,iCAAiC,oDAA0C,IAAI,CAAC,eAAe,CAAC,gBAAgB,8CAA2C,CACjM,CAAA;QACL,CAAC;IACL,CAAC;IAlED,sBAAI,iDAAS;aAAb;YACI,OAAO,IAAI,CAAC,UAAU,CAAA;QAC1B,CAAC;;;OAAA;IAUD,sBAAY,uDAAe;aAA3B;YACI,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,cAAc,EAAE,CAAC;gBACjC,MAAM,IAAI,KAAK,CAAC,aAAa,GAAG,+CAA+C,CAAC,CAAA;YACpF,CAAC;YAED,OAAO,IAAI,CAAC,SAAS,CAAC,cAAc,CAAA;QACxC,CAAC;;;OAAA;IAED,sBAAY,yEAAiC;aAA7C;YACI,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,iBAAiB,CAAC,yBAAyB,IAAI,mCAA2B,CAAA;QAC3G,CAAC;;;OAAA;IAED,sBAAY,kDAAU;aAAtB;YACI,IAAM,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,wCAA4B,CAAC,CAAA;YAC9E,0DAA0D;YAC1D,iFAAiF;YACjF,OAAO,IAAA,gBAAS,EAAC,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,IAAA,eAAQ,EAAC,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,KAAK,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAA;QACnH,CAAC;;;OAAA;IAED,sBAAY,mDAAW;aAAvB;;YACI,IAAM,IAAI,GAAG,MAAA,IAAI,CAAC,aAAa,0CAAE,UAAU,CAAA;YAC3C,OAAO,IAAA,eAAQ,EAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAA;QACvC,CAAC;;;OAAA;IAED,sBAAY,wDAAgB;aAA5B;;YACI,IAAM,QAAQ,GAAG,MAAA,IAAI,CAAC,aAAa,0CAAE,2BAA2B,CAAA;YAChE,OAAO,IAAA,eAAQ,EAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAA;QAC/C,CAAC;;;OAAA;IA6BD,sBAAY,gDAAQ;aAApB;;YAGI,IAAM,mBAAmB,GAAG,MAAA,IAAI,CAAC,aAAa,0CAAE,OAAO,CAAA;YACvD,IAAM,mBAAmB,GAAG;gBACxB,aAAa,EAAE,MAAA,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,iBAAiB,0CAAE,aAAa;gBACrE,gBAAgB,EAAE,MAAA,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,iBAAiB,0CAAE,gBAAgB;gBAC3E,aAAa,EAAE,MAAA,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,iBAAiB,0CAAE,aAAa;aACxE,CAAA;YAED,IAAM,aAAa,GAAG,MAAA,mBAAmB,aAAnB,mBAAmB,uBAAnB,mBAAmB,CAAE,aAAa,mCAAI,mBAAmB,aAAnB,mBAAmB,uBAAnB,mBAAmB,CAAE,aAAa,CAAA;YAC9F,IAAM,gBAAgB,GAAG,MAAA,mBAAmB,aAAnB,mBAAmB,uBAAnB,mBAAmB,CAAE,gBAAgB,mCAAI,mBAAmB,aAAnB,mBAAmB,uBAAnB,mBAAmB,CAAE,gBAAgB,CAAA;YACvG,IAAM,aAAa,GAAG,MAAA,mBAAmB,aAAnB,mBAAmB,uBAAnB,mBAAmB,CAAE,aAAa,mCAAI,mBAAmB,aAAnB,mBAAmB,uBAAnB,mBAAmB,CAAE,aAAa,CAAA;YAE9F,OAAO,CAAC,IAAA,kBAAW,EAAC,aAAa,CAAC,IAAI,CAAC,IAAA,kBAAW,EAAC,gBAAgB,CAAC,IAAI,CAAC,IAAA,kBAAW,EAAC,aAAa,CAAC;gBAC/F,CAAC,CAAC;oBACI,aAAa,EAAE,aAAa,aAAb,aAAa,cAAb,aAAa,GAAI,IAAI;oBACpC,gBAAgB,kBAAA;oBAChB,aAAa,eAAA;iBAChB;gBACH,CAAC,CAAC,SAAS,CAAA;QACnB,CAAC;;;OAAA;IAED,sBAAY,wDAAgB;aAA5B;;YACI,IAAM,2BAA2B,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,iBAAiB,CAAC,aAAa,CAAA;YACzF,IAAM,2BAA2B,GAAG,MAAA,IAAI,CAAC,aAAa,0CAAE,eAAe,CAAA;YAEvE,IAAM,OAAO,GACT,MAAA,MAAA,2BAA2B,aAA3B,2BAA2B,uBAA3B,2BAA2B,CAAE,YAAY,mCAAI,2BAA2B,aAA3B,2BAA2B,uBAA3B,2BAA2B,CAAE,OAAO,mCAAI,KAAK,CAAA;YAC9F,IAAM,GAAG,GACL,MAAA,MAAA,2BAA2B,aAA3B,2BAA2B,uBAA3B,2BAA2B,CAAE,SAAS,mCAAI,2BAA2B,aAA3B,2BAA2B,uBAA3B,2BAA2B,CAAE,GAAG,mCAAI,kBAAkB,CAAA;YACpG,IAAI,OAAO,GACP,MAAA,MAAA,2BAA2B,aAA3B,2BAA2B,uBAA3B,2BAA2B,CAAE,aAAa,mCAAI,2BAA2B,aAA3B,2BAA2B,uBAA3B,2BAA2B,CAAE,OAAO,mCAAI,sBAAsB,CAAA;YAChH,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,CAAC;gBAC9B,IAAM,MAAM,GAAG,UAAU,CAAC,OAAO,CAAC,CAAA;gBAClC,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAA;YAC1C,CAAC;YAED,OAAO;gBACH,OAAO,SAAA;gBACP,GAAG,EAAE,IAAA,mBAAY,EAAC,GAAG,EAAE,CAAC,EAAE,cAAc,EAAE,IAAA,qBAAY,EAAC,sBAAsB,CAAC,EAAE,kBAAkB,CAAC;gBACnG,OAAO,EAAE,IAAA,mBAAY,EACjB,OAAO,EACP,CAAC,EACD,kBAAkB,EAClB,IAAA,qBAAY,EAAC,0BAA0B,CAAC,EACxC,sBAAsB,CACzB;aACJ,CAAA;QACL,CAAC;;;OAAA;IAED,sBAAY,mEAA2B;aAAvC;;YACI,IAAM,mBAAmB,GAAG,CAAC,CAAC,CAAA,MAAA,IAAI,CAAC,aAAa,0CAAE,0BAA0B,CAAA,CAAA;YAC5E,IAAM,mBAAmB,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,4BAA4B,CAAA;YAC9E,OAAO,mBAAmB,aAAnB,mBAAmB,cAAnB,mBAAmB,GAAI,mBAAmB,CAAA;QACrD,CAAC;;;OAAA;IAID,sBAAY,8DAAsB;QAFlC,iDAAiD;QACjD,oDAAoD;aACpD;;YAGI,IAAM,iCAAiC,GAAG,MAAA,IAAI,CAAC,aAAa,0CAAE,qBAAqB,CAAA;YACnF,IAAM,iCAAiC,GAAG;gBACtC,aAAa,EAAE,MAAA,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,iBAAiB,0CAAE,aAAa;gBACrE,UAAU,EAAE,MAAA,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,iBAAiB,0CAAE,UAAU;aAClE,CAAA;YACD,IAAM,cAAc,GAChB,CAAA,iCAAiC,aAAjC,iCAAiC,uBAAjC,iCAAiC,CAAE,aAAa,MAAI,iCAAiC,aAAjC,iCAAiC,uBAAjC,iCAAiC,CAAE,aAAa,CAAA,CAAA;YACxG,IAAM,WAAW,GACb,CAAA,iCAAiC,aAAjC,iCAAiC,uBAAjC,iCAAiC,CAAE,UAAU,MAAI,iCAAiC,aAAjC,iCAAiC,uBAAjC,iCAAiC,CAAE,UAAU,CAAA,CAAA;YAClG,IAAM,iCAAiC,GAAG,IAAA,eAAQ,EAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,mBAAmB,CAAC;gBACzF,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,mBAAmB,CAAC,cAAc;gBAC1D,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,mBAAmB,CAAA;YAC/C,IAAM,oBAAoB,GAAG,CAAC,CAAC,CAAC,IAAA,gBAAS,EAAC,iCAAiC,CAAC;gBACxE,CAAC,CAAC,iCAAiC;gBACnC,CAAC,CAAC,iCAAiC,aAAjC,iCAAiC,uBAAjC,iCAAiC,CAAE,kBAAkB,CAAC,CAAA;YAE5D,OAAO,cAAc,IAAI,WAAW,IAAI,oBAAoB;gBACxD,CAAC,CAAC,EAAE,aAAa,EAAE,cAAc,EAAE,UAAU,EAAE,WAAW,EAAE,iBAAiB,EAAE,oBAAoB,EAAE;gBACrG,CAAC,CAAC,SAAS,CAAA;QACnB,CAAC;;;OAAA;IAEO,wDAAmB,GAA3B;;QACI,IAAM,OAAO,GAAmB,EAAE,CAAA;QAElC,IAAM,mBAAmB,GAAG,MAAA,MAAA,0BAAgB,CAAC,qBAAqB,0CAAE,YAAY,0CAAE,sBAAsB,CAAA;QACxG,IAAI,mBAAmB,IAAI,IAAI,CAAC,2BAA2B,EAAE,CAAC;YAC1D,OAAO,CAAC,IAAI,CAAC,mBAAmB,EAAE,CAAC,CAAA;QACvC,CAAC;QAED,IAAM,aAAa,GAAG,MAAA,MAAA,0BAAgB,CAAC,qBAAqB,0CAAE,YAAY,0CAAE,sBAAsB,CAAA;QAClG,IAAI,CAAC,CAAC,IAAI,CAAC,sBAAsB,IAAI,IAAA,iBAAU,EAAC,aAAa,CAAC,EAAE,CAAC;YAC7D,IAAM,gBAAgB,GAAG,CAAC,IAAA,2BAAW,GAAE,IAAI,IAAI,CAAC,kCAAkC,CAAA;YAElF,IAAI,gBAAgB,EAAE,CAAC;gBACnB,OAAO,CAAC,IAAI,CACR,aAAa,CAAC,IAAA,mCAA0B,EAAC,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAChG,CAAA;YACL,CAAC;iBAAM,CAAC;gBACJ,MAAM,CAAC,IAAI,CAAC,yDAAyD,CAAC,CAAA;YAC1E,CAAC;QACL,CAAC;QAED,OAAO,OAAO,CAAA;IAClB,CAAC;IAEO,6CAAQ,GAAhB,UAAiB,GAAW;QACxB,IAAM,2BAA2B,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,iBAAiB,CAAA;QAE3E,IAAI,2BAA2B,CAAC,oBAAoB,EAAE,CAAC;YACnD,IAAI,cAAc,GAAsC;gBACpD,GAAG,KAAA;aACN,CAAA;YAED,wGAAwG;YACxG,2GAA2G;YAC3G,cAAc,GAAG,2BAA2B,CAAC,oBAAoB,CAAC,cAAc,CAAC,CAAA;YAEjF,OAAO,cAAc,aAAd,cAAc,uBAAd,cAAc,CAAE,GAAG,CAAA;QAC9B,CAAC;QAED,OAAO,GAAG,CAAA;IACd,CAAC;IAEO,oDAAe,GAAvB,UAAwB,gBAAkC;QACtD,IAAI,CAAC;YACD,gBAAgB,CAAC,WAAW,EAAE,CAAA;YAC9B,OAAO,IAAI,CAAA;QACf,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC;YACT,yEAAyE;YACzE,IAAI,IAAI,CAAC,kBAAkB,CAAC,MAAM,GAAG,EAAE,EAAE,CAAC;gBACtC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC;oBACzB,UAAU,EAAE,gBAAgB,CAAC,UAAU,IAAI,IAAI,CAAC,GAAG,EAAE;oBACrD,OAAO,EAAE,gBAAgB,CAAC,OAAO,GAAG,CAAC;oBACrC,WAAW,EAAE,gBAAgB,CAAC,WAAW;iBAC5C,CAAC,CAAA;YACN,CAAC;iBAAM,CAAC;gBACJ,MAAM,CAAC,IAAI,CAAC,oCAAoC,EAAE,CAAC,EAAE,gBAAgB,CAAC,CAAA;YAC1E,CAAC;YAED,OAAO,KAAK,CAAA;QAChB,CAAC;IACL,CAAC;IAEO,uDAAkB,GAA1B,UAA2B,GAAW,EAAE,OAAY;QAChD,OAAO,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,cAAM,OAAA,cAAc,EAAG,CAAC,cAAc,CAAC,GAAG,EAAE,OAAO,CAAC,EAA9C,CAA8C,CAAC,CAAC,CAAA;IACrG,CAAC;IAEO,sDAAiB,GAAzB;QACI,IAAI,CAAC;YACD,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,gBAAgB,IAAI,CAAC,gBAAM,EAAE,CAAC;gBACpD,OAAM;YACV,CAAC;YACD,iEAAiE;YACjE,8DAA8D;YAC9D,8DAA8D;YAC9D,yCAAyC;YACzC,IAAM,GAAG,GAAG,IAAI,GAAG,CAAC,gBAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAA;YACzC,IAAM,eAAe,GAAG,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,QAAQ,GAAG,GAAG,CAAC,MAAM,CAAA;YAC9D,IAAM,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,CAAA;YACjD,IAAI,IAAI,CAAC,SAAS,KAAK,UAAU,EAAE,CAAC;gBAChC,IAAI,CAAC,SAAS,GAAG,UAAU,CAAA;gBAC3B,IAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC,CAAA;YACjE,CAAC;QACL,CAAC;QAAC,WAAM,CAAC;YACL,kDAAkD;QACtD,CAAC;IACL,CAAC;IAEO,yDAAoB,GAA5B;QAAA,iBAoBC;QAnBG,IAAI,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,CAAC;YACjC,yEAAyE;YACzE,wEAAwE;YACxE,yEAAyE;YACzE,yEAAyE;YACzE,wDAAwD;YACxD,8BAA8B;YAC9B,mEAAmE;YACnE,qCAAqC;YACrC,sEAAsE;YACtE,oDAAoD;YACpD,IAAM,cAAc,4BAAO,IAAI,CAAC,kBAAkB,SAAC,CAAA;YACnD,IAAI,CAAC,kBAAkB,GAAG,EAAE,CAAA;YAC5B,cAAc,CAAC,OAAO,CAAC,UAAC,gBAAgB;gBACpC,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,gBAAgB,CAAC,UAAU,IAAI,WAAW,EAAE,CAAC;oBAC1D,KAAI,CAAC,eAAe,CAAC,gBAAgB,CAAC,CAAA;gBAC1C,CAAC;YACL,CAAC,CAAC,CAAA;QACN,CAAC;IACL,CAAC;IAEO,yDAAoB,GAA5B;QACI,OAAO,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,cAAM,OAAA,cAAc,EAAG,CAAC,gBAAgB,EAAE,EAApC,CAAoC,CAAC,CAAC,CAAA;IAC3F,CAAC;IAED,sBAAY,mEAA2B;aAAvC;;YACI,IACI,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,iCAAe;gBACvE,CAAC,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,EAC9C,CAAC;gBACC,OAAO,UAAU,CAAA;YACrB,CAAC;YAED,OAAO,MAAA,MAAA,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,iBAAiB,0CAAE,6BAA6B,mCAAI,YAAY,CAAA;QACjG,CAAC;;;OAAA;IAEO,0DAAqB,GAA7B;QAAA,iBAiBC;QAhBG,IAAI,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC1B,aAAa,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAA;QAC1C,CAAC;QACD,yCAAyC;QACzC,IAAI,IAAI,CAAC,OAAO,KAAK,IAAI,EAAE,CAAC;YACxB,OAAM;QACV,CAAC;QAED,IAAM,QAAQ,GAAG,IAAI,CAAC,2BAA2B,CAAA;QACjD,IAAI,CAAC,QAAQ,EAAE,CAAC;YACZ,OAAM;QACV,CAAC;QAED,IAAI,CAAC,kBAAkB,GAAG,WAAW,CAAC;YAClC,KAAI,CAAC,oBAAoB,EAAE,CAAA;QAC/B,CAAC,EAAE,QAAQ,CAAC,CAAA;IAChB,CAAC;IAEO,oDAAe,GAAvB;QACI,+EAA+E;QAC/E,IAAI,IAAI,CAAC,mBAAmB,CAAC,UAAU,EAAE,CAAC;YACtC,OAAM;QACV,CAAC;QAED,oFAAoF;QACpF,yDAAyD;QACzD,wFAAwF;QACxF,qEAAqE;QACrE,IAAI,CAAC,mBAAmB,CAAC,UAAU,GAAG,IAAI,CAAA;QAE1C,0EAA0E;QAC1E,aAAa,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAA;QAEtC,MAAM,CAAC,IAAI,CAAC,qCAAqC,CAAC,CAAA;QAClD,IAAI,CAAC,kBAAkB,CAAC,kBAAkB,EAAE,EAAE,MAAM,EAAE,aAAa,EAAE,CAAC,CAAA;IAC1E,CAAC;IAEO,qDAAgB,GAAxB;QACI,+EAA+E;QAC/E,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,UAAU,EAAE,CAAC;YACvC,OAAM;QACV,CAAC;QAED,IAAI,CAAC,mBAAmB,CAAC,UAAU,GAAG,KAAK,CAAA;QAE3C,IAAI,CAAC,oBAAoB,EAAE,CAAA;QAC3B,IAAI,CAAC,qBAAqB,EAAE,CAAA;QAE5B,IAAI,CAAC,kBAAkB,CAAC,mBAAmB,EAAE,EAAE,MAAM,EAAE,kBAAkB,EAAE,CAAC,CAAA;QAC5E,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAA;IACpC,CAAC;IAEO,qDAAgB,GAAxB,UAAyB,WAAwB;;;QAC7C,IAAI,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,iCAAe,EAAE,CAAC;YAC1E,yDAAyD;YACzD,MAAA,MAAA,IAAI,CAAC,SAAS,0CAAE,WAAW,0CAAE,QAAQ;gBACjC,GAAC,WAAW,KAAK,KAAK;oBAClB,CAAC,CAAC,2DAA+C;oBACjD,CAAC,CAAC,6DAAiD,IAAG,IAAI,CAAC,UAAU;oBAC3E,CAAA;YAEF,IAAI,CAAC,YAAY,EAAE,CAAA;YACnB,IAAI,CAAC,cAAc,CAAC,CAAC,WAAW,GAAG,kBAAkB,CAAuB,CAAC,CAAA;QACjF,CAAC;IACL,CAAC;IAED,sBAAI,iDAAS;aAAb;YACI,OAAO,CAAC,CAAC,IAAI,CAAC,UAAU,CAAA;QAC5B,CAAC;;;OAAA;IAED,sBAAI,qDAAa;aAAjB;YACI,IAAM,eAAe,GAAQ,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,2CAA+B,CAAC,CAAA;YACzF,IAAI,CAAC,eAAe,EAAE,CAAC;gBACnB,OAAO,SAAS,CAAA;YACpB,CAAC;YACD,IAAM,YAAY,GAAG,IAAA,eAAQ,EAAC,eAAe,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAA;YAC9F,OAAO,YAA+C,CAAA;QAC1D,CAAC;;;OAAA;IAED,0CAAK,GAAL,UAAM,WAAgC;QAAtC,iBA+FC;;QA9FG,IAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAA;QACjC,IAAI,CAAC,MAAM,EAAE,CAAC;YACV,MAAM,CAAC,IAAI,CAAC,wEAAwE,CAAC,CAAA;YACrF,OAAM;QACV,CAAC;QAED,qFAAqF;QACrF,IAAI,CAAC,eAAe,CAAC,6BAA6B,EAAE,CAAA;QAEpD,IAAI,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,QAAQ,EAAE,CAAC;YACnB,IAAI,CAAC,SAAS,GAAG,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,QAAQ,CAAA;QACrC,CAAC;QAED,IAAI,CAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,gBAAgB,MAAK,KAAK,EAAE,CAAC;YACrC,IAAI,CAAC,cAAc,GAAG,gDAA8B,CAAA;YACpD,IAAI,CAAC,gBAAgB,GAAG,IAAI,mCAAiB,CAAC,CAAC,IAAI,CAAC,qBAAqB,EAAE,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAA;QACzG,CAAC;aAAM,CAAC;YACJ,8BAA8B;YAC9B,wCAAwC;YACxC,IAAI,CAAC,cAAc,GAAG,gDAA8B,CAAA;YACpD,IAAI,CAAC,gBAAgB,GAAG,IAAI,oCAAkB,CAAC,CAAC,IAAI,CAAC,qBAAqB,EAAE,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAA;QAC1G,CAAC;QACD,IAAI,CAAC,SAAS,CAAC,oBAAoB,CAAC;YAChC,gDAAgD,EAAE,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,gBAAgB;SAC7E,CAAC,CAAA;QAEF,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAA;QAEzC,IAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAA;QAC3C,MAAA,IAAI,CAAC,8BAA8B,oDAAI,CAAA;QACvC,IAAI,CAAC,wBAAwB,EAAE,CAAA;QAE/B,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,MAAM,EAAE,UAAC,IAAI,EAAE,OAAO;YACpD,KAAI,CAAC,cAAc,CAAC,qBAAqB,EAAE;gBACvC,IAAI,MAAA;gBACJ,OAAO,SAAA;aACV,CAAC,CAAA;QACN,CAAC,CAAC,CAAA;QAEF,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;QAC1C,IAAI,CAAC,cAAc,EAAE,CAAA;QAErB,8EAA8E;QAC9E,IAAA,wBAAgB,EAAC,gBAAM,EAAE,cAAc,EAAE,IAAI,CAAC,eAAe,CAAC,CAAA;QAC9D,IAAA,wBAAgB,EAAC,gBAAM,EAAE,SAAS,EAAE,IAAI,CAAC,UAAU,CAAC,CAAA;QACpD,IAAA,wBAAgB,EAAC,gBAAM,EAAE,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAA;QAClD,IAAA,wBAAgB,EAAC,gBAAM,EAAE,kBAAkB,EAAE,IAAI,CAAC,mBAAmB,CAAC,CAAA;QAEtE,IAAI,CAAC,IAAI,CAAC,oBAAoB,EAAE,CAAC;YAC7B,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAA;QAC3F,CAAC;QAED,IAAI,CAAC,IAAI,CAAC,iCAAiC,EAAE,CAAC;YAC1C,IAAI,CAAC,iCAAiC,GAAG,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,iBAAiB,EAAE;gBAChF,yEAAyE;gBACzE,KAAI,CAAC,qCAAqC,EAAE,CAAA;gBAC5C,KAAI,CAAC,OAAO,GAAG,SAAS,CAAA;gBACxB,KAAI,CAAC,IAAI,EAAE,CAAA;gBACX,wFAAwF;gBACxF,KAAI,CAAC,2BAA2B,GAAG,KAAI,CAAC,eAAe,CAAC,WAAW,CAC/D,UAAC,SAAS,EAAE,QAAQ,EAAE,YAAY;;oBAC9B,sCAAsC;oBACtC,MAAA,KAAI,CAAC,2BAA2B,qDAAI,CAAA;oBACpC,KAAI,CAAC,2BAA2B,GAAG,SAAS,CAAA;oBAC5C,KAAI,CAAC,oBAAoB,CAAC,SAAS,EAAE,QAAQ,EAAE,YAAY,CAAC,CAAA;gBAChE,CAAC,CACJ,CAAA;YACL,CAAC,CAAC,CAAA;QACN,CAAC;QAED,IAAI,IAAA,gBAAS,EAAC,IAAI,CAAC,0BAA0B,CAAC,EAAE,CAAC;YAC7C,0HAA0H;YAC1H,wEAAwE;YACxE,IAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,eAAe,EAAE,UAAC,KAAK;gBACvE,mCAAmC;gBACnC,+CAA+C;gBAC/C,0BAA0B;gBAC1B,IAAI,CAAC;oBACD,IAAI,KAAK,CAAC,KAAK,KAAK,WAAW,EAAE,CAAC;wBAC9B,IAAM,IAAI,GAAG,CAAA,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,UAAU,CAAC,YAAY,EAAC,CAAC,CAAC,KAAI,CAAC,QAAQ,CAAC,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,EAAE,CAAA;wBAChG,IAAI,CAAC,IAAI,EAAE,CAAC;4BACR,OAAM;wBACV,CAAC;wBACD,KAAI,CAAC,kBAAkB,CAAC,WAAW,EAAE,EAAE,IAAI,MAAA,EAAE,CAAC,CAAA;oBAClD,CAAC;gBACL,CAAC;gBAAC,OAAO,CAAC,EAAE,CAAC;oBACT,MAAM,CAAC,KAAK,CAAC,0CAA0C,EAAE,CAAC,CAAC,CAAA;gBAC/D,CAAC;YACL,CAAC,CAAC,CAAA;QACN,CAAC;QAED,IAAI,IAAI,CAAC,MAAM,KAAK,wBAAM,EAAE,CAAC;YACzB,IAAI,CAAC,cAAc,CAAC,WAAW,IAAI,uBAAuB,CAAC,CAAA;QAC/D,CAAC;IACL,CAAC;IAkBD,yCAAI,GAAJ;;QACI,gBAAM,aAAN,gBAAM,uBAAN,gBAAM,CAAE,mBAAmB,CAAC,cAAc,EAAE,IAAI,CAAC,eAAe,CAAC,CAAA;QACjE,gBAAM,aAAN,gBAAM,uBAAN,gBAAM,CAAE,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAAC,UAAU,CAAC,CAAA;QACvD,gBAAM,aAAN,gBAAM,uBAAN,gBAAM,CAAE,mBAAmB,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAA;QACrD,gBAAM,aAAN,gBAAM,uBAAN,gBAAM,CAAE,mBAAmB,CAAC,kBAAkB,EAAE,IAAI,CAAC,mBAAmB,CAAC,CAAA;QAEzE,IAAI,CAAC,YAAY,EAAE,CAAA;QACnB,aAAa,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAA;QACtC,IAAI,CAAC,sBAAsB,EAAE,CAAA;QAE7B,MAAA,IAAI,CAAC,0BAA0B,oDAAI,CAAA;QACnC,IAAI,CAAC,0BAA0B,GAAG,SAAS,CAAA;QAC3C,MAAA,IAAI,CAAC,8BAA8B,oDAAI,CAAA;QACvC,IAAI,CAAC,8BAA8B,GAAG,SAAS,CAAA;QAC/C,MAAA,IAAI,CAAC,oBAAoB,oDAAI,CAAA;QAC7B,IAAI,CAAC,oBAAoB,GAAG,SAAS,CAAA;QACrC,MAAA,IAAI,CAAC,iCAAiC,oDAAI,CAAA;QAC1C,IAAI,CAAC,iCAAiC,GAAG,SAAS,CAAA;QAClD,MAAA,IAAI,CAAC,wBAAwB,oDAAI,CAAA;QACjC,IAAI,CAAC,wBAAwB,GAAG,SAAS,CAAA;QACzC,MAAA,IAAI,CAAC,2BAA2B,oDAAI,CAAA;QACpC,IAAI,CAAC,2BAA2B,GAAG,SAAS,CAAA;QAE5C,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,CAAA;QACjC,IAAI,CAAC,mBAAmB,CAAC,IAAI,EAAE,CAAA;QAC/B,IAAI,CAAC,mBAAmB,CAAC,IAAI,EAAE,CAAA;QAE/B,MAAA,IAAI,CAAC,kBAAkB,0CAAE,IAAI,EAAE,CAAA;QAE/B,sEAAsE;QACtE,IAAI,CAAC,kBAAkB,GAAG,EAAE,CAAA;QAE5B,MAAA,IAAI,CAAC,UAAU,oDAAI,CAAA;QACnB,IAAI,CAAC,UAAU,GAAG,SAAS,CAAA;QAE3B,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;IAC1B,CAAC;IAED,gDAAW,GAAX,UAAY,QAAuB;QAAnC,iBA4FC;;QA3FG,IAAI,CAAC,oBAAoB,EAAE,CAAA;QAE3B,IAAI,CAAC,QAAQ,IAAI,CAAC,IAAA,eAAQ,EAAC,QAAQ,CAAC,EAAE,CAAC;YACnC,OAAM;QACV,CAAC;QAED,IAAI,QAAQ,CAAC,IAAI,KAAK,iBAAS,CAAC,IAAI,EAAE,CAAC;YACnC,IAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;YAC9C,IAAI,CAAC,SAAS,GAAG,IAAI,CAAA;YACrB,IAAI,CAAC,IAAI,EAAE,CAAC;gBACR,OAAM;YACV,CAAC;YACD,QAAQ,CAAC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;QAC7B,CAAC;aAAM,CAAC;YACJ,IAAI,CAAC,iBAAiB,EAAE,CAAA;QAC5B,CAAC;QAED,gDAAgD;QAChD,IAAI,CAAC,mBAAmB,CAAC,yBAAyB,CAC9C,cAAM,OAAA,KAAI,CAAC,eAAe,EAAE,EAAtB,CAAsB,EAC5B,cAAM,OAAA,KAAI,CAAC,gBAAgB,EAAE,EAAvB,CAAuB,EAC7B,UAAC,WAAW,IAAK,OAAA,KAAI,CAAC,gBAAgB,CAAC,WAAW,CAAC,EAAlC,CAAkC,CACtD,CAAA;QACD,2DAA2D;QAC3D,sCAAsC;QACtC,IAAI,IAAI,CAAC,mBAAmB,CAAC,UAAU,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,EAAE,CAAC;YAC3E,OAAM;QACV,CAAC;QAED,iEAAiE;QACjE,IAAI,QAAQ,CAAC,IAAI,KAAK,iBAAS,CAAC,YAAY,EAAE,CAAC;YAC3C,IAAI,CAAC,qBAAqB,EAAE,CAAA;YAC5B,2EAA2E;YAC3E,MAAA,IAAI,CAAC,kBAAkB,0CAAE,KAAK,EAAE,CAAA;QACpC,CAAC;QAED,oGAAoG;QACpG,mGAAmG;QACnG,IACI,QAAQ,CAAC,IAAI,KAAK,iBAAS,CAAC,YAAY;YACxC,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,iCAAe,EACzE,CAAC;YACC,IAAI,CAAC,gCAAgC,EAAE,CAAA;QAC3C,CAAC;QAED,IAAM,cAAc,GAAG,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAA;QAE/G,IAAI,CAAC,cAAc,EAAE,CAAC;YAClB,OAAM;QACV,CAAC;QAED,gEAAgE;QAChE,IAAM,KAAK,GAAG,IAAA,iDAAwB,EAAC,cAAc,CAAC,CAAA;QAEtD,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC,CAAA;QAEtC,wEAAwE;QACxE,qDAAqD;QACrD,IAAI,IAAI,CAAC,OAAO,KAAK,IAAI,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,EAAE,CAAC;YACtD,OAAM;QACV,CAAC;QAED,IAAI,kBAAkB,CAAC,KAAK,CAAC,EAAE,CAAC;YAC5B,4DAA4D;YAC5D,4CAA4C;YAC5C,iFAAiF;YACjF,IAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC,OAA6B,CAAA;YACxD,IAAI,OAAO,EAAE,CAAC;gBACV,IAAM,YAAY,GAAG,OAAO,CAAC,qBAAqB,CAAA;gBAClD,IAAM,SAAS,GAAG,OAAO,CAAC,SAAS,CAAA;gBACnC,KAAK,CAAC,SAAS,GAAG,YAAY,GAAG,SAAS,CAAA;YAC9C,CAAC;QACL,CAAC;QAED,IAAM,WAAW,GACb,CAAC,MAAA,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,iBAAiB,CAAC,eAAe,mCAAI,IAAI,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAA;QACpG,IAAM,IAAI,GAAG,IAAA,qCAAY,EAAC,WAAW,CAAC,CAAA;QAEtC,IAAM,UAAU,GAAG;YACf,eAAe,EAAE,IAAI;YACrB,cAAc,EAAE,WAAW;YAC3B,WAAW,EAAE,IAAI,CAAC,UAAU;YAC5B,UAAU,EAAE,IAAI,CAAC,SAAS;SAC7B,CAAA;QAED,IAAI,IAAI,CAAC,MAAM,KAAK,0BAAQ,EAAE,CAAC;YAC3B,IAAI,CAAC,YAAY,EAAE,CAAA;YACnB,OAAM;QACV,CAAC;QAED,IAAI,CAAC,wBAAwB,CAAC,UAAU,CAAC,CAAA;IAC7C,CAAC;IAED,sBAAI,8CAAM;aAAV;YACI,OAAO,IAAI,CAAC,cAAc,CAAC;gBACvB,oDAAoD;gBACpD,aAAa,EAAE,IAAI;gBACnB,kBAAkB,EAAE,IAAI;gBACxB,4BAA4B;gBAC5B,SAAS,EAAE,IAAI,CAAC,UAAU;gBAC1B,kBAAkB,EAAE,IAAI,CAAC,mBAAmB;gBAC5C,oBAAoB,EAAE,IAAI,CAAC,qBAAqB;gBAChD,kBAAkB,EAAE,IAAI,CAAC,mBAAmB;gBAC5C,SAAS,EAAE,IAAI,CAAC,SAAS;aAC5B,CAAC,CAAA;QACN,CAAC;;;OAAA;IAED,wCAAG,GAAH,UAAI,OAAe,EAAE,KAAuC;;QAAvC,sBAAA,EAAA,aAAuC;QACxD,MAAA,IAAI,CAAC,SAAS,CAAC,gBAAgB,0CAAE,WAAW,CAAC;YACzC,IAAI,EAAE,CAAC;YACP,IAAI,EAAE;gBACF,MAAM,EAAE,iBAAiB;gBACzB,OAAO,EAAE;oBACL,KAAK,OAAA;oBACL,KAAK,EAAE,EAAE;oBACT,2EAA2E;oBAC3E,OAAO,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;iBACrC;aACJ;YACD,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE;SACxB,CAAC,CAAA;IACN,CAAC;IAEM,uDAAkB,GAAzB;QACI,IAAI,CAAC,mBAAmB,CAAC,cAAc,GAAG,IAAI,CAAA;QAC9C,IAAI,CAAC,oBAAoB,EAAE,CAAA;QAC3B,IAAI,CAAC,cAAc,CAAC,wBAAwB,CAAC,CAAA;IACjD,CAAC;IAED;;;;;SAKK;IACE,qDAAgB,GAAvB;;;QACI,MAAA,IAAI,CAAC,SAAS,CAAC,WAAW,0CAAE,QAAQ;YAChC,qFAAqF;YACrF,GAAC,wCAA4B,IAAG,IAAI,CAAC,SAAS;gBAChD,CAAA;QACF,IAAI,CAAC,oBAAoB,EAAE,CAAA;QAC3B,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,CAAA;IAC9C,CAAC;IAED;;;;;SAKK;IACE,oDAAe,GAAtB,UAAuB,WAAwB;QAC3C,IAAI,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAA;IACtC,CAAC;IAEO,2DAAsB,GAA9B;QACI,IAAI,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACzB,YAAY,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAA;YACpC,IAAI,CAAC,iBAAiB,GAAG,SAAS,CAAA;QACtC,CAAC;IACL,CAAC;IAEO,iDAAY,GAApB;QAAA,iBAkCC;QAjCG,IAAI,CAAC,sBAAsB,EAAE,CAAA;QAE7B,IAAM,eAAe,GAAG,IAAI,CAAC,gBAAgB,CAAA;QAC7C,IAAM,eAAe,GAAG,IAAI,CAAC,gBAAgB,CAAA;QAC7C,0EAA0E;QAC1E,+EAA+E;QAC/E,IAAM,yBAAyB,GAAG,IAAA,eAAQ,EAAC,eAAe,CAAC,IAAI,eAAe,IAAI,CAAC,CAAA;QACnF,IAAM,sBAAsB,GACxB,IAAA,eAAQ,EAAC,eAAe,CAAC,IAAI,yBAAyB,IAAI,eAAe,GAAG,eAAe,CAAA;QAE/F,IAAI,IAAI,CAAC,MAAM,KAAK,2BAAS,IAAI,IAAI,CAAC,MAAM,KAAK,wBAAM,IAAI,IAAI,CAAC,MAAM,KAAK,0BAAQ,IAAI,sBAAsB,EAAE,CAAC;YAC5G,IAAI,CAAC,iBAAiB,GAAG,UAAU,CAAC;gBAChC,KAAI,CAAC,YAAY,EAAE,CAAA;YACvB,CAAC,EAAE,gCAAwB,CAAC,CAAA;YAC5B,OAAO,IAAI,CAAC,OAAO,CAAA;QACvB,CAAC;QAED,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC/B,IAAM,cAAc,GAAG,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;YAChD,cAAc,CAAC,OAAO,CAAC,UAAC,cAAc;gBAClC,KAAI,CAAC,gBAAgB,CAAC;oBAClB,eAAe,EAAE,cAAc,CAAC,IAAI;oBACpC,cAAc,EAAE,cAAc,CAAC,IAAI;oBACnC,WAAW,EAAE,cAAc,CAAC,SAAS;oBACrC,UAAU,EAAE,cAAc,CAAC,QAAQ;oBACnC,IAAI,EAAE,KAAK;oBACX,YAAY,EAAE,gBAAM,CAAC,WAAW;iBACnC,CAAC,CAAA;YACN,CAAC,CAAC,CAAA;QACN,CAAC;QAED,kEAAkE;QAClE,OAAO,IAAI,CAAC,YAAY,EAAE,CAAA;IAC9B,CAAC;IAEO,6DAAwB,GAAhC,UAAiC,UAAsB;QAAvD,iBAkBC;;QAjBG,IAAM,eAAe,GAAG,CAAC,GAAG,CAAC,CAAA,MAAA,IAAI,CAAC,OAAO,0CAAE,IAAI,CAAC,MAAM,KAAI,CAAC,CAAC,CAAA,CAAC,2DAA2D;QACxH,IACI,CAAC,IAAI,CAAC,OAAO,IAAI,mCAAmC;YACpD,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,GAAG,UAAU,CAAC,eAAe,GAAG,eAAe,GAAG,gCAAwB;gBACxF,IAAI,CAAC,OAAO,CAAC,SAAS,KAAK,IAAI,CAAC,UAAU,CAAC,EACjD,CAAC;YACC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,YAAY,EAAE,CAAA;QACtC,CAAC;QAED,IAAI,CAAC,OAAO,CAAC,IAAI,IAAI,UAAU,CAAC,eAAe,CAAA;QAC/C,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,CAAA;QAEjD,IAAI,CAAC,IAAI,CAAC,iBAAiB,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YAC3C,IAAI,CAAC,iBAAiB,GAAG,UAAU,CAAC;gBAChC,KAAI,CAAC,YAAY,EAAE,CAAA;YACvB,CAAC,EAAE,gCAAwB,CAAC,CAAA;QAChC,CAAC;IACL,CAAC;IAEO,qDAAgB,GAAxB,UAAyB,UAAsB;QAC3C,oGAAoG;QACpG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,WAAW,EAAE,UAAU,EAAE;YAC5C,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC;YACrE,WAAW,EAAE,IAAI;YACjB,SAAS,EAAE,mCAA2B;YACtC,yBAAyB,EAAE,IAAI;SAClC,CAAC,CAAA;IACN,CAAC;IAED,sBAAY,wDAAgB;aAA5B;;YACI,IAAM,kBAAkB,GAAG,MAAA,IAAI,CAAC,OAAO,0CAAE,IAAI,CAAC,CAAA,MAAA,IAAI,CAAC,OAAO,0CAAE,IAAI,CAAC,MAAM,IAAG,CAAC,CAAC,CAAA;YACpE,IAAA,qBAAqB,GAAK,IAAI,CAAC,eAAe,CAAC,6BAA6B,CAAC,IAAI,CAAC,sBAA7D,CAA6D;YAC1F,OAAO,kBAAkB,CAAC,CAAC,CAAC,kBAAkB,CAAC,SAAS,GAAG,qBAAqB,CAAC,CAAC,CAAC,IAAI,CAAA;QAC3F,CAAC;;;OAAA;IAEO,qEAAgC,GAAxC;QACI,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAClD,OAAO,IAAI,CAAC,YAAY,EAAE,CAAA;QAC9B,CAAC;QAED,wDAAwD;QACxD,IAAI,aAAa,GAAG,CAAC,CAAC,CAAA;QACtB,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YACrD,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,iBAAS,CAAC,IAAI,EAAE,CAAC;gBAC/C,aAAa,GAAG,CAAC,CAAA;gBACjB,MAAK;YACT,CAAC;QACL,CAAC;QACD,IAAI,aAAa,IAAI,CAAC,EAAE,CAAC;YACrB,IAAI,CAAC,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,CAAA;YAC1D,IAAI,CAAC,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,IAAI,IAAK,OAAA,GAAG,GAAG,IAAA,qCAAY,EAAC,IAAI,CAAC,EAAxB,CAAwB,EAAE,CAAC,CAAC,CAAA;YACxF,OAAO,IAAI,CAAC,OAAO,CAAA;QACvB,CAAC;aAAM,CAAC;YACJ,OAAO,IAAI,CAAC,YAAY,EAAE,CAAA;QAC9B,CAAC;IACL,CAAC;IAEO,iDAAY,GAApB;QACI,IAAI,CAAC,OAAO,GAAG;YACX,IAAI,EAAE,CAAC;YACP,IAAI,EAAE,EAAE;YACR,SAAS,EAAE,IAAI,CAAC,UAAU;YAC1B,QAAQ,EAAE,IAAI,CAAC,SAAS;SAC3B,CAAA;QACD,OAAO,IAAI,CAAC,OAAO,CAAA;IACvB,CAAC;IAqBO,mDAAc,GAAtB,UAAuB,WAA+B,EAAE,UAAgC;QACpF,IAAI,CAAC,SAAS,CAAC,oBAAoB,CAAC;YAChC,+BAA+B,EAAE,WAAW;SAC/C,CAAC,CAAA;QACF,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,UAAU,CAAC,CAAA;QACtD,IAAI,CAAC,IAAA,eAAQ,EAAC,CAAC,uBAAuB,EAAE,oBAAoB,CAAC,EAAE,WAAW,CAAC,EAAE,CAAC;YAC1E,IAAI,CAAC,kBAAkB,CAAC,WAAW,EAAE,UAAU,CAAC,CAAA;QACpD,CAAC;IACL,CAAC;IAEO,wDAAmB,GAA3B,UAA4B,KAAoB;;QAC5C,OAAO,CACH,KAAK,CAAC,IAAI,KAAK,wDAA+B;YAC9C,cAAc,CAAC,OAAO,CAAC,MAAA,KAAK,CAAC,IAAI,0CAAE,MAA2B,CAAC,KAAK,CAAC,CAAC,CACzE,CAAA;IACL,CAAC;IAEO,+DAA0B,GAAlC,UAAmC,KAAoB;QACnD,6GAA6G;QAC7G,oHAAoH;QACpH,sDAAsD;QAEtD,IAAM,iBAAiB,GAAG,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAA;QAEzD,IAAI,CAAC,iBAAiB,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YACtC,iEAAiE;YACjE,IAAM,qBAAqB,GAAG,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC,sBAAsB,CAAA;YAC3E,IAAI,qBAAqB,GAAG,IAAI,CAAC,iCAAiC,EAAE,CAAC;gBACjE,8BAA8B;gBAC9B,sCAAsC;gBACtC,8DAA8D;gBAC9D,IAAI,CAAC,OAAO,GAAG,IAAI,CAAA;gBAEnB,uCAAuC;gBACvC,aAAa,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAA;gBAEtC,IAAI,CAAC,kBAAkB,CAAC,aAAa,EAAE;oBACnC,cAAc,EAAE,KAAK,CAAC,SAAS;oBAC/B,qBAAqB,EAAE,IAAI,CAAC,sBAAsB;oBAClD,SAAS,EAAE,IAAI,CAAC,iCAAiC;oBACjD,YAAY,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM;oBACtC,UAAU,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI;iBAChC,CAAC,CAAA;gBAEF,2EAA2E;gBAC3E,IAAI,CAAC,YAAY,EAAE,CAAA;YACvB,CAAC;QACL,CAAC;QAED,IAAI,iBAAiB,GAAG,KAAK,CAAA;QAC7B,IAAI,iBAAiB,EAAE,CAAC;YACpB,IAAI,CAAC,sBAAsB,GAAG,KAAK,CAAC,SAAS,CAAA;YAC7C,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;gBACf,IAAM,cAAc,GAAG,IAAI,CAAC,OAAO,KAAK,SAAS,CAAA;gBACjD,wBAAwB;gBACxB,IAAI,CAAC,OAAO,GAAG,KAAK,CAAA;gBACpB,2FAA2F;gBAC3F,gHAAgH;gBAChH,IAAI,CAAC,cAAc,EAAE,CAAC;oBAClB,IAAI,CAAC,kBAAkB,CAAC,qBAAqB,EAAE;wBAC3C,MAAM,EAAE,eAAe;wBACvB,IAAI,EAAE,KAAK,CAAC,IAAI;qBACnB,CAAC,CAAA;oBACF,iBAAiB,GAAG,IAAI,CAAA;gBAC5B,CAAC;YACL,CAAC;QACL,CAAC;QAED,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,OAAM;QACV,CAAC;QAED,oEAAoE;QAC9D,IAAA,KAA0B,IAAI,CAAC,eAAe,CAAC,6BAA6B,CAC9E,CAAC,iBAAiB,EAClB,KAAK,CAAC,SAAS,CAClB,EAHO,QAAQ,cAAA,EAAE,SAAS,eAG1B,CAAA;QAED,IAAM,gBAAgB,GAAG,IAAI,CAAC,UAAU,KAAK,SAAS,CAAA;QACtD,IAAM,eAAe,GAAG,IAAI,CAAC,SAAS,KAAK,QAAQ,CAAA;QAEnD,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAA;QACzB,IAAI,CAAC,UAAU,GAAG,SAAS,CAAA;QAE3B,IAAI,gBAAgB,IAAI,eAAe,EAAE,CAAC;YACtC,IAAI,CAAC,IAAI,EAAE,CAAA;YACX,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,CAAA;QACpC,CAAC;aAAM,IAAI,iBAAiB,EAAE,CAAC;YAC3B,IAAI,CAAC,qBAAqB,EAAE,CAAA;QAChC,CAAC;IACL,CAAC;IAEO,0EAAqC,GAA7C;;QACI,MAAA,MAAA,IAAI,CAAC,SAAS,0CAAE,WAAW,0CAAE,UAAU,CAAC,6DAAiD,CAAC,CAAA;QAC1F,MAAA,MAAA,IAAI,CAAC,SAAS,0CAAE,WAAW,0CAAE,UAAU,CAAC,2DAA+C,CAAC,CAAA;QACxF,MAAA,MAAA,IAAI,CAAC,SAAS,0CAAE,WAAW,0CAAE,UAAU,CAAC,wCAA4B,CAAC,CAAA;IACzE,CAAC;IAEO,0DAAqB,GAA7B,UAA8B,SAAiB;;;QAC3C,IAAM,gBAAgB,GAAG,IAAI,CAAC,UAAU,KAAK,SAAS,CAAA;QAEtD,kCAAkC;QAClC,uCAAuC;QACvC,uDAAuD;QACvD,IAAM,iBAAiB,GAAG,IAAI,CAAC,WAAW,CAAA;QAE1C,IAAI,CAAC,IAAA,eAAQ,EAAC,iBAAiB,CAAC,EAAE,CAAC;YAC/B,MAAA,IAAI,CAAC,SAAS,CAAC,WAAW,0CAAE,UAAU,CAAC,wCAA4B,CAAC,CAAA;YACpE,OAAM;QACV,CAAC;QAED,IAAM,eAAe,GAAG,IAAI,CAAC,UAAU,CAAA;QAEvC;;;;;;WAMG;QACH,IAAM,YAAY,GAAG,gBAAgB,IAAI,CAAC,IAAA,gBAAS,EAAC,eAAe,CAAC,CAAA;QACpE,IAAM,YAAY,GAAG,YAAY,CAAC,CAAC,CAAC,IAAA,2BAAgB,EAAC,SAAS,EAAE,iBAAiB,CAAC,CAAC,CAAC,CAAC,eAAe,CAAA;QAEpG,IAAI,YAAY,EAAE,CAAC;YACf,IAAI,YAAY,EAAE,CAAC;gBACf,IAAI,CAAC,cAAc,CAAC,yBAAO,CAAC,CAAA;YAChC,CAAC;iBAAM,CAAC;gBACJ,MAAM,CAAC,IAAI,CACP,uBAAgB,iBAAiB,mDAAyC,SAAS,sCAAmC,CACzH,CAAA;YACL,CAAC;YAED,IAAI,CAAC,kBAAkB,CAAC,sBAAsB,EAAE;gBAC5C,UAAU,EAAE,iBAAiB;gBAC7B,SAAS,EAAE,YAAY;aAC1B,CAAC,CAAA;QACN,CAAC;QAED,MAAA,IAAI,CAAC,SAAS,CAAC,WAAW,0CAAE,QAAQ;YAChC,GAAC,wCAA4B,IAAG,YAAY,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK;gBAClE,CAAA;IACN,CAAC;IAEO,6DAAwB,GAAhC;QAAA,iBAgBC;QAfG,IAAI,IAAI,CAAC,qBAAqB,CAAC,cAAc,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,IAAA,gBAAS,EAAC,IAAI,CAAC,8BAA8B,CAAC,EAAE,CAAC;YAC5G,OAAM;QACV,CAAC;QAED,IAAI,CAAC,8BAA8B,GAAG,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,eAAe,EAAE,UAAC,KAAoB;YAC1F,gFAAgF;YAChF,0BAA0B;YAC1B,IAAI,CAAC;gBACD,IAAI,KAAI,CAAC,qBAAqB,CAAC,cAAc,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC;oBAClE,KAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAA;gBAClC,CAAC;YACL,CAAC;YAAC,OAAO,CAAC,EAAE,CAAC;gBACT,MAAM,CAAC,KAAK,CAAC,kCAAkC,EAAE,CAAC,CAAC,CAAA;YACvD,CAAC;QACL,CAAC,CAAC,CAAA;IACN,CAAC;IAED,sBAAI,0DAAkB;aAAtB;YACY,IAAA,qBAAqB,GAAK,IAAI,CAAC,eAAe,CAAC,6BAA6B,CAAC,IAAI,CAAC,sBAA7D,CAA6D;YAE1F,OAAO;gBACH,iBAAiB,EAAE,IAAI,CAAC,MAAM;gBAC9B,wCAAwC,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM;gBAClE,sCAAsC,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI;gBACzD,mCAAmC,EAAE,IAAI,CAAC,gBAAgB;gBAC1D,wBAAwB,EAAE,qBAAqB;aAClD,CAAA;QACL,CAAC;;;OAAA;IAEO,mDAAc,GAAtB;;QAAA,iBAiGC;;QAhGG,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;YAClB,OAAM;QACV,CAAC;QAED,6HAA6H;QAC7H,IAAM,uBAAuB,GAAkB;YAC3C,yEAAyE;YACzE,6DAA6D;YAC7D,UAAU,EAAE,eAAe;YAC3B,aAAa,EAAE,SAAS;YACxB,WAAW,EAAE,iBAAiB;YAC9B,aAAa,EAAE,SAAS;YACxB,gBAAgB,EAAE,SAAS;YAC3B,UAAU,EAAE,SAAS;YACrB,aAAa,EAAE,IAAI;YACnB,gBAAgB,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE;YACpC,WAAW,EAAE,SAAS;YACtB,cAAc,EAAE,EAAE;YAClB,YAAY,EAAE,KAAK;YACnB,gBAAgB,EAAE,IAAI;YACtB,wBAAwB,EAAE,KAAK;SAClC,CAAA;QAED,kDAAkD;QAClD,IAAM,2BAA2B,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,iBAAiB,CAAA;;YAC3E,KAA2B,IAAA,KAAA,SAAA,MAAM,CAAC,OAAO,CAAC,2BAA2B,IAAI,EAAE,CAAC,CAAA,gBAAA,4BAAE,CAAC;gBAApE,IAAA,KAAA,mBAAY,EAAX,GAAG,QAAA,EAAE,KAAK,QAAA;gBAClB,IAAI,GAAG,IAAI,uBAAuB,EAAE,CAAC;oBACjC,IAAI,GAAG,KAAK,kBAAkB,EAAE,CAAC;wBAC7B,gDAAgD;wBAChD,uBAAuB,CAAC,gBAAgB,cAAK,QAAQ,EAAE,IAAI,IAAK,KAAK,CAAE,CAAA;oBAC3E,CAAC;yBAAM,CAAC;wBACJ,6DAA6D;wBAC7D,aAAa;wBACb,uBAAuB,CAAC,GAAG,CAAC,GAAG,KAAK,CAAA;oBACxC,CAAC;gBACL,CAAC;YACL,CAAC;;;;;;;;;QAED,IAAI,IAAI,CAAC,gBAAgB,IAAI,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,CAAC;YACzD,uBAAuB,CAAC,YAAY,GAAG,IAAI,CAAA;YAC3C,uBAAuB,CAAC,QAAQ,GAAG,EAAE,MAAM,EAAE,IAAI,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAA;YACxE,uBAAuB,CAAC,cAAc,GAAG,EAAE,IAAI,EAAE,YAAY,EAAE,OAAO,EAAE,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,CAAA;QAC3G,CAAC;QAED,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YAChB,uBAAuB,CAAC,aAAa,GAAG,MAAA,IAAI,CAAC,QAAQ,CAAC,aAAa,mCAAI,IAAI,CAAA;YAC3E,uBAAuB,CAAC,gBAAgB,GAAG,MAAA,IAAI,CAAC,QAAQ,CAAC,gBAAgB,mCAAI,SAAS,CAAA;YACtF,uBAAuB,CAAC,aAAa,GAAG,MAAA,IAAI,CAAC,QAAQ,CAAC,aAAa,mCAAI,SAAS,CAAA;QACpF,CAAC;QAED,IAAM,WAAW,GAAG,cAAc,EAAE,CAAA;QACpC,IAAI,CAAC,WAAW,EAAE,CAAC;YACf,MAAM,CAAC,KAAK,CACR,sGAAsG,CACzG,CAAA;YACD,OAAM;QACV,CAAC;QAED,IAAI,CAAC,kBAAkB;YACnB,MAAA,IAAI,CAAC,kBAAkB,mCACvB,IAAI,sCAAiB,CAAC,WAAW,EAAE;gBAC/B,UAAU,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,iBAAiB,CAAC,6BAA6B;gBACjF,UAAU,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,iBAAiB,CAAC,6BAA6B;gBACjF,aAAa,EAAE,UAAC,EAAE,EAAE,IAAI;oBACpB,IAAM,OAAO,GAAG,sCAA+B,EAAE,+EAA4E,CAAA;oBAC7H,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE;wBACjB,IAAI,EAAE,IAAI;qBACb,CAAC,CAAA;oBAEF,KAAI,CAAC,GAAG,CAAC,aAAa,GAAG,GAAG,GAAG,OAAO,EAAE,MAAM,CAAC,CAAA;gBACnD,CAAC;aACJ,CAAC,CAAA;QAEN,IAAM,aAAa,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAA;QAChD,IAAI,CAAC,UAAU,GAAG,WAAW,YACzB,IAAI,EAAE,UAAC,KAAK;gBACR,KAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAA;YAC3B,CAAC,EACD,OAAO,EAAE,aAAa,IACnB,uBAAuB,EAC5B,CAAA;QAEF,iEAAiE;QACjE,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC,GAAG,EAAE,CAAA;QACxC,sDAAsD;QACtD,IAAI,CAAC,OAAO,GAAG,IAAA,gBAAS,EAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,SAAS,CAAA;QAEjE,IAAI,CAAC,iBAAiB,CAAC,yBAAyB,EAAE,IAAI,CAAC,aAAa,CAAC,CAAA;QACrE,IAAI,CAAC,kBAAkB,CAAC,kBAAkB,EAAE;YACxC,uBAAuB,yBAAA;YACvB,aAAa,EAAE,aAAa,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,aAAD,CAAC,uBAAD,CAAC,CAAE,IAAI,EAAP,CAAO,CAAC;SACnD,CAAC,CAAA;QAEF,IAAI,CAAC,kBAAkB,CAAC,iBAAiB,EAAE;YACvC,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM;SAChC,CAAC,CAAA;IACN,CAAC;IAED,sDAAiB,GAAjB,UAAkB,GAAW,EAAE,OAAY;QACvC,OAAO,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE,OAAO,CAAC,CAAA;IAChD,CAAC;IACL,iCAAC;AAAD,CAAC,AAxkCD,IAwkCC;AAxkCY,gEAA0B","sourcesContent":["import type { recordOptions, rrwebRecord as rrwebRecordType } from '../types/rrweb'\nimport {\n    type customEvent,\n    EventType,\n    eventWithTime,\n    IncrementalSource,\n    type listenerHandler,\n    RecordPlugin,\n} from '@rrweb/types'\nimport { buildNetworkRequestOptions } from './config'\nimport {\n    ACTIVE,\n    allMatchSessionRecordingStatus,\n    AndTriggerMatching,\n    anyMatchSessionRecordingStatus,\n    BUFFERING,\n    DISABLED,\n    EventTriggerMatching,\n    LinkedFlagMatching,\n    nullMatchSessionRecordingStatus,\n    OrTriggerMatching,\n    PAUSED,\n    PendingTriggerMatching,\n    RecordingTriggersStatus,\n    SAMPLED,\n    SessionRecordingStatus,\n    TRIGGER_PENDING,\n    TriggerStatusMatching,\n    TriggerType,\n    URLTriggerMatching,\n} from './triggerMatching'\nimport { estimateSize, INCREMENTAL_SNAPSHOT_EVENT_TYPE, truncateLargeConsoleLogs } from './sessionrecording-utils'\nimport { gzipSync, strFromU8, strToU8 } from 'fflate'\nimport { assignableWindow, LazyLoadedSessionRecordingInterface, window, document } from '../../../utils/globals'\nimport { addEventListener } from '../../../utils'\nimport { MutationThrottler } from './mutation-throttler'\nimport { createLogger } from '../../../utils/logger'\nimport {\n    clampToRange,\n    includes,\n    isBoolean,\n    isFunction,\n    isNullish,\n    isNumber,\n    isObject,\n    isString,\n    isUndefined,\n} from '@posthog/core'\nimport {\n    SESSION_RECORDING_EVENT_TRIGGER_ACTIVATED_SESSION,\n    SESSION_RECORDING_IS_SAMPLED,\n    SESSION_RECORDING_REMOTE_CONFIG,\n    SESSION_RECORDING_URL_TRIGGER_ACTIVATED_SESSION,\n} from '../../../constants'\nimport { PostHog } from '../../../posthog-core'\nimport {\n    CaptureResult,\n    NetworkRecordOptions,\n    NetworkRequest,\n    Properties,\n    SessionIdChangedCallback,\n    SessionRecordingOptions,\n    SessionRecordingPersistedConfig,\n    SessionStartReason,\n} from '../../../types'\nimport { isLocalhost } from '../../../utils/request-utils'\nimport Config from '../../../config'\nimport { sampleOnProperty } from '../../sampling'\n\nconst BASE_ENDPOINT = '/s/'\nconst DEFAULT_CANVAS_QUALITY = 0.4\nconst DEFAULT_CANVAS_FPS = 4\nconst MAX_CANVAS_FPS = 12\nconst MAX_CANVAS_QUALITY = 1\nconst TWO_SECONDS = 2000\nconst ONE_KB = 1024\n\nconst ONE_MINUTE = 1000 * 60\nconst FIVE_MINUTES = ONE_MINUTE * 5\n\nexport const RECORDING_IDLE_THRESHOLD_MS = FIVE_MINUTES\n\nexport const RECORDING_MAX_EVENT_SIZE = ONE_KB * ONE_KB * 0.9 // ~1mb (with some wiggle room)\nexport const RECORDING_BUFFER_TIMEOUT = 2000 // 2 seconds\nexport const SESSION_RECORDING_BATCH_KEY = 'recordings'\n\nconst LOGGER_PREFIX = '[SessionRecording]'\nconst logger = createLogger(LOGGER_PREFIX)\n\ninterface QueuedRRWebEvent {\n    rrwebMethod: () => void\n    attempt: number\n    // the timestamp this was first put into this queue\n    enqueuedAt: number\n}\n\ninterface SessionIdlePayload {\n    eventTimestamp: number\n    lastActivityTimestamp: number\n    threshold: number\n    bufferLength: number\n    bufferSize: number\n}\n\nexport interface SnapshotBuffer {\n    size: number\n    data: any[]\n    sessionId: string\n    windowId: string\n}\n\nconst ACTIVE_SOURCES = [\n    IncrementalSource.MouseMove,\n    IncrementalSource.MouseInteraction,\n    IncrementalSource.Scroll,\n    IncrementalSource.ViewportResize,\n    IncrementalSource.Input,\n    IncrementalSource.TouchMove,\n    IncrementalSource.MediaInteraction,\n    IncrementalSource.Drag,\n]\n\nconst newQueuedEvent = (rrwebMethod: () => void): QueuedRRWebEvent => ({\n    rrwebMethod,\n    enqueuedAt: Date.now(),\n    attempt: 1,\n})\n\nfunction getRRWebRecord(): rrwebRecordType | undefined {\n    return assignableWindow?.__PosthogExtensions__?.rrweb?.record\n}\n\nexport type compressedFullSnapshotEvent = {\n    type: EventType.FullSnapshot\n    data: string\n}\n\nexport type compressedIncrementalSnapshotEvent = {\n    type: EventType.IncrementalSnapshot\n    data: {\n        source: IncrementalSource\n        texts: string\n        attributes: string\n        removes: string\n        adds: string\n    }\n}\n\nexport type compressedIncrementalStyleSnapshotEvent = {\n    type: EventType.IncrementalSnapshot\n    data: {\n        source: IncrementalSource.StyleSheetRule\n        id?: number\n        styleId?: number\n        replace?: string\n        replaceSync?: string\n        adds?: string\n        removes?: string\n    }\n}\n\nexport type compressedEvent =\n    | compressedIncrementalStyleSnapshotEvent\n    | compressedFullSnapshotEvent\n    | compressedIncrementalSnapshotEvent\nexport type compressedEventWithTime = compressedEvent & {\n    timestamp: number\n    delay?: number\n    // marker for compression version\n    cv: '2024-10'\n}\n\nfunction gzipToString(data: unknown): string {\n    return strFromU8(gzipSync(strToU8(JSON.stringify(data))), true)\n}\n\n/**\n * rrweb's packer takes an event and returns a string or the reverse on `unpack`.\n * but we want to be able to inspect metadata during ingestion.\n * and don't want to compress the entire event,\n * so we have a custom packer that only compresses part of some events\n */\nfunction compressEvent(event: eventWithTime): eventWithTime | compressedEventWithTime {\n    try {\n        if (event.type === EventType.FullSnapshot) {\n            return {\n                ...event,\n                data: gzipToString(event.data),\n                cv: '2024-10',\n            }\n        }\n        if (event.type === EventType.IncrementalSnapshot && event.data.source === IncrementalSource.Mutation) {\n            return {\n                ...event,\n                cv: '2024-10',\n                data: {\n                    ...event.data,\n                    texts: gzipToString(event.data.texts),\n                    attributes: gzipToString(event.data.attributes),\n                    removes: gzipToString(event.data.removes),\n                    adds: gzipToString(event.data.adds),\n                },\n            }\n        }\n        if (event.type === EventType.IncrementalSnapshot && event.data.source === IncrementalSource.StyleSheetRule) {\n            return {\n                ...event,\n                cv: '2024-10',\n                data: {\n                    ...event.data,\n                    adds: event.data.adds ? gzipToString(event.data.adds) : undefined,\n                    removes: event.data.removes ? gzipToString(event.data.removes) : undefined,\n                },\n            }\n        }\n    } catch (e) {\n        logger.error('could not compress event - will use uncompressed event', e)\n    }\n    return event\n}\n\nfunction isSessionIdleEvent(e: eventWithTime): e is eventWithTime & customEvent {\n    return e.type === EventType.Custom && e.data.tag === 'sessionIdle'\n}\n\n/** When we put the recording into a paused state, we add a custom event.\n *  However, in the paused state, events are dropped and never make it to the buffer,\n *  so we need to manually let this one through */\nfunction isRecordingPausedEvent(e: eventWithTime) {\n    return e.type === EventType.Custom && e.data.tag === 'recording paused'\n}\n\nexport const SEVEN_MEGABYTES = 1024 * 1024 * 7 * 0.9 // ~7mb (with some wiggle room)\n\n// recursively splits large buffers into smaller ones\n// uses a pretty high size limit to avoid splitting too much\nexport function splitBuffer(buffer: SnapshotBuffer, sizeLimit: number = SEVEN_MEGABYTES): SnapshotBuffer[] {\n    if (buffer.size >= sizeLimit && buffer.data.length > 1) {\n        const half = Math.floor(buffer.data.length / 2)\n        const firstHalf = buffer.data.slice(0, half)\n        const secondHalf = buffer.data.slice(half)\n        return [\n            splitBuffer({\n                size: estimateSize(firstHalf),\n                data: firstHalf,\n                sessionId: buffer.sessionId,\n                windowId: buffer.windowId,\n            }),\n            splitBuffer({\n                size: estimateSize(secondHalf),\n                data: secondHalf,\n                sessionId: buffer.sessionId,\n                windowId: buffer.windowId,\n            }),\n        ].flatMap((x) => x)\n    } else {\n        return [buffer]\n    }\n}\n\nexport class LazyLoadedSessionRecording implements LazyLoadedSessionRecordingInterface {\n    private _endpoint: string = BASE_ENDPOINT\n    private _mutationThrottler?: MutationThrottler\n    /**\n     * Util to help developers working on this feature manually override\n     */\n    private _forceAllowLocalhostNetworkCapture = false\n    private _stopRrweb: listenerHandler | undefined = undefined\n    private _lastActivityTimestamp: number = Date.now()\n    /**\n     * if pageview capture is disabled,\n     * then we can manually track href changes\n     */\n    private _lastHref?: string\n    /**\n     * and a queue - that contains rrweb events that we want to send to rrweb, but rrweb wasn't able to accept them yet\n     */\n    private _queuedRRWebEvents: QueuedRRWebEvent[] = []\n    private _isIdle: boolean | 'unknown' = 'unknown'\n\n    private _linkedFlagMatching: LinkedFlagMatching\n    private _urlTriggerMatching: URLTriggerMatching\n    private _eventTriggerMatching: EventTriggerMatching\n    // we need to be able to check the state of the event and url triggers separately\n    // as we make some decisions based on them without referencing LinkedFlag etc\n    private _triggerMatching: TriggerStatusMatching = new PendingTriggerMatching()\n    private _fullSnapshotTimer?: ReturnType<typeof setInterval>\n\n    private _windowId: string\n    private _sessionId: string\n    get sessionId(): string {\n        return this._sessionId\n    }\n\n    private _flushBufferTimer?: any\n    // we have a buffer - that contains PostHog snapshot events ready to be sent to the server\n    private _buffer: SnapshotBuffer\n\n    private _removePageViewCaptureHook: (() => void) | undefined = undefined\n\n    private _removeEventTriggerCaptureHook: (() => void) | undefined = undefined\n\n    private get _sessionManager() {\n        if (!this._instance.sessionManager) {\n            throw new Error(LOGGER_PREFIX + ' must be started with a valid sessionManager.')\n        }\n\n        return this._instance.sessionManager\n    }\n\n    private get _sessionIdleThresholdMilliseconds(): number {\n        return this._instance.config.session_recording.session_idle_threshold_ms || RECORDING_IDLE_THRESHOLD_MS\n    }\n\n    private get _isSampled(): boolean | null {\n        const currentValue = this._instance.get_property(SESSION_RECORDING_IS_SAMPLED)\n        // originally we would store `true` or `false` or nothing,\n        // but that would mean sometimes we would carry on recording on session id change\n        return isBoolean(currentValue) ? currentValue : isString(currentValue) ? currentValue === this.sessionId : null\n    }\n\n    private get _sampleRate(): number | null {\n        const rate = this._remoteConfig?.sampleRate\n        return isNumber(rate) ? rate : null\n    }\n\n    private get _minimumDuration(): number | null {\n        const duration = this._remoteConfig?.minimumDurationMilliseconds\n        return isNumber(duration) ? duration : null\n    }\n\n    private _statusMatcher: (triggersStatus: RecordingTriggersStatus) => SessionRecordingStatus =\n        nullMatchSessionRecordingStatus\n\n    private _onSessionIdListener: (() => void) | undefined = undefined\n    private _onSessionIdleResetForcedListener: (() => void) | undefined = undefined\n    private _samplingSessionListener: (() => void) | undefined = undefined\n    private _forceIdleSessionIdListener: (() => void) | undefined = undefined\n\n    constructor(private readonly _instance: PostHog) {\n        // we know there's a sessionManager, so don't need to start without a session id\n        const { sessionId, windowId } = this._sessionManager.checkAndGetSessionAndWindowId()\n        this._sessionId = sessionId\n        this._windowId = windowId\n\n        this._linkedFlagMatching = new LinkedFlagMatching(this._instance)\n        this._urlTriggerMatching = new URLTriggerMatching(this._instance)\n        this._eventTriggerMatching = new EventTriggerMatching(this._instance)\n\n        this._buffer = this._clearBuffer()\n\n        if (this._sessionIdleThresholdMilliseconds >= this._sessionManager.sessionTimeoutMs) {\n            logger.warn(\n                `session_idle_threshold_ms (${this._sessionIdleThresholdMilliseconds}) is greater than the session timeout (${this._sessionManager.sessionTimeoutMs}). Session will never be detected as idle`\n            )\n        }\n    }\n\n    private get _masking():\n        | Pick<SessionRecordingOptions, 'maskAllInputs' | 'maskTextSelector' | 'blockSelector'>\n        | undefined {\n        const masking_server_side = this._remoteConfig?.masking\n        const masking_client_side = {\n            maskAllInputs: this._instance.config.session_recording?.maskAllInputs,\n            maskTextSelector: this._instance.config.session_recording?.maskTextSelector,\n            blockSelector: this._instance.config.session_recording?.blockSelector,\n        }\n\n        const maskAllInputs = masking_client_side?.maskAllInputs ?? masking_server_side?.maskAllInputs\n        const maskTextSelector = masking_client_side?.maskTextSelector ?? masking_server_side?.maskTextSelector\n        const blockSelector = masking_client_side?.blockSelector ?? masking_server_side?.blockSelector\n\n        return !isUndefined(maskAllInputs) || !isUndefined(maskTextSelector) || !isUndefined(blockSelector)\n            ? {\n                  maskAllInputs: maskAllInputs ?? true,\n                  maskTextSelector,\n                  blockSelector,\n              }\n            : undefined\n    }\n\n    private get _canvasRecording(): { enabled: boolean; fps: number; quality: number } {\n        const canvasRecording_client_side = this._instance.config.session_recording.captureCanvas\n        const canvasRecording_server_side = this._remoteConfig?.canvasRecording\n\n        const enabled: boolean =\n            canvasRecording_client_side?.recordCanvas ?? canvasRecording_server_side?.enabled ?? false\n        const fps: number =\n            canvasRecording_client_side?.canvasFps ?? canvasRecording_server_side?.fps ?? DEFAULT_CANVAS_FPS\n        let quality: string | number =\n            canvasRecording_client_side?.canvasQuality ?? canvasRecording_server_side?.quality ?? DEFAULT_CANVAS_QUALITY\n        if (typeof quality === 'string') {\n            const parsed = parseFloat(quality)\n            quality = isNaN(parsed) ? 0.4 : parsed\n        }\n\n        return {\n            enabled,\n            fps: clampToRange(fps, 0, MAX_CANVAS_FPS, createLogger('canvas recording fps'), DEFAULT_CANVAS_FPS),\n            quality: clampToRange(\n                quality,\n                0,\n                MAX_CANVAS_QUALITY,\n                createLogger('canvas recording quality'),\n                DEFAULT_CANVAS_QUALITY\n            ),\n        }\n    }\n\n    private get _isConsoleLogCaptureEnabled() {\n        const enabled_server_side = !!this._remoteConfig?.consoleLogRecordingEnabled\n        const enabled_client_side = this._instance.config.enable_recording_console_log\n        return enabled_client_side ?? enabled_server_side\n    }\n\n    // network payload capture config has three parts\n    // each can be configured server side or client side\n    private get _networkPayloadCapture():\n        | Pick<NetworkRecordOptions, 'recordHeaders' | 'recordBody' | 'recordPerformance'>\n        | undefined {\n        const networkPayloadCapture_server_side = this._remoteConfig?.networkPayloadCapture\n        const networkPayloadCapture_client_side = {\n            recordHeaders: this._instance.config.session_recording?.recordHeaders,\n            recordBody: this._instance.config.session_recording?.recordBody,\n        }\n        const headersEnabled =\n            networkPayloadCapture_client_side?.recordHeaders || networkPayloadCapture_server_side?.recordHeaders\n        const bodyEnabled =\n            networkPayloadCapture_client_side?.recordBody || networkPayloadCapture_server_side?.recordBody\n        const clientConfigForPerformanceCapture = isObject(this._instance.config.capture_performance)\n            ? this._instance.config.capture_performance.network_timing\n            : this._instance.config.capture_performance\n        const networkTimingEnabled = !!(isBoolean(clientConfigForPerformanceCapture)\n            ? clientConfigForPerformanceCapture\n            : networkPayloadCapture_server_side?.capturePerformance)\n\n        return headersEnabled || bodyEnabled || networkTimingEnabled\n            ? { recordHeaders: headersEnabled, recordBody: bodyEnabled, recordPerformance: networkTimingEnabled }\n            : undefined\n    }\n\n    private _gatherRRWebPlugins() {\n        const plugins: RecordPlugin[] = []\n\n        const recordConsolePlugin = assignableWindow.__PosthogExtensions__?.rrwebPlugins?.getRecordConsolePlugin\n        if (recordConsolePlugin && this._isConsoleLogCaptureEnabled) {\n            plugins.push(recordConsolePlugin())\n        }\n\n        const networkPlugin = assignableWindow.__PosthogExtensions__?.rrwebPlugins?.getRecordNetworkPlugin\n        if (!!this._networkPayloadCapture && isFunction(networkPlugin)) {\n            const canRecordNetwork = !isLocalhost() || this._forceAllowLocalhostNetworkCapture\n\n            if (canRecordNetwork) {\n                plugins.push(\n                    networkPlugin(buildNetworkRequestOptions(this._instance.config, this._networkPayloadCapture))\n                )\n            } else {\n                logger.info('NetworkCapture not started because we are on localhost.')\n            }\n        }\n\n        return plugins\n    }\n\n    private _maskUrl(url: string): string | undefined {\n        const userSessionRecordingOptions = this._instance.config.session_recording\n\n        if (userSessionRecordingOptions.maskNetworkRequestFn) {\n            let networkRequest: NetworkRequest | null | undefined = {\n                url,\n            }\n\n            // TODO we should deprecate this and use the same function for this masking and the rrweb/network plugin\n            // TODO or deprecate this and provide a new clearer name so this would be `maskURLPerformanceFn` or similar\n            networkRequest = userSessionRecordingOptions.maskNetworkRequestFn(networkRequest)\n\n            return networkRequest?.url\n        }\n\n        return url\n    }\n\n    private _tryRRWebMethod(queuedRRWebEvent: QueuedRRWebEvent): boolean {\n        try {\n            queuedRRWebEvent.rrwebMethod()\n            return true\n        } catch (e) {\n            // Sometimes a race can occur where the recorder is not fully started yet\n            if (this._queuedRRWebEvents.length < 10) {\n                this._queuedRRWebEvents.push({\n                    enqueuedAt: queuedRRWebEvent.enqueuedAt || Date.now(),\n                    attempt: queuedRRWebEvent.attempt + 1,\n                    rrwebMethod: queuedRRWebEvent.rrwebMethod,\n                })\n            } else {\n                logger.warn('could not emit queued rrweb event.', e, queuedRRWebEvent)\n            }\n\n            return false\n        }\n    }\n\n    private _tryAddCustomEvent(tag: string, payload: any): boolean {\n        return this._tryRRWebMethod(newQueuedEvent(() => getRRWebRecord()!.addCustomEvent(tag, payload)))\n    }\n\n    private _pageViewFallBack() {\n        try {\n            if (this._instance.config.capture_pageview || !window) {\n                return\n            }\n            // Strip hash parameters from URL since they often aren't helpful\n            // Use URL constructor for proper parsing to handle edge cases\n            // recording doesn't run in IE11, so we don't need compat here\n            // eslint-disable-next-line compat/compat\n            const url = new URL(window.location.href)\n            const hrefWithoutHash = url.origin + url.pathname + url.search\n            const currentUrl = this._maskUrl(hrefWithoutHash)\n            if (this._lastHref !== currentUrl) {\n                this._lastHref = currentUrl\n                this._tryAddCustomEvent('$url_changed', { href: currentUrl })\n            }\n        } catch {\n            // If URL processing fails, don't capture anything\n        }\n    }\n\n    private _processQueuedEvents() {\n        if (this._queuedRRWebEvents.length) {\n            // if rrweb isn't ready to accept events earlier, then we queued them up.\n            // now that `emit` has been called rrweb should be ready to accept them.\n            // so, before we process this event, we try our queued events _once_ each\n            // we don't want to risk queuing more things and never exiting this loop!\n            // if they fail here, they'll be pushed into a new queue\n            // and tried on the next loop.\n            // there is a risk of this queue growing in an uncontrolled manner.\n            // so its length is limited elsewhere\n            // for now this is to help us ensure we can capture events that happen\n            // and try to identify more about when it is failing\n            const itemsToProcess = [...this._queuedRRWebEvents]\n            this._queuedRRWebEvents = []\n            itemsToProcess.forEach((queuedRRWebEvent) => {\n                if (Date.now() - queuedRRWebEvent.enqueuedAt <= TWO_SECONDS) {\n                    this._tryRRWebMethod(queuedRRWebEvent)\n                }\n            })\n        }\n    }\n\n    private _tryTakeFullSnapshot(): boolean {\n        return this._tryRRWebMethod(newQueuedEvent(() => getRRWebRecord()!.takeFullSnapshot()))\n    }\n\n    private get _fullSnapshotIntervalMillis(): number {\n        if (\n            this._triggerMatching.triggerStatus(this.sessionId) === TRIGGER_PENDING &&\n            !['sampled', 'active'].includes(this.status)\n        ) {\n            return ONE_MINUTE\n        }\n\n        return this._instance.config.session_recording?.full_snapshot_interval_millis ?? FIVE_MINUTES\n    }\n\n    private _scheduleFullSnapshot(): void {\n        if (this._fullSnapshotTimer) {\n            clearInterval(this._fullSnapshotTimer)\n        }\n        // we don't schedule snapshots while idle\n        if (this._isIdle === true) {\n            return\n        }\n\n        const interval = this._fullSnapshotIntervalMillis\n        if (!interval) {\n            return\n        }\n\n        this._fullSnapshotTimer = setInterval(() => {\n            this._tryTakeFullSnapshot()\n        }, interval)\n    }\n\n    private _pauseRecording() {\n        // we check _urlBlocked not status, since more than one thing can affect status\n        if (this._urlTriggerMatching.urlBlocked) {\n            return\n        }\n\n        // we can't flush the buffer here since someone might be starting on a blocked page.\n        // and we need to be sure that we don't record that page,\n        // so we might not get the below custom event, but events will report the paused status.\n        // which will allow debugging of sessions that start on blocked pages\n        this._urlTriggerMatching.urlBlocked = true\n\n        // Clear the snapshot timer since we don't want new snapshots while paused\n        clearInterval(this._fullSnapshotTimer)\n\n        logger.info('recording paused due to URL blocker')\n        this._tryAddCustomEvent('recording paused', { reason: 'url blocker' })\n    }\n\n    private _resumeRecording() {\n        // we check _urlBlocked not status, since more than one thing can affect status\n        if (!this._urlTriggerMatching.urlBlocked) {\n            return\n        }\n\n        this._urlTriggerMatching.urlBlocked = false\n\n        this._tryTakeFullSnapshot()\n        this._scheduleFullSnapshot()\n\n        this._tryAddCustomEvent('recording resumed', { reason: 'left blocked url' })\n        logger.info('recording resumed')\n    }\n\n    private _activateTrigger(triggerType: TriggerType) {\n        if (this._triggerMatching.triggerStatus(this.sessionId) === TRIGGER_PENDING) {\n            // status is stored separately for URL and event triggers\n            this._instance?.persistence?.register({\n                [triggerType === 'url'\n                    ? SESSION_RECORDING_URL_TRIGGER_ACTIVATED_SESSION\n                    : SESSION_RECORDING_EVENT_TRIGGER_ACTIVATED_SESSION]: this._sessionId,\n            })\n\n            this._flushBuffer()\n            this._reportStarted((triggerType + '_trigger_matched') as SessionStartReason)\n        }\n    }\n\n    get isStarted(): boolean {\n        return !!this._stopRrweb\n    }\n\n    get _remoteConfig(): SessionRecordingPersistedConfig | undefined {\n        const persistedConfig: any = this._instance.get_property(SESSION_RECORDING_REMOTE_CONFIG)\n        if (!persistedConfig) {\n            return undefined\n        }\n        const parsedConfig = isObject(persistedConfig) ? persistedConfig : JSON.parse(persistedConfig)\n        return parsedConfig as SessionRecordingPersistedConfig\n    }\n\n    start(startReason?: SessionStartReason) {\n        const config = this._remoteConfig\n        if (!config) {\n            logger.info('remote config must be stored in persistence before recording can start')\n            return\n        }\n\n        // We want to ensure the sessionManager is reset if necessary on loading the recorder\n        this._sessionManager.checkAndGetSessionAndWindowId()\n\n        if (config?.endpoint) {\n            this._endpoint = config?.endpoint\n        }\n\n        if (config?.triggerMatchType === 'any') {\n            this._statusMatcher = anyMatchSessionRecordingStatus\n            this._triggerMatching = new OrTriggerMatching([this._eventTriggerMatching, this._urlTriggerMatching])\n        } else {\n            // either the setting is \"ALL\"\n            // or we default to the most restrictive\n            this._statusMatcher = allMatchSessionRecordingStatus\n            this._triggerMatching = new AndTriggerMatching([this._eventTriggerMatching, this._urlTriggerMatching])\n        }\n        this._instance.register_for_session({\n            $sdk_debug_replay_remote_trigger_matching_config: config?.triggerMatchType,\n        })\n\n        this._urlTriggerMatching.onConfig(config)\n\n        this._eventTriggerMatching.onConfig(config)\n        this._removeEventTriggerCaptureHook?.()\n        this._addEventTriggerListener()\n\n        this._linkedFlagMatching.onConfig(config, (flag, variant) => {\n            this._reportStarted('linked_flag_matched', {\n                flag,\n                variant,\n            })\n        })\n\n        this._makeSamplingDecision(this.sessionId)\n        this._startRecorder()\n\n        // calling addEventListener multiple times is safe and will not add duplicates\n        addEventListener(window, 'beforeunload', this._onBeforeUnload)\n        addEventListener(window, 'offline', this._onOffline)\n        addEventListener(window, 'online', this._onOnline)\n        addEventListener(window, 'visibilitychange', this._onVisibilityChange)\n\n        if (!this._onSessionIdListener) {\n            this._onSessionIdListener = this._sessionManager.onSessionId(this._onSessionIdCallback)\n        }\n\n        if (!this._onSessionIdleResetForcedListener) {\n            this._onSessionIdleResetForcedListener = this._sessionManager.on('forcedIdleReset', () => {\n                // a session was forced to reset due to idle timeout and lack of activity\n                this._clearConditionalRecordingPersistence()\n                this._isIdle = 'unknown'\n                this.stop()\n                // then we want a session id listener to restart the recording when a new session starts\n                this._forceIdleSessionIdListener = this._sessionManager.onSessionId(\n                    (sessionId, windowId, changeReason) => {\n                        // this should first unregister itself\n                        this._forceIdleSessionIdListener?.()\n                        this._forceIdleSessionIdListener = undefined\n                        this._onSessionIdCallback(sessionId, windowId, changeReason)\n                    }\n                )\n            })\n        }\n\n        if (isNullish(this._removePageViewCaptureHook)) {\n            // :TRICKY: rrweb does not capture navigation within SPA-s, so hook into our $pageview events to get access to all events.\n            //   Dropping the initial event is fine (it's always captured by rrweb).\n            this._removePageViewCaptureHook = this._instance.on('eventCaptured', (event) => {\n                // If anything could go wrong here,\n                // it has the potential to block the main loop,\n                // so we catch all errors.\n                try {\n                    if (event.event === '$pageview') {\n                        const href = event?.properties.$current_url ? this._maskUrl(event?.properties.$current_url) : ''\n                        if (!href) {\n                            return\n                        }\n                        this._tryAddCustomEvent('$pageview', { href })\n                    }\n                } catch (e) {\n                    logger.error('Could not add $pageview to rrweb session', e)\n                }\n            })\n        }\n\n        if (this.status === ACTIVE) {\n            this._reportStarted(startReason || 'recording_initialized')\n        }\n    }\n\n    private _onSessionIdCallback: SessionIdChangedCallback = (sessionId, windowId, changeReason) => {\n        if (changeReason) {\n            this._tryAddCustomEvent('$session_id_change', { sessionId, windowId, changeReason })\n\n            this._clearConditionalRecordingPersistence()\n\n            if (!this._stopRrweb) {\n                this.start('session_id_changed')\n            }\n\n            if (isNumber(this._sampleRate) && isNullish(this._samplingSessionListener)) {\n                this._makeSamplingDecision(sessionId)\n            }\n        }\n    }\n\n    stop() {\n        window?.removeEventListener('beforeunload', this._onBeforeUnload)\n        window?.removeEventListener('offline', this._onOffline)\n        window?.removeEventListener('online', this._onOnline)\n        window?.removeEventListener('visibilitychange', this._onVisibilityChange)\n\n        this._clearBuffer()\n        clearInterval(this._fullSnapshotTimer)\n        this._clearFlushBufferTimer()\n\n        this._removePageViewCaptureHook?.()\n        this._removePageViewCaptureHook = undefined\n        this._removeEventTriggerCaptureHook?.()\n        this._removeEventTriggerCaptureHook = undefined\n        this._onSessionIdListener?.()\n        this._onSessionIdListener = undefined\n        this._onSessionIdleResetForcedListener?.()\n        this._onSessionIdleResetForcedListener = undefined\n        this._samplingSessionListener?.()\n        this._samplingSessionListener = undefined\n        this._forceIdleSessionIdListener?.()\n        this._forceIdleSessionIdListener = undefined\n\n        this._eventTriggerMatching.stop()\n        this._urlTriggerMatching.stop()\n        this._linkedFlagMatching.stop()\n\n        this._mutationThrottler?.stop()\n\n        // Clear any queued rrweb events to prevent memory leaks from closures\n        this._queuedRRWebEvents = []\n\n        this._stopRrweb?.()\n        this._stopRrweb = undefined\n\n        logger.info('stopped')\n    }\n\n    onRRwebEmit(rawEvent: eventWithTime) {\n        this._processQueuedEvents()\n\n        if (!rawEvent || !isObject(rawEvent)) {\n            return\n        }\n\n        if (rawEvent.type === EventType.Meta) {\n            const href = this._maskUrl(rawEvent.data.href)\n            this._lastHref = href\n            if (!href) {\n                return\n            }\n            rawEvent.data.href = href\n        } else {\n            this._pageViewFallBack()\n        }\n\n        // Check if the URL matches any trigger patterns\n        this._urlTriggerMatching.checkUrlTriggerConditions(\n            () => this._pauseRecording(),\n            () => this._resumeRecording(),\n            (triggerType) => this._activateTrigger(triggerType)\n        )\n        // always have to check if the URL is blocked really early,\n        // or you risk getting stuck in a loop\n        if (this._urlTriggerMatching.urlBlocked && !isRecordingPausedEvent(rawEvent)) {\n            return\n        }\n\n        // we're processing a full snapshot, so we should reset the timer\n        if (rawEvent.type === EventType.FullSnapshot) {\n            this._scheduleFullSnapshot()\n            // Full snapshots reset rrweb's node IDs, so clear any logged node tracking\n            this._mutationThrottler?.reset()\n        }\n\n        // Clear the buffer if waiting for a trigger and only keep data from after the current full snapshot\n        // we always start trigger pending so need to wait for flags before we know if we're really pending\n        if (\n            rawEvent.type === EventType.FullSnapshot &&\n            this._triggerMatching.triggerStatus(this.sessionId) === TRIGGER_PENDING\n        ) {\n            this._clearBufferBeforeMostRecentMeta()\n        }\n\n        const throttledEvent = this._mutationThrottler ? this._mutationThrottler.throttleMutations(rawEvent) : rawEvent\n\n        if (!throttledEvent) {\n            return\n        }\n\n        // TODO: Re-add ensureMaxMessageSize once we are confident in it\n        const event = truncateLargeConsoleLogs(throttledEvent)\n\n        this._updateWindowAndSessionIds(event)\n\n        // When in an idle state we keep recording but don't capture the events,\n        // we don't want to return early if idle is 'unknown'\n        if (this._isIdle === true && !isSessionIdleEvent(event)) {\n            return\n        }\n\n        if (isSessionIdleEvent(event)) {\n            // session idle events have a timestamp when rrweb sees them\n            // which can artificially lengthen a session\n            // we know when we detected it based on the payload and can correct the timestamp\n            const payload = event.data.payload as SessionIdlePayload\n            if (payload) {\n                const lastActivity = payload.lastActivityTimestamp\n                const threshold = payload.threshold\n                event.timestamp = lastActivity + threshold\n            }\n        }\n\n        const eventToSend =\n            (this._instance.config.session_recording.compress_events ?? true) ? compressEvent(event) : event\n        const size = estimateSize(eventToSend)\n\n        const properties = {\n            $snapshot_bytes: size,\n            $snapshot_data: eventToSend,\n            $session_id: this._sessionId,\n            $window_id: this._windowId,\n        }\n\n        if (this.status === DISABLED) {\n            this._clearBuffer()\n            return\n        }\n\n        this._captureSnapshotBuffered(properties)\n    }\n\n    get status(): SessionRecordingStatus {\n        return this._statusMatcher({\n            // can't get here without recording being enabled...\n            receivedFlags: true,\n            isRecordingEnabled: true,\n            // things that do still vary\n            isSampled: this._isSampled,\n            urlTriggerMatching: this._urlTriggerMatching,\n            eventTriggerMatching: this._eventTriggerMatching,\n            linkedFlagMatching: this._linkedFlagMatching,\n            sessionId: this.sessionId,\n        })\n    }\n\n    log(message: string, level: 'log' | 'warn' | 'error' = 'log') {\n        this._instance.sessionRecording?.onRRwebEmit({\n            type: 6,\n            data: {\n                plugin: 'rrweb/console@1',\n                payload: {\n                    level,\n                    trace: [],\n                    // Even though it is a string, we stringify it as that's what rrweb expects\n                    payload: [JSON.stringify(message)],\n                },\n            },\n            timestamp: Date.now(),\n        })\n    }\n\n    public overrideLinkedFlag() {\n        this._linkedFlagMatching.linkedFlagSeen = true\n        this._tryTakeFullSnapshot()\n        this._reportStarted('linked_flag_overridden')\n    }\n\n    /**\n     * this ignores the sampling config and (if other conditions are met) causes capture to start\n     *\n     * It is not usual to call this directly,\n     * instead call `posthog.startSessionRecording({sampling: true})`\n     * */\n    public overrideSampling() {\n        this._instance.persistence?.register({\n            // short-circuits the `makeSamplingDecision` function in the session recording module\n            [SESSION_RECORDING_IS_SAMPLED]: this.sessionId,\n        })\n        this._tryTakeFullSnapshot()\n        this._reportStarted('sampling_overridden')\n    }\n\n    /**\n     * this ignores the URL/Event trigger config and (if other conditions are met) causes capture to start\n     *\n     * It is not usual to call this directly,\n     * instead call `posthog.startSessionRecording({trigger: 'url' | 'event'})`\n     * */\n    public overrideTrigger(triggerType: TriggerType) {\n        this._activateTrigger(triggerType)\n    }\n\n    private _clearFlushBufferTimer() {\n        if (this._flushBufferTimer) {\n            clearTimeout(this._flushBufferTimer)\n            this._flushBufferTimer = undefined\n        }\n    }\n\n    private _flushBuffer(): SnapshotBuffer {\n        this._clearFlushBufferTimer()\n\n        const minimumDuration = this._minimumDuration\n        const sessionDuration = this._sessionDuration\n        // if we have old data in the buffer but the session has rotated, then the\n        // session duration might be negative. In that case we want to flush the buffer\n        const isPositiveSessionDuration = isNumber(sessionDuration) && sessionDuration >= 0\n        const isBelowMinimumDuration =\n            isNumber(minimumDuration) && isPositiveSessionDuration && sessionDuration < minimumDuration\n\n        if (this.status === BUFFERING || this.status === PAUSED || this.status === DISABLED || isBelowMinimumDuration) {\n            this._flushBufferTimer = setTimeout(() => {\n                this._flushBuffer()\n            }, RECORDING_BUFFER_TIMEOUT)\n            return this._buffer\n        }\n\n        if (this._buffer.data.length > 0) {\n            const snapshotEvents = splitBuffer(this._buffer)\n            snapshotEvents.forEach((snapshotBuffer) => {\n                this._captureSnapshot({\n                    $snapshot_bytes: snapshotBuffer.size,\n                    $snapshot_data: snapshotBuffer.data,\n                    $session_id: snapshotBuffer.sessionId,\n                    $window_id: snapshotBuffer.windowId,\n                    $lib: 'web',\n                    $lib_version: Config.LIB_VERSION,\n                })\n            })\n        }\n\n        // buffer is empty, we clear it in case the session id has changed\n        return this._clearBuffer()\n    }\n\n    private _captureSnapshotBuffered(properties: Properties) {\n        const additionalBytes = 2 + (this._buffer?.data.length || 0) // 2 bytes for the array brackets and 1 byte for each comma\n        if (\n            !this._isIdle && // we never want to flush when idle\n            (this._buffer.size + properties.$snapshot_bytes + additionalBytes > RECORDING_MAX_EVENT_SIZE ||\n                this._buffer.sessionId !== this._sessionId)\n        ) {\n            this._buffer = this._flushBuffer()\n        }\n\n        this._buffer.size += properties.$snapshot_bytes\n        this._buffer.data.push(properties.$snapshot_data)\n\n        if (!this._flushBufferTimer && !this._isIdle) {\n            this._flushBufferTimer = setTimeout(() => {\n                this._flushBuffer()\n            }, RECORDING_BUFFER_TIMEOUT)\n        }\n    }\n\n    private _captureSnapshot(properties: Properties) {\n        // :TRICKY: Make sure we batch these requests, use a custom endpoint and don't truncate the strings.\n        this._instance.capture('$snapshot', properties, {\n            _url: this._instance.requestRouter.endpointFor('api', this._endpoint),\n            _noTruncate: true,\n            _batchKey: SESSION_RECORDING_BATCH_KEY,\n            skip_client_rate_limiting: true,\n        })\n    }\n\n    private get _sessionDuration(): number | null {\n        const mostRecentSnapshot = this._buffer?.data[this._buffer?.data.length - 1]\n        const { sessionStartTimestamp } = this._sessionManager.checkAndGetSessionAndWindowId(true)\n        return mostRecentSnapshot ? mostRecentSnapshot.timestamp - sessionStartTimestamp : null\n    }\n\n    private _clearBufferBeforeMostRecentMeta(): SnapshotBuffer {\n        if (!this._buffer || this._buffer.data.length === 0) {\n            return this._clearBuffer()\n        }\n\n        // Find the last meta event index by iterating backwards\n        let lastMetaIndex = -1\n        for (let i = this._buffer.data.length - 1; i >= 0; i--) {\n            if (this._buffer.data[i].type === EventType.Meta) {\n                lastMetaIndex = i\n                break\n            }\n        }\n        if (lastMetaIndex >= 0) {\n            this._buffer.data = this._buffer.data.slice(lastMetaIndex)\n            this._buffer.size = this._buffer.data.reduce((acc, curr) => acc + estimateSize(curr), 0)\n            return this._buffer\n        } else {\n            return this._clearBuffer()\n        }\n    }\n\n    private _clearBuffer(): SnapshotBuffer {\n        this._buffer = {\n            size: 0,\n            data: [],\n            sessionId: this._sessionId,\n            windowId: this._windowId,\n        }\n        return this._buffer\n    }\n\n    private _onBeforeUnload = (): void => {\n        this._flushBuffer()\n    }\n\n    private _onOffline = (): void => {\n        this._tryAddCustomEvent('browser offline', {})\n    }\n\n    private _onOnline = (): void => {\n        this._tryAddCustomEvent('browser online', {})\n    }\n\n    private _onVisibilityChange = (): void => {\n        if (document?.visibilityState) {\n            const label = 'window ' + document.visibilityState\n            this._tryAddCustomEvent(label, {})\n        }\n    }\n\n    private _reportStarted(startReason: SessionStartReason, tagPayload?: Record<string, any>) {\n        this._instance.register_for_session({\n            $session_recording_start_reason: startReason,\n        })\n        logger.info(startReason.replace('_', ' '), tagPayload)\n        if (!includes(['recording_initialized', 'session_id_changed'], startReason)) {\n            this._tryAddCustomEvent(startReason, tagPayload)\n        }\n    }\n\n    private _isInteractiveEvent(event: eventWithTime) {\n        return (\n            event.type === INCREMENTAL_SNAPSHOT_EVENT_TYPE &&\n            ACTIVE_SOURCES.indexOf(event.data?.source as IncrementalSource) !== -1\n        )\n    }\n\n    private _updateWindowAndSessionIds(event: eventWithTime) {\n        // Some recording events are triggered by non-user events (e.g. \"X minutes ago\" text updating on the screen).\n        // We don't want to extend the session or trigger a new session in these cases. These events are designated by event\n        // type -> incremental update, and source -> mutation.\n\n        const isUserInteraction = this._isInteractiveEvent(event)\n\n        if (!isUserInteraction && !this._isIdle) {\n            // We check if the lastActivityTimestamp is old enough to go idle\n            const timeSinceLastActivity = event.timestamp - this._lastActivityTimestamp\n            if (timeSinceLastActivity > this._sessionIdleThresholdMilliseconds) {\n                // we mark as idle right away,\n                // or else we get multiple idle events\n                // if there are lots of non-user activity events being emitted\n                this._isIdle = true\n\n                // don't take full snapshots while idle\n                clearInterval(this._fullSnapshotTimer)\n\n                this._tryAddCustomEvent('sessionIdle', {\n                    eventTimestamp: event.timestamp,\n                    lastActivityTimestamp: this._lastActivityTimestamp,\n                    threshold: this._sessionIdleThresholdMilliseconds,\n                    bufferLength: this._buffer.data.length,\n                    bufferSize: this._buffer.size,\n                })\n\n                // proactively flush the buffer in case the session is idle for a long time\n                this._flushBuffer()\n            }\n        }\n\n        let returningFromIdle = false\n        if (isUserInteraction) {\n            this._lastActivityTimestamp = event.timestamp\n            if (this._isIdle) {\n                const idleWasUnknown = this._isIdle === 'unknown'\n                // Remove the idle state\n                this._isIdle = false\n                // if the idle state was unknown, we don't want to add an event, since we're just in bootup\n                // whereas if it was true, we know we've been idle for a while, and we can mark ourselves as returning from idle\n                if (!idleWasUnknown) {\n                    this._tryAddCustomEvent('sessionNoLongerIdle', {\n                        reason: 'user activity',\n                        type: event.type,\n                    })\n                    returningFromIdle = true\n                }\n            }\n        }\n\n        if (this._isIdle) {\n            return\n        }\n\n        // We only want to extend the session if it is an interactive event.\n        const { windowId, sessionId } = this._sessionManager.checkAndGetSessionAndWindowId(\n            !isUserInteraction,\n            event.timestamp\n        )\n\n        const sessionIdChanged = this._sessionId !== sessionId\n        const windowIdChanged = this._windowId !== windowId\n\n        this._windowId = windowId\n        this._sessionId = sessionId\n\n        if (sessionIdChanged || windowIdChanged) {\n            this.stop()\n            this.start('session_id_changed')\n        } else if (returningFromIdle) {\n            this._scheduleFullSnapshot()\n        }\n    }\n\n    private _clearConditionalRecordingPersistence(): void {\n        this._instance?.persistence?.unregister(SESSION_RECORDING_EVENT_TRIGGER_ACTIVATED_SESSION)\n        this._instance?.persistence?.unregister(SESSION_RECORDING_URL_TRIGGER_ACTIVATED_SESSION)\n        this._instance?.persistence?.unregister(SESSION_RECORDING_IS_SAMPLED)\n    }\n\n    private _makeSamplingDecision(sessionId: string): void {\n        const sessionIdChanged = this._sessionId !== sessionId\n\n        // capture the current sample rate\n        // because it is re-used multiple times\n        // and the bundler won't minimize any of the references\n        const currentSampleRate = this._sampleRate\n\n        if (!isNumber(currentSampleRate)) {\n            this._instance.persistence?.unregister(SESSION_RECORDING_IS_SAMPLED)\n            return\n        }\n\n        const storedIsSampled = this._isSampled\n\n        /**\n         * if we get this far, then we should make a sampling decision.\n         * When the session id changes or there is no stored sampling decision for this session id\n         * then we should make a new decision.\n         *\n         * Otherwise, we should use the stored decision.\n         */\n        const makeDecision = sessionIdChanged || !isBoolean(storedIsSampled)\n        const shouldSample = makeDecision ? sampleOnProperty(sessionId, currentSampleRate) : storedIsSampled\n\n        if (makeDecision) {\n            if (shouldSample) {\n                this._reportStarted(SAMPLED)\n            } else {\n                logger.warn(\n                    `Sample rate (${currentSampleRate}) has determined that this sessionId (${sessionId}) will not be sent to the server.`\n                )\n            }\n\n            this._tryAddCustomEvent('samplingDecisionMade', {\n                sampleRate: currentSampleRate,\n                isSampled: shouldSample,\n            })\n        }\n\n        this._instance.persistence?.register({\n            [SESSION_RECORDING_IS_SAMPLED]: shouldSample ? sessionId : false,\n        })\n    }\n\n    private _addEventTriggerListener() {\n        if (this._eventTriggerMatching._eventTriggers.length === 0 || !isNullish(this._removeEventTriggerCaptureHook)) {\n            return\n        }\n\n        this._removeEventTriggerCaptureHook = this._instance.on('eventCaptured', (event: CaptureResult) => {\n            // If anything could go wrong here, it has the potential to block the main loop,\n            // so we catch all errors.\n            try {\n                if (this._eventTriggerMatching._eventTriggers.includes(event.event)) {\n                    this._activateTrigger('event')\n                }\n            } catch (e) {\n                logger.error('Could not activate event trigger', e)\n            }\n        })\n    }\n\n    get sdkDebugProperties(): Properties {\n        const { sessionStartTimestamp } = this._sessionManager.checkAndGetSessionAndWindowId(true)\n\n        return {\n            $recording_status: this.status,\n            $sdk_debug_replay_internal_buffer_length: this._buffer.data.length,\n            $sdk_debug_replay_internal_buffer_size: this._buffer.size,\n            $sdk_debug_current_session_duration: this._sessionDuration,\n            $sdk_debug_session_start: sessionStartTimestamp,\n        }\n    }\n\n    private _startRecorder() {\n        if (this._stopRrweb) {\n            return\n        }\n\n        // rrweb config info: https://github.com/rrweb-io/rrweb/blob/7d5d0033258d6c29599fb08412202d9a2c7b9413/src/record/index.ts#L28\n        const sessionRecordingOptions: recordOptions = {\n            // a limited set of the rrweb config options that we expose to our users.\n            // see https://github.com/rrweb-io/rrweb/blob/master/guide.md\n            blockClass: 'ph-no-capture',\n            blockSelector: undefined,\n            ignoreClass: 'ph-ignore-input',\n            maskTextClass: 'ph-mask',\n            maskTextSelector: undefined,\n            maskTextFn: undefined,\n            maskAllInputs: true,\n            maskInputOptions: { password: true },\n            maskInputFn: undefined,\n            slimDOMOptions: {},\n            collectFonts: false,\n            inlineStylesheet: true,\n            recordCrossOriginIframes: false,\n        }\n\n        // only allows user to set our allowlisted options\n        const userSessionRecordingOptions = this._instance.config.session_recording\n        for (const [key, value] of Object.entries(userSessionRecordingOptions || {})) {\n            if (key in sessionRecordingOptions) {\n                if (key === 'maskInputOptions') {\n                    // ensure password config is set if not included\n                    sessionRecordingOptions.maskInputOptions = { password: true, ...value }\n                } else {\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    sessionRecordingOptions[key] = value\n                }\n            }\n        }\n\n        if (this._canvasRecording && this._canvasRecording.enabled) {\n            sessionRecordingOptions.recordCanvas = true\n            sessionRecordingOptions.sampling = { canvas: this._canvasRecording.fps }\n            sessionRecordingOptions.dataURLOptions = { type: 'image/webp', quality: this._canvasRecording.quality }\n        }\n\n        if (this._masking) {\n            sessionRecordingOptions.maskAllInputs = this._masking.maskAllInputs ?? true\n            sessionRecordingOptions.maskTextSelector = this._masking.maskTextSelector ?? undefined\n            sessionRecordingOptions.blockSelector = this._masking.blockSelector ?? undefined\n        }\n\n        const rrwebRecord = getRRWebRecord()\n        if (!rrwebRecord) {\n            logger.error(\n                '_startRecorder was called but rrwebRecord is not available. This indicates something has gone wrong.'\n            )\n            return\n        }\n\n        this._mutationThrottler =\n            this._mutationThrottler ??\n            new MutationThrottler(rrwebRecord, {\n                refillRate: this._instance.config.session_recording.__mutationThrottlerRefillRate,\n                bucketSize: this._instance.config.session_recording.__mutationThrottlerBucketSize,\n                onBlockedNode: (id, node) => {\n                    const message = `Too many mutations on node '${id}'. Rate limiting. This could be due to SVG animations or something similar`\n                    logger.info(message, {\n                        node: node,\n                    })\n\n                    this.log(LOGGER_PREFIX + ' ' + message, 'warn')\n                },\n            })\n\n        const activePlugins = this._gatherRRWebPlugins()\n        this._stopRrweb = rrwebRecord({\n            emit: (event) => {\n                this.onRRwebEmit(event)\n            },\n            plugins: activePlugins,\n            ...sessionRecordingOptions,\n        })\n\n        // We reset the last activity timestamp, resetting the idle timer\n        this._lastActivityTimestamp = Date.now()\n        // stay unknown if we're not sure if we're idle or not\n        this._isIdle = isBoolean(this._isIdle) ? this._isIdle : 'unknown'\n\n        this.tryAddCustomEvent('$remote_config_received', this._remoteConfig)\n        this._tryAddCustomEvent('$session_options', {\n            sessionRecordingOptions,\n            activePlugins: activePlugins.map((p) => p?.name),\n        })\n\n        this._tryAddCustomEvent('$posthog_config', {\n            config: this._instance.config,\n        })\n    }\n\n    tryAddCustomEvent(tag: string, payload: any): boolean {\n        return this._tryAddCustomEvent(tag, payload)\n    }\n}\n"]}