{"version":3,"file":"session-recording.js","sourceRoot":"","sources":["../../../../src/extensions/replay/session-recording.ts"],"names":[],"mappings":"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","sourcesContent":["import { SESSION_RECORDING_IS_SAMPLED, SESSION_RECORDING_REMOTE_CONFIG } from '../../constants'\nimport { PostHog } from '../../posthog-core'\nimport { Properties, RemoteConfig, SessionRecordingPersistedConfig, SessionStartReason } from '../../types'\nimport { type eventWithTime } from '@rrweb/types'\n\nimport { isNullish, isUndefined } from '@posthog/core'\nimport { createLogger } from '../../utils/logger'\nimport {\n    assignableWindow,\n    LazyLoadedSessionRecordingInterface,\n    PostHogExtensionKind,\n    window,\n} from '../../utils/globals'\nimport { DISABLED, LAZY_LOADING, SessionRecordingStatus, TriggerType } from './external/triggerMatching'\n\nconst LOGGER_PREFIX = '[SessionRecording]'\nconst logger = createLogger(LOGGER_PREFIX)\n\nexport class SessionRecording {\n    _forceAllowLocalhostNetworkCapture: boolean = false\n\n    private _receivedFlags: boolean = false\n\n    private _persistFlagsOnSessionListener: (() => void) | undefined = undefined\n    private _lazyLoadedSessionRecording: LazyLoadedSessionRecordingInterface | undefined\n\n    public get started(): boolean {\n        return !!this._lazyLoadedSessionRecording?.isStarted\n    }\n\n    /**\n     * defaults to buffering mode until a flags response is received\n     * once a flags response is received status can be disabled, active or sampled\n     */\n    get status(): SessionRecordingStatus {\n        if (this._lazyLoadedSessionRecording) {\n            return this._lazyLoadedSessionRecording.status\n        }\n\n        if (this._receivedFlags && !this._isRecordingEnabled) {\n            return DISABLED\n        }\n\n        return LAZY_LOADING\n    }\n\n    constructor(private readonly _instance: PostHog) {\n        if (!this._instance.sessionManager) {\n            logger.error('started without valid sessionManager')\n            throw new Error(LOGGER_PREFIX + ' started without valid sessionManager. This is a bug.')\n        }\n\n        if (this._instance.config.cookieless_mode === 'always') {\n            throw new Error(LOGGER_PREFIX + ' cannot be used with cookieless_mode=\"always\"')\n        }\n    }\n\n    private get _isRecordingEnabled() {\n        const enabled_server_side = !!this._instance.get_property(SESSION_RECORDING_REMOTE_CONFIG)?.enabled\n        const enabled_client_side = !this._instance.config.disable_session_recording\n        const isDisabled = this._instance.config.disable_session_recording || this._instance.consent.isOptedOut()\n        return window && enabled_server_side && enabled_client_side && !isDisabled\n    }\n\n    startIfEnabledOrStop(startReason?: SessionStartReason) {\n        if (this._isRecordingEnabled && this._lazyLoadedSessionRecording?.isStarted) {\n            return\n        }\n\n        // According to the rrweb docs, rrweb is not supported on IE11 and below:\n        // \"rrweb does not support IE11 and below because it uses the MutationObserver API, which was supported by these browsers.\"\n        // https://github.com/rrweb-io/rrweb/blob/master/guide.md#compatibility-note\n        //\n        // However, MutationObserver does exist on IE11, it just doesn't work well and does not detect all changes.\n        // Instead, when we load \"recorder.js\", the first JS error is about \"Object.assign\" and \"Array.from\" being undefined.\n        // Thus instead of MutationObserver, we look for this function and block recording if it's undefined.\n        const canRunReplay = !isUndefined(Object.assign) && !isUndefined(Array.from)\n        if (this._isRecordingEnabled && canRunReplay) {\n            this._lazyLoadAndStart(startReason)\n            logger.info('starting')\n        } else {\n            this.stopRecording()\n        }\n    }\n\n    /**\n     * session recording waits until it receives remote config before loading the script\n     * this is to ensure we can control the script name remotely\n     * and because we wait until we have local and remote config to determine if we should start at all\n     * if start is called and there is no remote config then we wait until there is\n     */\n    private _lazyLoadAndStart(startReason?: SessionStartReason) {\n        // by checking `_isRecordingEnabled` here we know that\n        // we have stored remote config and client config to read\n        // replay waits for both local and remote config before starting\n        if (!this._isRecordingEnabled) {\n            return\n        }\n\n        // If recorder.js is already loaded (if array.full.js snippet is used or posthog-js/dist/recorder is\n        // imported), don't load the script. Otherwise, remotely import recorder.js from cdn since it hasn't been loaded.\n        if (\n            !assignableWindow?.__PosthogExtensions__?.rrweb?.record ||\n            !assignableWindow.__PosthogExtensions__?.initSessionRecording\n        ) {\n            assignableWindow.__PosthogExtensions__?.loadExternalDependency?.(\n                this._instance,\n                this._scriptName,\n                (err) => {\n                    if (err) {\n                        return logger.error('could not load recorder', err)\n                    }\n                    this._onScriptLoaded(startReason)\n                }\n            )\n        } else {\n            this._onScriptLoaded(startReason)\n        }\n    }\n\n    stopRecording() {\n        this._persistFlagsOnSessionListener?.()\n        this._persistFlagsOnSessionListener = undefined\n        this._lazyLoadedSessionRecording?.stop()\n    }\n\n    private _resetSampling() {\n        this._instance.persistence?.unregister(SESSION_RECORDING_IS_SAMPLED)\n    }\n\n    private _persistRemoteConfig(response: RemoteConfig): void {\n        if (this._instance.persistence) {\n            const persistence = this._instance.persistence\n\n            const persistResponse = () => {\n                const sessionRecordingConfigResponse =\n                    response.sessionRecording === false ? undefined : response.sessionRecording\n\n                const receivedSampleRate = sessionRecordingConfigResponse?.sampleRate\n\n                const parsedSampleRate = isNullish(receivedSampleRate) ? null : parseFloat(receivedSampleRate)\n                if (isNullish(parsedSampleRate)) {\n                    this._resetSampling()\n                }\n\n                const receivedMinimumDuration = sessionRecordingConfigResponse?.minimumDurationMilliseconds\n\n                persistence.register({\n                    [SESSION_RECORDING_REMOTE_CONFIG]: {\n                        enabled: !!sessionRecordingConfigResponse,\n                        ...sessionRecordingConfigResponse,\n                        networkPayloadCapture: {\n                            capturePerformance: response.capturePerformance,\n                            ...sessionRecordingConfigResponse?.networkPayloadCapture,\n                        },\n                        canvasRecording: {\n                            enabled: sessionRecordingConfigResponse?.recordCanvas,\n                            fps: sessionRecordingConfigResponse?.canvasFps,\n                            quality: sessionRecordingConfigResponse?.canvasQuality,\n                        },\n                        sampleRate: parsedSampleRate,\n                        minimumDurationMilliseconds: isUndefined(receivedMinimumDuration)\n                            ? null\n                            : receivedMinimumDuration,\n                        endpoint: sessionRecordingConfigResponse?.endpoint,\n                        triggerMatchType: sessionRecordingConfigResponse?.triggerMatchType,\n                        masking: sessionRecordingConfigResponse?.masking,\n                        urlTriggers: sessionRecordingConfigResponse?.urlTriggers,\n                    } satisfies SessionRecordingPersistedConfig,\n                })\n            }\n\n            persistResponse()\n\n            // in case we see multiple flags responses, we should only use the response from the most recent one\n            this._persistFlagsOnSessionListener?.()\n            // we 100% know there is a session manager by this point\n            this._persistFlagsOnSessionListener = this._instance.sessionManager?.onSessionId(persistResponse)\n        }\n    }\n\n    onRemoteConfig(response: RemoteConfig) {\n        if (!('sessionRecording' in response)) {\n            // if sessionRecording is not in the response, we do nothing\n            logger.info('skipping remote config with no sessionRecording', response)\n            return\n        }\n        if (response.sessionRecording === false) {\n            // remotely disabled\n            this._receivedFlags = true\n            return\n        }\n\n        this._persistRemoteConfig(response)\n        this._receivedFlags = true\n        this.startIfEnabledOrStop()\n    }\n\n    log(message: string, level: 'log' | 'warn' | 'error' = 'log') {\n        if (this._lazyLoadedSessionRecording?.log) {\n            this._lazyLoadedSessionRecording.log(message, level)\n        } else {\n            logger.warn('log called before recorder was ready')\n        }\n    }\n\n    private get _scriptName(): PostHogExtensionKind {\n        const remoteConfig: SessionRecordingPersistedConfig | undefined = this._instance?.persistence?.get_property(\n            SESSION_RECORDING_REMOTE_CONFIG\n        )\n        return (remoteConfig?.scriptConfig?.script as PostHogExtensionKind) || 'lazy-recorder'\n    }\n\n    private _onScriptLoaded(startReason?: SessionStartReason) {\n        if (!assignableWindow.__PosthogExtensions__?.initSessionRecording) {\n            throw Error('Called on script loaded before session recording is available')\n        }\n\n        if (!this._lazyLoadedSessionRecording) {\n            this._lazyLoadedSessionRecording = assignableWindow.__PosthogExtensions__?.initSessionRecording(\n                this._instance\n            )\n            ;(this._lazyLoadedSessionRecording as any)._forceAllowLocalhostNetworkCapture =\n                this._forceAllowLocalhostNetworkCapture\n        }\n\n        this._lazyLoadedSessionRecording.start(startReason)\n    }\n\n    /**\n     * this is maintained on the public API only because it has always been on the public API\n     * if you are calling this directly you are certainly doing something wrong\n     * @deprecated\n     */\n    onRRwebEmit(rawEvent: eventWithTime) {\n        this._lazyLoadedSessionRecording?.onRRwebEmit?.(rawEvent)\n    }\n\n    /**\n     * this ignores the linked flag config and (if other conditions are met) causes capture to start\n     *\n     * It is not usual to call this directly,\n     * instead call `posthog.startSessionRecording({linked_flag: true})`\n     * */\n    public overrideLinkedFlag() {\n        // TODO what if this gets called before lazy loading is done\n        this._lazyLoadedSessionRecording?.overrideLinkedFlag()\n    }\n\n    /**\n     * this ignores the sampling config and (if other conditions are met) causes capture to start\n     *\n     * It is not usual to call this directly,\n     * instead call `posthog.startSessionRecording({sampling: true})`\n     * */\n    public overrideSampling() {\n        // TODO what if this gets called before lazy loading is done\n        this._lazyLoadedSessionRecording?.overrideSampling()\n    }\n\n    /**\n     * this ignores the URL/Event trigger config and (if other conditions are met) causes capture to start\n     *\n     * It is not usual to call this directly,\n     * instead call `posthog.startSessionRecording({trigger: 'url' | 'event'})`\n     * */\n    public overrideTrigger(triggerType: TriggerType) {\n        // TODO what if this gets called before lazy loading is done\n        this._lazyLoadedSessionRecording?.overrideTrigger(triggerType)\n    }\n\n    /*\n     * whenever we capture an event, we add these properties to the event\n     * these are used to debug issues with the session recording\n     * when looking at the event feed for a session\n     */\n    get sdkDebugProperties(): Properties {\n        return (\n            this._lazyLoadedSessionRecording?.sdkDebugProperties || {\n                $recording_status: this.status,\n            }\n        )\n    }\n\n    /**\n     * This adds a custom event to the session recording\n     *\n     * It is not intended for arbitrary public use - playback only displays known custom events\n     * And is exposed on the public interface only so that other parts of the SDK are able to use it\n     *\n     * if you are calling this from client code, you're probably looking for `posthog.capture('$custom_event', {...})`\n     */\n    tryAddCustomEvent(tag: string, payload: any): boolean {\n        return !!this._lazyLoadedSessionRecording?.tryAddCustomEvent(tag, payload)\n    }\n}\n"]}