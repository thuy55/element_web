{"version":3,"file":"request-queue.js","sourceRoot":"","sources":["../../src/request-queue.ts"],"names":[],"mappings":"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","sourcesContent":["import { QueuedRequestWithOptions, RequestQueueConfig } from './types'\nimport { each } from './utils'\n\nimport { isArray, isUndefined, clampToRange } from '@posthog/core'\nimport { logger } from './utils/logger'\n\nexport const DEFAULT_FLUSH_INTERVAL_MS = 3000\n\nexport class RequestQueue {\n    // We start in a paused state and only start flushing when enabled by the parent\n    private _isPaused: boolean = true\n    private _queue: QueuedRequestWithOptions[] = []\n    private _flushTimeout?: ReturnType<typeof setTimeout>\n    private _flushTimeoutMs: number\n    private _sendRequest: (req: QueuedRequestWithOptions) => void\n\n    constructor(sendRequest: (req: QueuedRequestWithOptions) => void, config?: RequestQueueConfig) {\n        this._flushTimeoutMs = clampToRange(\n            config?.flush_interval_ms || DEFAULT_FLUSH_INTERVAL_MS,\n            250,\n            5000,\n            logger.createLogger('flush interval'),\n            DEFAULT_FLUSH_INTERVAL_MS\n        )\n        this._sendRequest = sendRequest\n    }\n\n    enqueue(req: QueuedRequestWithOptions): void {\n        this._queue.push(req)\n\n        if (!this._flushTimeout) {\n            this._setFlushTimeout()\n        }\n    }\n\n    unload(): void {\n        this._clearFlushTimeout()\n        const requests = this._queue.length > 0 ? this._formatQueue() : {}\n        const requestValues = Object.values(requests)\n\n        // Always force events to be sent before recordings, as events are more important, and recordings are bigger and thus less likely to arrive\n        const sortedRequests = [\n            ...requestValues.filter((r) => r.url.indexOf('/e') === 0),\n            ...requestValues.filter((r) => r.url.indexOf('/e') !== 0),\n        ]\n        sortedRequests.map((req) => {\n            this._sendRequest({ ...req, transport: 'sendBeacon' })\n        })\n    }\n\n    enable(): void {\n        this._isPaused = false\n        this._setFlushTimeout()\n    }\n\n    private _setFlushTimeout(): void {\n        if (this._isPaused) {\n            return\n        }\n        this._flushTimeout = setTimeout(() => {\n            this._clearFlushTimeout()\n            if (this._queue.length > 0) {\n                const requests = this._formatQueue()\n                for (const key in requests) {\n                    const req = requests[key]\n                    const now = new Date().getTime()\n\n                    if (req.data && isArray(req.data)) {\n                        each(req.data, (data) => {\n                            data['offset'] = Math.abs(data['timestamp'] - now)\n                            delete data['timestamp']\n                        })\n                    }\n                    this._sendRequest(req)\n                }\n            }\n        }, this._flushTimeoutMs)\n    }\n\n    private _clearFlushTimeout(): void {\n        clearTimeout(this._flushTimeout)\n        this._flushTimeout = undefined\n    }\n\n    private _formatQueue(): Record<string, QueuedRequestWithOptions> {\n        const requests: Record<string, QueuedRequestWithOptions> = {}\n        each(this._queue, (request: QueuedRequestWithOptions) => {\n            const req = request\n            const key = (req ? req.batchKey : null) || req.url\n            if (isUndefined(requests[key])) {\n                // TODO: What about this -it seems to batch data into an array - do we always want that?\n                requests[key] = { ...req, data: [] }\n            }\n\n            requests[key].data?.push(req.data)\n        })\n\n        this._queue = []\n        return requests\n    }\n}\n"]}