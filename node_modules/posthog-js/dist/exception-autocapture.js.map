{"version":3,"file":"exception-autocapture.js","sources":["../src/utils/globals.ts","../../core/dist/utils/type-utils.mjs","../../core/dist/utils/index.mjs","../../core/dist/error-tracking/chunk-ids.mjs","../../core/dist/error-tracking/parsers/base.mjs","../../core/dist/error-tracking/parsers/safari.mjs","../../core/dist/error-tracking/parsers/chrome.mjs","../../core/dist/error-tracking/parsers/gecko.mjs","../../core/dist/error-tracking/parsers/index.mjs","../../core/dist/error-tracking/error-properties-builder.mjs","../../core/dist/error-tracking/coercers/dom-exception-coercer.mjs","../../core/dist/error-tracking/coercers/error-coercer.mjs","../../core/dist/error-tracking/coercers/error-event-coercer.mjs","../../core/dist/error-tracking/coercers/string-coercer.mjs","../../core/dist/error-tracking/types.mjs","../../core/dist/error-tracking/coercers/utils.mjs","../../core/dist/error-tracking/coercers/object-coercer.mjs","../../core/dist/error-tracking/coercers/event-coercer.mjs","../../core/dist/error-tracking/coercers/primitive-coercer.mjs","../../core/dist/error-tracking/coercers/promise-rejection-event.mjs","../src/utils/logger.ts","../src/request.ts","../src/entrypoints/exception-autocapture.ts","../src/posthog-exceptions.ts"],"sourcesContent":["import type { PostHog } from '../posthog-core'\nimport { SessionIdManager } from '../sessionid'\nimport {\n    DeadClicksAutoCaptureConfig,\n    ExternalIntegrationKind,\n    Properties,\n    RemoteConfig,\n    SiteAppLoader,\n    SessionStartReason,\n} from '../types'\n// only importing types here, so won't affect the bundle\n// eslint-disable-next-line posthog-js/no-external-replay-imports\nimport type { SessionRecordingStatus, TriggerType } from '../extensions/replay/external/triggerMatching'\nimport { eventWithTime } from '@rrweb/types'\nimport { ErrorTracking } from '@posthog/core'\n\n/*\n * Global helpers to protect access to browser globals in a way that is safer for different targets\n * like DOM, SSR, Web workers etc.\n *\n * NOTE: Typically we want the \"window\" but globalThis works for both the typical browser context as\n * well as other contexts such as the web worker context. Window is still exported for any bits that explicitly require it.\n * If in doubt - export the global you need from this file and use that as an optional value. This way the code path is forced\n * to handle the case where the global is not available.\n */\n\n// eslint-disable-next-line no-restricted-globals\nconst win: (Window & typeof globalThis) | undefined = typeof window !== 'undefined' ? window : undefined\n\nexport type AssignableWindow = Window &\n    typeof globalThis & {\n        /*\n         * Main PostHog instance\n         */\n        posthog: any\n\n        /*\n         * This is our contract between (potentially) lazily loaded extensions and the SDK\n         */\n        __PosthogExtensions__?: PostHogExtensions\n\n        /**\n         * When loading remote config, we assign it to this global configuration\n         * for ease of sharing it with the rest of the SDK\n         */\n        _POSTHOG_REMOTE_CONFIG?: Record<\n            string,\n            {\n                config: RemoteConfig\n                siteApps: SiteAppLoader[]\n            }\n        >\n\n        /**\n         * If this is set on the window, our logger will log to the console\n         * for ease of debugging. Used for testing purposes only.\n         *\n         * @see {Config.DEBUG} from config.ts\n         */\n        POSTHOG_DEBUG: any\n\n        // Exposed by the browser\n        doNotTrack: any\n\n        // See entrypoints/customizations.full.ts\n        posthogCustomizations: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/exception-autocapture.ts\n         *\n         * @deprecated use `__PosthogExtensions__.errorWrappingFunctions` instead\n         */\n        posthogErrorWrappingFunctions: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/posthog-recorder.ts\n         *\n         * @deprecated use `__PosthogExtensions__.rrweb` instead\n         */\n        rrweb: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/posthog-recorder.ts\n         *\n         * @deprecated use `__PosthogExtensions__.rrwebConsoleRecord` instead\n         */\n        rrwebConsoleRecord: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/posthog-recorder.ts\n         *\n         * @deprecated use `__PosthogExtensions__.getRecordNetworkPlugin` instead\n         */\n        getRecordNetworkPlugin: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/web-vitals.ts\n         *\n         * @deprecated use `__PosthogExtensions__.postHogWebVitalsCallbacks` instead\n         */\n        postHogWebVitalsCallbacks: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/tracing-headers.ts\n         *\n         * @deprecated use `__PosthogExtensions__.postHogTracingHeadersPatchFns` instead\n         */\n        postHogTracingHeadersPatchFns: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/surveys.ts\n         *\n         * @deprecated use `__PosthogExtensions__.generateSurveys` instead\n         */\n        extendPostHogWithSurveys: any\n\n        /*\n         * These are used to handle our toolbar state.\n         * @see {Toolbar} from extensions/toolbar.ts\n         */\n        ph_load_toolbar: any\n        ph_load_editor: any\n        ph_toolbar_state: any\n    } & Record<`__$$ph_site_app_${string}`, any>\n\n/**\n * This is our contract between (potentially) lazily loaded extensions and the SDK\n * changes to this interface can be breaking changes for users of the SDK\n */\n\nexport type ExternalExtensionKind = 'intercom-integration' | 'crisp-chat-integration'\n\nexport type PostHogExtensionKind =\n    | 'toolbar'\n    | 'exception-autocapture'\n    | 'web-vitals'\n    | 'recorder'\n    | 'lazy-recorder'\n    | 'tracing-headers'\n    | 'surveys'\n    | 'dead-clicks-autocapture'\n    | 'remote-config'\n    | ExternalExtensionKind\n\nexport interface LazyLoadedSessionRecordingInterface {\n    start: (startReason?: SessionStartReason) => void\n    stop: () => void\n    sessionId: string\n    status: SessionRecordingStatus\n    onRRwebEmit: (rawEvent: eventWithTime) => void\n    log: (message: string, level: 'log' | 'warn' | 'error') => void\n    sdkDebugProperties: Properties\n    overrideLinkedFlag: () => void\n    overrideSampling: () => void\n    overrideTrigger: (triggerType: TriggerType) => void\n    isStarted: boolean\n    tryAddCustomEvent(tag: string, payload: any): boolean\n}\n\nexport interface LazyLoadedDeadClicksAutocaptureInterface {\n    start: (observerTarget: Node) => void\n    stop: () => void\n}\n\ninterface PostHogExtensions {\n    loadExternalDependency?: (\n        posthog: PostHog,\n        kind: PostHogExtensionKind,\n        callback: (error?: string | Event, event?: Event) => void\n    ) => void\n\n    loadSiteApp?: (posthog: PostHog, appUrl: string, callback: (error?: string | Event, event?: Event) => void) => void\n\n    errorWrappingFunctions?: {\n        wrapOnError: (captureFn: (props: ErrorTracking.ErrorProperties) => void) => () => void\n        wrapUnhandledRejection: (captureFn: (props: ErrorTracking.ErrorProperties) => void) => () => void\n        wrapConsoleError: (captureFn: (props: ErrorTracking.ErrorProperties) => void) => () => void\n    }\n    rrweb?: { record: any; version: string }\n    rrwebPlugins?: { getRecordConsolePlugin: any; getRecordNetworkPlugin?: any }\n    generateSurveys?: (posthog: PostHog, isSurveysEnabled: boolean) => any | undefined\n    postHogWebVitalsCallbacks?: {\n        onLCP: (metric: any) => void\n        onCLS: (metric: any) => void\n        onFCP: (metric: any) => void\n        onINP: (metric: any) => void\n    }\n    tracingHeadersPatchFns?: {\n        _patchFetch: (hostnames: string[], distinctId: string, sessionManager?: SessionIdManager) => () => void\n        _patchXHR: (hostnames: string[], distinctId: string, sessionManager?: SessionIdManager) => () => void\n    }\n    initDeadClicksAutocapture?: (\n        ph: PostHog,\n        config: DeadClicksAutoCaptureConfig\n    ) => LazyLoadedDeadClicksAutocaptureInterface\n    integrations?: {\n        [K in ExternalIntegrationKind]?: { start: (posthog: PostHog) => void; stop: () => void }\n    }\n    initSessionRecording?: (ph: PostHog) => LazyLoadedSessionRecordingInterface\n}\n\nconst global: typeof globalThis | undefined = typeof globalThis !== 'undefined' ? globalThis : win\n\nexport const ArrayProto = Array.prototype\nexport const nativeForEach = ArrayProto.forEach\nexport const nativeIndexOf = ArrayProto.indexOf\n\nexport const navigator = global?.navigator\nexport const document = global?.document\nexport const location = global?.location\nexport const fetch = global?.fetch\nexport const XMLHttpRequest =\n    global?.XMLHttpRequest && 'withCredentials' in new global.XMLHttpRequest() ? global.XMLHttpRequest : undefined\nexport const AbortController = global?.AbortController\nexport const userAgent = navigator?.userAgent\nexport const assignableWindow: AssignableWindow = win ?? ({} as any)\n\nexport { win as window }\n","import { knownUnsafeEditableEvent } from \"../types.mjs\";\nimport { includes } from \"./string-utils.mjs\";\nconst nativeIsArray = Array.isArray;\nconst ObjProto = Object.prototype;\nconst type_utils_hasOwnProperty = ObjProto.hasOwnProperty;\nconst type_utils_toString = ObjProto.toString;\nconst isArray = nativeIsArray || function(obj) {\n    return '[object Array]' === type_utils_toString.call(obj);\n};\nconst isFunction = (x)=>'function' == typeof x;\nconst isNativeFunction = (x)=>isFunction(x) && -1 !== x.toString().indexOf('[native code]');\nconst isObject = (x)=>x === Object(x) && !isArray(x);\nconst isEmptyObject = (x)=>{\n    if (isObject(x)) {\n        for(const key in x)if (type_utils_hasOwnProperty.call(x, key)) return false;\n        return true;\n    }\n    return false;\n};\nconst isUndefined = (x)=>void 0 === x;\nconst isString = (x)=>'[object String]' == type_utils_toString.call(x);\nconst isEmptyString = (x)=>isString(x) && 0 === x.trim().length;\nconst isNull = (x)=>null === x;\nconst isNullish = (x)=>isUndefined(x) || isNull(x);\nconst isNumber = (x)=>'[object Number]' == type_utils_toString.call(x);\nconst isBoolean = (x)=>'[object Boolean]' === type_utils_toString.call(x);\nconst isFormData = (x)=>x instanceof FormData;\nconst isFile = (x)=>x instanceof File;\nconst isPlainError = (x)=>x instanceof Error;\nconst isKnownUnsafeEditableEvent = (x)=>includes(knownUnsafeEditableEvent, x);\nfunction isInstanceOf(candidate, base) {\n    try {\n        return candidate instanceof base;\n    } catch  {\n        return false;\n    }\n}\nfunction isPrimitive(value) {\n    return null === value || 'object' != typeof value;\n}\nfunction isBuiltin(candidate, className) {\n    return Object.prototype.toString.call(candidate) === `[object ${className}]`;\n}\nfunction isError(candidate) {\n    switch(Object.prototype.toString.call(candidate)){\n        case '[object Error]':\n        case '[object Exception]':\n        case '[object DOMException]':\n        case '[object DOMError]':\n        case '[object WebAssembly.Exception]':\n            return true;\n        default:\n            return isInstanceOf(candidate, Error);\n    }\n}\nfunction isErrorEvent(event) {\n    return isBuiltin(event, 'ErrorEvent');\n}\nfunction isEvent(candidate) {\n    return !isUndefined(Event) && isInstanceOf(candidate, Event);\n}\nfunction isPlainObject(candidate) {\n    return isBuiltin(candidate, 'Object');\n}\nconst yesLikeValues = [\n    true,\n    'true',\n    1,\n    '1',\n    'yes'\n];\nconst isYesLike = (val)=>includes(yesLikeValues, val);\nconst noLikeValues = [\n    false,\n    'false',\n    0,\n    '0',\n    'no'\n];\nconst isNoLike = (val)=>includes(noLikeValues, val);\nexport { type_utils_hasOwnProperty as hasOwnProperty, isArray, isBoolean, isBuiltin, isEmptyObject, isEmptyString, isError, isErrorEvent, isEvent, isFile, isFormData, isFunction, isInstanceOf, isKnownUnsafeEditableEvent, isNativeFunction, isNoLike, isNull, isNullish, isNumber, isObject, isPlainError, isPlainObject, isPrimitive, isString, isUndefined, isYesLike, noLikeValues, yesLikeValues };\n","export * from \"./bucketed-rate-limiter.mjs\";\nexport * from \"./number-utils.mjs\";\nexport * from \"./string-utils.mjs\";\nexport * from \"./type-utils.mjs\";\nexport * from \"./promise-queue.mjs\";\nconst STRING_FORMAT = 'utf8';\nfunction assert(truthyValue, message) {\n    if (!truthyValue || 'string' != typeof truthyValue || isEmpty(truthyValue)) throw new Error(message);\n}\nfunction isEmpty(truthyValue) {\n    if (0 === truthyValue.trim().length) return true;\n    return false;\n}\nfunction removeTrailingSlash(url) {\n    return url?.replace(/\\/+$/, '');\n}\nasync function retriable(fn, props) {\n    let lastError = null;\n    for(let i = 0; i < props.retryCount + 1; i++){\n        if (i > 0) await new Promise((r)=>setTimeout(r, props.retryDelay));\n        try {\n            const res = await fn();\n            return res;\n        } catch (e) {\n            lastError = e;\n            if (!props.retryCheck(e)) throw e;\n        }\n    }\n    throw lastError;\n}\nfunction currentTimestamp() {\n    return new Date().getTime();\n}\nfunction currentISOTime() {\n    return new Date().toISOString();\n}\nfunction safeSetTimeout(fn, timeout) {\n    const t = setTimeout(fn, timeout);\n    t?.unref && t?.unref();\n    return t;\n}\nconst isPromise = (obj)=>obj && 'function' == typeof obj.then;\nconst isError = (x)=>x instanceof Error;\nfunction getFetch() {\n    return 'undefined' != typeof fetch ? fetch : void 0 !== globalThis.fetch ? globalThis.fetch : void 0;\n}\nfunction allSettled(promises) {\n    return Promise.all(promises.map((p)=>(p ?? Promise.resolve()).then((value)=>({\n                status: 'fulfilled',\n                value\n            }), (reason)=>({\n                status: 'rejected',\n                reason\n            }))));\n}\nexport { STRING_FORMAT, allSettled, assert, currentISOTime, currentTimestamp, getFetch, isError, isPromise, removeTrailingSlash, retriable, safeSetTimeout };\n","let parsedStackResults;\nlet lastKeysCount;\nlet cachedFilenameChunkIds;\nfunction getFilenameToChunkIdMap(stackParser) {\n    const chunkIdMap = globalThis._posthogChunkIds;\n    if (!chunkIdMap) return;\n    const chunkIdKeys = Object.keys(chunkIdMap);\n    if (cachedFilenameChunkIds && chunkIdKeys.length === lastKeysCount) return cachedFilenameChunkIds;\n    lastKeysCount = chunkIdKeys.length;\n    cachedFilenameChunkIds = chunkIdKeys.reduce((acc, stackKey)=>{\n        if (!parsedStackResults) parsedStackResults = {};\n        const result = parsedStackResults[stackKey];\n        if (result) acc[result[0]] = result[1];\n        else {\n            const parsedStack = stackParser(stackKey);\n            for(let i = parsedStack.length - 1; i >= 0; i--){\n                const stackFrame = parsedStack[i];\n                const filename = stackFrame?.filename;\n                const chunkId = chunkIdMap[stackKey];\n                if (filename && chunkId) {\n                    acc[filename] = chunkId;\n                    parsedStackResults[stackKey] = [\n                        filename,\n                        chunkId\n                    ];\n                    break;\n                }\n            }\n        }\n        return acc;\n    }, {});\n    return cachedFilenameChunkIds;\n}\nexport { getFilenameToChunkIdMap };\n","import { isUndefined } from \"../../utils/index.mjs\";\nconst UNKNOWN_FUNCTION = '?';\nfunction createFrame(filename, func, lineno, colno) {\n    const frame = {\n        platform: \"web:javascript\",\n        filename,\n        function: '<anonymous>' === func ? UNKNOWN_FUNCTION : func,\n        in_app: true\n    };\n    if (!isUndefined(lineno)) frame.lineno = lineno;\n    if (!isUndefined(colno)) frame.colno = colno;\n    return frame;\n}\nexport { UNKNOWN_FUNCTION, createFrame };\n","import { UNKNOWN_FUNCTION } from \"./base.mjs\";\nconst extractSafariExtensionDetails = (func, filename)=>{\n    const isSafariExtension = -1 !== func.indexOf('safari-extension');\n    const isSafariWebExtension = -1 !== func.indexOf('safari-web-extension');\n    return isSafariExtension || isSafariWebExtension ? [\n        -1 !== func.indexOf('@') ? func.split('@')[0] : UNKNOWN_FUNCTION,\n        isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`\n    ] : [\n        func,\n        filename\n    ];\n};\nexport { extractSafariExtensionDetails };\n","import { UNKNOWN_FUNCTION, createFrame } from \"./base.mjs\";\nimport { extractSafariExtensionDetails } from \"./safari.mjs\";\nconst chromeRegexNoFnName = /^\\s*at (\\S+?)(?::(\\d+))(?::(\\d+))\\s*$/i;\nconst chromeRegex = /^\\s*at (?:(.+?\\)(?: \\[.+\\])?|.*?) ?\\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\\/)?.*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nconst chromeEvalRegex = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\nconst chromeStackLineParser = (line)=>{\n    const noFnParts = chromeRegexNoFnName.exec(line);\n    if (noFnParts) {\n        const [, filename, line, col] = noFnParts;\n        return createFrame(filename, UNKNOWN_FUNCTION, +line, +col);\n    }\n    const parts = chromeRegex.exec(line);\n    if (parts) {\n        const isEval = parts[2] && 0 === parts[2].indexOf('eval');\n        if (isEval) {\n            const subMatch = chromeEvalRegex.exec(parts[2]);\n            if (subMatch) {\n                parts[2] = subMatch[1];\n                parts[3] = subMatch[2];\n                parts[4] = subMatch[3];\n            }\n        }\n        const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);\n        return createFrame(filename, func, parts[3] ? +parts[3] : void 0, parts[4] ? +parts[4] : void 0);\n    }\n};\nexport { chromeStackLineParser };\n","import { UNKNOWN_FUNCTION, createFrame } from \"./base.mjs\";\nimport { extractSafariExtensionDetails } from \"./safari.mjs\";\nconst geckoREgex = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)?((?:[-a-z]+)?:\\/.*?|\\[native code\\]|[^@]*(?:bundle|\\d+\\.js)|\\/[\\w\\-. /=]+)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nconst geckoEvalRegex = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\nconst geckoStackLineParser = (line)=>{\n    const parts = geckoREgex.exec(line);\n    if (parts) {\n        const isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n        if (isEval) {\n            const subMatch = geckoEvalRegex.exec(parts[3]);\n            if (subMatch) {\n                parts[1] = parts[1] || 'eval';\n                parts[3] = subMatch[1];\n                parts[4] = subMatch[2];\n                parts[5] = '';\n            }\n        }\n        let filename = parts[3];\n        let func = parts[1] || UNKNOWN_FUNCTION;\n        [func, filename] = extractSafariExtensionDetails(func, filename);\n        return createFrame(filename, func, parts[4] ? +parts[4] : void 0, parts[5] ? +parts[5] : void 0);\n    }\n};\nexport { geckoStackLineParser };\n","import { UNKNOWN_FUNCTION } from \"./base.mjs\";\nimport { chromeStackLineParser } from \"./chrome.mjs\";\nimport { winjsStackLineParser } from \"./winjs.mjs\";\nimport { geckoStackLineParser } from \"./gecko.mjs\";\nimport { opera10StackLineParser, opera11StackLineParser } from \"./opera.mjs\";\nimport { nodeStackLineParser } from \"./node.mjs\";\nconst WEBPACK_ERROR_REGEXP = /\\(error: (.*)\\)/;\nconst STACKTRACE_FRAME_LIMIT = 50;\nfunction reverseAndStripFrames(stack) {\n    if (!stack.length) return [];\n    const localStack = Array.from(stack);\n    localStack.reverse();\n    return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map((frame)=>({\n            ...frame,\n            filename: frame.filename || getLastStackFrame(localStack).filename,\n            function: frame.function || UNKNOWN_FUNCTION\n        }));\n}\nfunction getLastStackFrame(arr) {\n    return arr[arr.length - 1] || {};\n}\nfunction createStackParser(...parsers) {\n    return (stack, skipFirstLines = 0)=>{\n        const frames = [];\n        const lines = stack.split('\\n');\n        for(let i = skipFirstLines; i < lines.length; i++){\n            const line = lines[i];\n            if (line.length > 1024) continue;\n            const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, '$1') : line;\n            if (!cleanedLine.match(/\\S*Error: /)) {\n                for (const parser of parsers){\n                    const frame = parser(cleanedLine);\n                    if (frame) {\n                        frames.push(frame);\n                        break;\n                    }\n                }\n                if (frames.length >= STACKTRACE_FRAME_LIMIT) break;\n            }\n        }\n        return reverseAndStripFrames(frames);\n    };\n}\nexport { chromeStackLineParser, createStackParser, geckoStackLineParser, nodeStackLineParser, opera10StackLineParser, opera11StackLineParser, reverseAndStripFrames, winjsStackLineParser };\n","import { isArray } from \"../utils/index.mjs\";\nimport { getFilenameToChunkIdMap } from \"./chunk-ids.mjs\";\nimport { createStackParser } from \"./parsers/index.mjs\";\nconst MAX_CAUSE_RECURSION = 4;\nclass ErrorPropertiesBuilder {\n    constructor(coercers = [], parsers = [], modifiers = []){\n        this.coercers = coercers;\n        this.modifiers = modifiers;\n        this.stackParser = createStackParser(...parsers);\n    }\n    buildFromUnknown(input, hint = {}) {\n        const providedMechanism = hint && hint.mechanism;\n        const mechanism = providedMechanism || {\n            handled: true,\n            type: 'generic'\n        };\n        const coercingContext = this.buildCoercingContext(mechanism, hint, 0);\n        const exceptionWithCause = coercingContext.apply(input);\n        const parsingContext = this.buildParsingContext();\n        const exceptionWithStack = this.parseStacktrace(exceptionWithCause, parsingContext);\n        const exceptionList = this.convertToExceptionList(exceptionWithStack, mechanism);\n        return {\n            $exception_list: exceptionList,\n            $exception_level: 'error'\n        };\n    }\n    async modifyFrames(exceptionList) {\n        for (const exc of exceptionList)if (exc.stacktrace && exc.stacktrace.frames && isArray(exc.stacktrace.frames)) exc.stacktrace.frames = await this.applyModifiers(exc.stacktrace.frames);\n        return exceptionList;\n    }\n    coerceFallback(ctx) {\n        return {\n            type: 'Error',\n            value: 'Unknown error',\n            stack: ctx.syntheticException?.stack,\n            synthetic: true\n        };\n    }\n    parseStacktrace(err, ctx) {\n        let cause;\n        if (null != err.cause) cause = this.parseStacktrace(err.cause, ctx);\n        let stack;\n        if ('' != err.stack && null != err.stack) stack = this.applyChunkIds(this.stackParser(err.stack, err.synthetic ? 1 : 0), ctx.chunkIdMap);\n        return {\n            ...err,\n            cause,\n            stack\n        };\n    }\n    applyChunkIds(frames, chunkIdMap) {\n        return frames.map((frame)=>{\n            if (frame.filename && chunkIdMap) frame.chunk_id = chunkIdMap[frame.filename];\n            return frame;\n        });\n    }\n    applyCoercers(input, ctx) {\n        for (const adapter of this.coercers)if (adapter.match(input)) return adapter.coerce(input, ctx);\n        return this.coerceFallback(ctx);\n    }\n    async applyModifiers(frames) {\n        let newFrames = frames;\n        for (const modifier of this.modifiers)newFrames = await modifier(newFrames);\n        return newFrames;\n    }\n    convertToExceptionList(exceptionWithStack, mechanism) {\n        const currentException = {\n            type: exceptionWithStack.type,\n            value: exceptionWithStack.value,\n            mechanism: {\n                type: mechanism.type ?? 'generic',\n                handled: mechanism.handled ?? true,\n                synthetic: exceptionWithStack.synthetic ?? false\n            }\n        };\n        if (exceptionWithStack.stack) currentException.stacktrace = {\n            type: 'raw',\n            frames: exceptionWithStack.stack\n        };\n        const exceptionList = [\n            currentException\n        ];\n        if (null != exceptionWithStack.cause) exceptionList.push(...this.convertToExceptionList(exceptionWithStack.cause, {\n            ...mechanism,\n            handled: true\n        }));\n        return exceptionList;\n    }\n    buildParsingContext() {\n        const context = {\n            chunkIdMap: getFilenameToChunkIdMap(this.stackParser)\n        };\n        return context;\n    }\n    buildCoercingContext(mechanism, hint, depth = 0) {\n        const coerce = (input, depth)=>{\n            if (!(depth <= MAX_CAUSE_RECURSION)) return;\n            {\n                const ctx = this.buildCoercingContext(mechanism, hint, depth);\n                return this.applyCoercers(input, ctx);\n            }\n        };\n        const context = {\n            ...hint,\n            syntheticException: 0 == depth ? hint.syntheticException : void 0,\n            mechanism,\n            apply: (input)=>coerce(input, depth),\n            next: (input)=>coerce(input, depth + 1)\n        };\n        return context;\n    }\n}\nexport { ErrorPropertiesBuilder };\n","import { isBuiltin, isString } from \"../../utils/index.mjs\";\nclass DOMExceptionCoercer {\n    match(err) {\n        return this.isDOMException(err) || this.isDOMError(err);\n    }\n    coerce(err, ctx) {\n        const hasStack = isString(err.stack);\n        return {\n            type: this.getType(err),\n            value: this.getValue(err),\n            stack: hasStack ? err.stack : void 0,\n            cause: err.cause ? ctx.next(err.cause) : void 0,\n            synthetic: false\n        };\n    }\n    getType(candidate) {\n        return this.isDOMError(candidate) ? 'DOMError' : 'DOMException';\n    }\n    getValue(err) {\n        const name = err.name || (this.isDOMError(err) ? 'DOMError' : 'DOMException');\n        const message = err.message ? `${name}: ${err.message}` : name;\n        return message;\n    }\n    isDOMException(err) {\n        return isBuiltin(err, 'DOMException');\n    }\n    isDOMError(err) {\n        return isBuiltin(err, 'DOMError');\n    }\n}\nexport { DOMExceptionCoercer };\n","import { isPlainError } from \"../../utils/index.mjs\";\nclass ErrorCoercer {\n    match(err) {\n        return isPlainError(err);\n    }\n    coerce(err, ctx) {\n        return {\n            type: this.getType(err),\n            value: this.getMessage(err, ctx),\n            stack: this.getStack(err),\n            cause: err.cause ? ctx.next(err.cause) : void 0,\n            synthetic: false\n        };\n    }\n    getType(err) {\n        return err.name || err.constructor.name;\n    }\n    getMessage(err, _ctx) {\n        const message = err.message;\n        if (message.error && 'string' == typeof message.error.message) return String(message.error.message);\n        return String(message);\n    }\n    getStack(err) {\n        return err.stacktrace || err.stack || void 0;\n    }\n}\nexport { ErrorCoercer };\n","import { isErrorEvent } from \"../../utils/index.mjs\";\nclass ErrorEventCoercer {\n    constructor(){}\n    match(err) {\n        return isErrorEvent(err) && void 0 != err.error;\n    }\n    coerce(err, ctx) {\n        const exceptionLike = ctx.apply(err.error);\n        if (!exceptionLike) return {\n            type: 'ErrorEvent',\n            value: err.message,\n            stack: ctx.syntheticException?.stack,\n            synthetic: true\n        };\n        return exceptionLike;\n    }\n}\nexport { ErrorEventCoercer };\n","const ERROR_TYPES_PATTERN = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;\nclass StringCoercer {\n    match(input) {\n        return 'string' == typeof input;\n    }\n    coerce(input, ctx) {\n        const [type, value] = this.getInfos(input);\n        return {\n            type: type ?? 'Error',\n            value: value ?? input,\n            stack: ctx.syntheticException?.stack,\n            synthetic: true\n        };\n    }\n    getInfos(candidate) {\n        let type = 'Error';\n        let value = candidate;\n        const groups = candidate.match(ERROR_TYPES_PATTERN);\n        if (groups) {\n            type = groups[1];\n            value = groups[2];\n        }\n        return [\n            type,\n            value\n        ];\n    }\n}\nexport { StringCoercer };\n","const severityLevels = [\n    'fatal',\n    'error',\n    'warning',\n    'log',\n    'info',\n    'debug'\n];\nexport { severityLevels };\n","function truncate(str, max = 0) {\n    if ('string' != typeof str || 0 === max) return str;\n    return str.length <= max ? str : `${str.slice(0, max)}...`;\n}\nfunction extractExceptionKeysForMessage(err, maxLength = 40) {\n    const keys = Object.keys(err);\n    keys.sort();\n    if (!keys.length) return '[object has no keys]';\n    for(let i = keys.length; i > 0; i--){\n        const serialized = keys.slice(0, i).join(', ');\n        if (!(serialized.length > maxLength)) {\n            if (i === keys.length) return serialized;\n            return serialized.length <= maxLength ? serialized : `${serialized.slice(0, maxLength)}...`;\n        }\n    }\n    return '';\n}\nexport { extractExceptionKeysForMessage, truncate };\n","import { isEmptyString, isError, isEvent, isString } from \"../../utils/index.mjs\";\nimport { severityLevels } from \"../types.mjs\";\nimport { extractExceptionKeysForMessage } from \"./utils.mjs\";\nclass ObjectCoercer {\n    match(candidate) {\n        return 'object' == typeof candidate && null !== candidate;\n    }\n    coerce(candidate, ctx) {\n        const errorProperty = this.getErrorPropertyFromObject(candidate);\n        if (errorProperty) return ctx.apply(errorProperty);\n        return {\n            type: this.getType(candidate),\n            value: this.getValue(candidate),\n            stack: ctx.syntheticException?.stack,\n            level: this.isSeverityLevel(candidate.level) ? candidate.level : 'error',\n            synthetic: true\n        };\n    }\n    getType(err) {\n        return isEvent(err) ? err.constructor.name : 'Error';\n    }\n    getValue(err) {\n        if ('name' in err && 'string' == typeof err.name) {\n            let message = `'${err.name}' captured as exception`;\n            if ('message' in err && 'string' == typeof err.message) message += ` with message: '${err.message}'`;\n            return message;\n        }\n        if ('message' in err && 'string' == typeof err.message) return err.message;\n        const className = this.getObjectClassName(err);\n        const keys = extractExceptionKeysForMessage(err);\n        return `${className && 'Object' !== className ? `'${className}'` : 'Object'} captured as exception with keys: ${keys}`;\n    }\n    isSeverityLevel(x) {\n        return isString(x) && !isEmptyString(x) && severityLevels.indexOf(x) >= 0;\n    }\n    getErrorPropertyFromObject(obj) {\n        for(const prop in obj)if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n            const value = obj[prop];\n            if (isError(value)) return value;\n        }\n    }\n    getObjectClassName(obj) {\n        try {\n            const prototype = Object.getPrototypeOf(obj);\n            return prototype ? prototype.constructor.name : void 0;\n        } catch (e) {\n            return;\n        }\n    }\n}\nexport { ObjectCoercer };\n","import { isEvent } from \"../../utils/index.mjs\";\nimport { extractExceptionKeysForMessage } from \"./utils.mjs\";\nclass EventCoercer {\n    match(err) {\n        return isEvent(err);\n    }\n    coerce(evt, ctx) {\n        const constructorName = evt.constructor.name;\n        return {\n            type: constructorName,\n            value: `${constructorName} captured as exception with keys: ${extractExceptionKeysForMessage(evt)}`,\n            stack: ctx.syntheticException?.stack,\n            synthetic: true\n        };\n    }\n}\nexport { EventCoercer };\n","import { isPrimitive } from \"../../utils/index.mjs\";\nclass PrimitiveCoercer {\n    match(candidate) {\n        return isPrimitive(candidate);\n    }\n    coerce(value, ctx) {\n        return {\n            type: 'Error',\n            value: `Primitive value captured as exception: ${String(value)}`,\n            stack: ctx.syntheticException?.stack,\n            synthetic: true\n        };\n    }\n}\nexport { PrimitiveCoercer };\n","import { isBuiltin, isPrimitive } from \"../../utils/index.mjs\";\nclass PromiseRejectionEventCoercer {\n    match(err) {\n        return isBuiltin(err, 'PromiseRejectionEvent');\n    }\n    coerce(err, ctx) {\n        const reason = this.getUnhandledRejectionReason(err);\n        if (isPrimitive(reason)) return {\n            type: 'UnhandledRejection',\n            value: `Non-Error promise rejection captured with value: ${String(reason)}`,\n            stack: ctx.syntheticException?.stack,\n            synthetic: true\n        };\n        return ctx.apply(reason);\n    }\n    getUnhandledRejectionReason(error) {\n        if (isPrimitive(error)) return error;\n        try {\n            if ('reason' in error) return error.reason;\n            if ('detail' in error && 'reason' in error.detail) return error.detail.reason;\n        } catch  {}\n        return error;\n    }\n}\nexport { PromiseRejectionEventCoercer };\n","import Config from '../config'\nimport { isUndefined } from '@posthog/core'\nimport { assignableWindow, window } from './globals'\nimport type { Logger } from '@posthog/core'\n\ntype PosthogJsLogger = Omit<Logger, 'createLogger'> & {\n    _log: (level: 'log' | 'warn' | 'error', ...args: any[]) => void\n    uninitializedWarning: (methodName: string) => void\n    createLogger: (prefix: string) => PosthogJsLogger\n}\n\nconst _createLogger = (prefix: string): PosthogJsLogger => {\n    const logger: PosthogJsLogger = {\n        _log: (level: 'log' | 'warn' | 'error', ...args: any[]) => {\n            if (\n                window &&\n                (Config.DEBUG || assignableWindow.POSTHOG_DEBUG) &&\n                !isUndefined(window.console) &&\n                window.console\n            ) {\n                const consoleLog =\n                    '__rrweb_original__' in window.console[level]\n                        ? (window.console[level] as any)['__rrweb_original__']\n                        : window.console[level]\n\n                // eslint-disable-next-line no-console\n                consoleLog(prefix, ...args)\n            }\n        },\n\n        info: (...args: any[]) => {\n            logger._log('log', ...args)\n        },\n\n        warn: (...args: any[]) => {\n            logger._log('warn', ...args)\n        },\n\n        error: (...args: any[]) => {\n            logger._log('error', ...args)\n        },\n\n        critical: (...args: any[]) => {\n            // Critical errors are always logged to the console\n            // eslint-disable-next-line no-console\n            console.error(prefix, ...args)\n        },\n\n        uninitializedWarning: (methodName: string) => {\n            logger.error(`You must initialize PostHog before calling ${methodName}`)\n        },\n\n        createLogger: (additionalPrefix: string) => _createLogger(`${prefix} ${additionalPrefix}`),\n    }\n    return logger\n}\n\nexport const logger = _createLogger('[PostHog.js]')\n\nexport const createLogger = logger.createLogger\n","import { each, find } from './utils'\nimport Config from './config'\nimport { Compression, RequestWithOptions, RequestResponse } from './types'\nimport { formDataToQuery } from './utils/request-utils'\n\nimport { logger } from './utils/logger'\nimport { AbortController, fetch, navigator, XMLHttpRequest } from './utils/globals'\nimport { gzipSync, strToU8 } from 'fflate'\n\nimport { _base64Encode } from './utils/encode-utils'\n\n// eslint-disable-next-line compat/compat\nexport const SUPPORTS_REQUEST = !!XMLHttpRequest || !!fetch\n\nconst CONTENT_TYPE_PLAIN = 'text/plain'\nconst CONTENT_TYPE_JSON = 'application/json'\nconst CONTENT_TYPE_FORM = 'application/x-www-form-urlencoded'\nconst SIXTY_FOUR_KILOBYTES = 64 * 1024\n/*\n fetch will fail if we request keepalive with a body greater than 64kb\n sets the threshold lower than that so that\n any overhead doesn't push over the threshold after checking here\n*/\nconst KEEP_ALIVE_THRESHOLD = SIXTY_FOUR_KILOBYTES * 0.8\ntype EncodedBody = {\n    contentType: string\n    body: string | BlobPart\n    estimatedSize: number\n}\n\nexport const extendURLParams = (url: string, params: Record<string, any>): string => {\n    const [baseUrl, search] = url.split('?')\n    const newParams = { ...params }\n\n    search?.split('&').forEach((pair) => {\n        const [key] = pair.split('=')\n        delete newParams[key]\n    })\n\n    let newSearch = formDataToQuery(newParams)\n    newSearch = newSearch ? (search ? search + '&' : '') + newSearch : search\n\n    return `${baseUrl}?${newSearch}`\n}\n\nexport const jsonStringify = (data: any, space?: string | number): string => {\n    // With plain JSON.stringify, we get an exception when a property is a BigInt. This has caused problems for some users,\n    // see https://github.com/PostHog/posthog-js/issues/1440\n    // To work around this, we convert BigInts to strings before stringifying the data. This is not ideal, as we lose\n    // information that this was originally a number, but given ClickHouse doesn't support BigInts, the customer\n    // would not be able to operate on these numerically anyway.\n    return JSON.stringify(data, (_, value) => (typeof value === 'bigint' ? value.toString() : value), space)\n}\n\nconst encodeToDataString = (data: string | Record<string, any>): string => {\n    return 'data=' + encodeURIComponent(typeof data === 'string' ? data : jsonStringify(data))\n}\n\nconst encodePostData = ({ data, compression }: RequestWithOptions): EncodedBody | undefined => {\n    if (!data) {\n        return\n    }\n\n    if (compression === Compression.GZipJS) {\n        const gzipData = gzipSync(strToU8(jsonStringify(data)), { mtime: 0 })\n        const blob = new Blob([gzipData], { type: CONTENT_TYPE_PLAIN })\n        return {\n            contentType: CONTENT_TYPE_PLAIN,\n            body: blob,\n            estimatedSize: blob.size,\n        }\n    }\n\n    if (compression === Compression.Base64) {\n        const b64data = _base64Encode(jsonStringify(data))\n        const encodedBody = encodeToDataString(b64data)\n\n        return {\n            contentType: CONTENT_TYPE_FORM,\n            body: encodedBody,\n            estimatedSize: new Blob([encodedBody]).size,\n        }\n    }\n\n    const jsonBody = jsonStringify(data)\n    return {\n        contentType: CONTENT_TYPE_JSON,\n        body: jsonBody,\n        estimatedSize: new Blob([jsonBody]).size,\n    }\n}\n\nconst xhr = (options: RequestWithOptions) => {\n    const req = new XMLHttpRequest!()\n    req.open(options.method || 'GET', options.url, true)\n    const { contentType, body } = encodePostData(options) ?? {}\n\n    each(options.headers, function (headerValue, headerName) {\n        req.setRequestHeader(headerName, headerValue)\n    })\n\n    if (contentType) {\n        req.setRequestHeader('Content-Type', contentType)\n    }\n\n    if (options.timeout) {\n        req.timeout = options.timeout\n    }\n    if (!options.disableXHRCredentials) {\n        // send the ph_optout cookie\n        // withCredentials cannot be modified until after calling .open on Android and Mobile Safari\n        req.withCredentials = true\n    }\n    req.onreadystatechange = () => {\n        // XMLHttpRequest.DONE == 4, except in safari 4\n        if (req.readyState === 4) {\n            const response: RequestResponse = {\n                statusCode: req.status,\n                text: req.responseText,\n            }\n            if (req.status === 200) {\n                try {\n                    response.json = JSON.parse(req.responseText)\n                } catch {\n                    // logger.error(e)\n                }\n            }\n\n            options.callback?.(response)\n        }\n    }\n    req.send(body)\n}\n\nconst _fetch = (options: RequestWithOptions) => {\n    const { contentType, body, estimatedSize } = encodePostData(options) ?? {}\n\n    // eslint-disable-next-line compat/compat\n    const headers = new Headers()\n    each(options.headers, function (headerValue, headerName) {\n        headers.append(headerName, headerValue)\n    })\n\n    if (contentType) {\n        headers.append('Content-Type', contentType)\n    }\n\n    const url = options.url\n    let aborter: { signal: any; timeout: ReturnType<typeof setTimeout> } | null = null\n\n    if (AbortController) {\n        const controller = new AbortController()\n        aborter = {\n            signal: controller.signal,\n            timeout: setTimeout(() => controller.abort(), options.timeout),\n        }\n    }\n\n    fetch!(url, {\n        method: options?.method || 'GET',\n        headers,\n        // if body is greater than 64kb, then fetch with keepalive will error\n        // see 8:10:5 at https://fetch.spec.whatwg.org/#http-network-or-cache-fetch,\n        // but we do want to set keepalive sometimes as it can  help with success\n        // when e.g. a page is being closed\n        // so let's get the best of both worlds and only set keepalive for POST requests\n        // where the body is less than 64kb\n        // NB this is fetch keepalive and not http keepalive\n        keepalive: options.method === 'POST' && (estimatedSize || 0) < KEEP_ALIVE_THRESHOLD,\n        body,\n        signal: aborter?.signal,\n        ...options.fetchOptions,\n    })\n        .then((response) => {\n            return response.text().then((responseText) => {\n                const res: RequestResponse = {\n                    statusCode: response.status,\n                    text: responseText,\n                }\n\n                if (response.status === 200) {\n                    try {\n                        res.json = JSON.parse(responseText)\n                    } catch (e) {\n                        logger.error(e)\n                    }\n                }\n\n                options.callback?.(res)\n            })\n        })\n        .catch((error) => {\n            logger.error(error)\n            options.callback?.({ statusCode: 0, text: error })\n        })\n        .finally(() => (aborter ? clearTimeout(aborter.timeout) : null))\n\n    return\n}\n\nconst _sendBeacon = (options: RequestWithOptions) => {\n    // beacon documentation https://w3c.github.io/beacon/\n    // beacons format the message and use the type property\n\n    const url = extendURLParams(options.url, {\n        beacon: '1',\n    })\n\n    try {\n        const { contentType, body } = encodePostData(options) ?? {}\n        // sendBeacon requires a blob so we convert it\n        const sendBeaconBody = typeof body === 'string' ? new Blob([body], { type: contentType }) : body\n        navigator!.sendBeacon!(url, sendBeaconBody)\n    } catch {\n        // send beacon is a best-effort, fire-and-forget mechanism on page unload,\n        // we don't want to throw errors here\n    }\n}\n\nconst AVAILABLE_TRANSPORTS: {\n    transport: RequestWithOptions['transport']\n    method: (options: RequestWithOptions) => void\n}[] = []\n\n// We add the transports in order of preference\nif (fetch) {\n    AVAILABLE_TRANSPORTS.push({\n        transport: 'fetch',\n        method: _fetch,\n    })\n}\n\nif (XMLHttpRequest) {\n    AVAILABLE_TRANSPORTS.push({\n        transport: 'XHR',\n        method: xhr,\n    })\n}\n\nif (navigator?.sendBeacon) {\n    AVAILABLE_TRANSPORTS.push({\n        transport: 'sendBeacon',\n        method: _sendBeacon,\n    })\n}\n\n// This is the entrypoint. It takes care of sanitizing the options and then calls the appropriate request method.\nexport const request = (_options: RequestWithOptions) => {\n    // Clone the options so we don't modify the original object\n    const options = { ..._options }\n    options.timeout = options.timeout || 60000\n\n    options.url = extendURLParams(options.url, {\n        _: new Date().getTime().toString(),\n        ver: Config.LIB_VERSION,\n        compression: options.compression,\n    })\n\n    const transport = options.transport ?? 'fetch'\n\n    const availableTransports = AVAILABLE_TRANSPORTS.filter(\n        (t) => !options.disableTransport || !t.transport || !options.disableTransport.includes(t.transport)\n    )\n\n    const transportMethod =\n        find(availableTransports, (t) => t.transport === transport)?.method ?? availableTransports[0].method\n\n    if (!transportMethod) {\n        throw new Error('No available transport method')\n    }\n\n    transportMethod(options)\n}\n","import { assignableWindow, window } from '../utils/globals'\nimport { ErrorEventArgs } from '../types'\nimport { createLogger } from '../utils/logger'\nimport type { ErrorTracking } from '@posthog/core'\nimport { buildErrorPropertiesBuilder } from '../posthog-exceptions'\n\nconst logger = createLogger('[ExceptionAutocapture]')\nconst errorPropertiesBuilder = buildErrorPropertiesBuilder()\n\nfunction errorToProperties({ event, error }: { event: Event | string; error?: Error }) {\n    return errorPropertiesBuilder.buildFromUnknown(error || event, {\n        mechanism: {\n            handled: false,\n        },\n    })\n}\n\nconst wrapOnError = (captureFn: (props: ErrorTracking.ErrorProperties) => void) => {\n    const win = window as any\n    if (!win) {\n        logger.info('window not available, cannot wrap onerror')\n    }\n    const originalOnError = win.onerror\n\n    win.onerror = function (...args: ErrorEventArgs): boolean {\n        const errorProperties = errorToProperties({ event: args[0], error: args[4] })\n        captureFn(errorProperties)\n        return originalOnError?.(...args) ?? false\n    }\n    win.onerror.__POSTHOG_INSTRUMENTED__ = true\n\n    return () => {\n        delete win.onerror?.__POSTHOG_INSTRUMENTED__\n        win.onerror = originalOnError\n    }\n}\n\nconst wrapUnhandledRejection = (captureFn: (props: ErrorTracking.ErrorProperties) => void) => {\n    const win = window as any\n    if (!win) {\n        logger.info('window not available, cannot wrap onUnhandledRejection')\n    }\n\n    const originalOnUnhandledRejection = win.onunhandledrejection\n\n    win.onunhandledrejection = function (ev: PromiseRejectionEvent): boolean {\n        const errorProperties = errorToProperties({ event: ev })\n        captureFn(errorProperties)\n        return originalOnUnhandledRejection?.apply(win, [ev]) ?? false\n    }\n    win.onunhandledrejection.__POSTHOG_INSTRUMENTED__ = true\n\n    return () => {\n        delete win.onunhandledrejection?.__POSTHOG_INSTRUMENTED__\n        win.onunhandledrejection = originalOnUnhandledRejection\n    }\n}\n\nconst wrapConsoleError = (captureFn: (props: ErrorTracking.ErrorProperties) => void) => {\n    const con = console as any\n    if (!con) {\n        logger.info('console not available, cannot wrap console.error')\n    }\n\n    const originalConsoleError = con.error\n\n    con.error = function (...args: any[]): void {\n        const event = args.join(' ')\n        const error = args.find((arg) => arg instanceof Error)\n        const errorProperties = errorToProperties({ error, event })\n        captureFn(errorProperties)\n        return originalConsoleError?.(...args)\n    }\n    con.error.__POSTHOG_INSTRUMENTED__ = true\n\n    return () => {\n        delete con.error?.__POSTHOG_INSTRUMENTED__\n        con.error = originalConsoleError\n    }\n}\n\nconst posthogErrorWrappingFunctions = {\n    wrapOnError,\n    wrapUnhandledRejection,\n    wrapConsoleError,\n}\n\nassignableWindow.__PosthogExtensions__ = assignableWindow.__PosthogExtensions__ || {}\nassignableWindow.__PosthogExtensions__.errorWrappingFunctions = posthogErrorWrappingFunctions\n\n// we used to put these on window, and now we put them on __PosthogExtensions__\n// but that means that old clients which lazily load this extension are looking in the wrong place\n// yuck,\n// so we also put them directly on the window\n// when 1.161.1 is the oldest version seen in production we can remove this\nassignableWindow.posthogErrorWrappingFunctions = posthogErrorWrappingFunctions\n\nexport default posthogErrorWrappingFunctions\n","import { ErrorPropertiesBuilder } from '@posthog/core/dist/error-tracking'\nimport { ERROR_TRACKING_CAPTURE_EXTENSION_EXCEPTIONS, ERROR_TRACKING_SUPPRESSION_RULES } from './constants'\nimport { PostHog } from './posthog-core'\nimport { CaptureResult, ErrorTrackingSuppressionRule, Properties, RemoteConfig } from './types'\nimport { createLogger } from './utils/logger'\nimport { propertyComparisons } from './utils/property-utils'\nimport { isString, isArray, ErrorTracking } from '@posthog/core'\n\nconst logger = createLogger('[Error tracking]')\n\nexport function buildErrorPropertiesBuilder() {\n    return new ErrorTracking.ErrorPropertiesBuilder(\n        [\n            new ErrorTracking.DOMExceptionCoercer(),\n            new ErrorTracking.PromiseRejectionEventCoercer(),\n            new ErrorTracking.ErrorEventCoercer(),\n            new ErrorTracking.ErrorCoercer(),\n            new ErrorTracking.EventCoercer(),\n            new ErrorTracking.ObjectCoercer(),\n            new ErrorTracking.StringCoercer(),\n            new ErrorTracking.PrimitiveCoercer(),\n        ],\n        [ErrorTracking.chromeStackLineParser, ErrorTracking.geckoStackLineParser]\n    )\n}\nexport class PostHogExceptions {\n    private readonly _instance: PostHog\n    private _suppressionRules: ErrorTrackingSuppressionRule[] = []\n    private _errorPropertiesBuilder: ErrorPropertiesBuilder = buildErrorPropertiesBuilder()\n\n    constructor(instance: PostHog) {\n        this._instance = instance\n        this._suppressionRules = this._instance.persistence?.get_property(ERROR_TRACKING_SUPPRESSION_RULES) ?? []\n    }\n\n    onRemoteConfig(response: RemoteConfig) {\n        const suppressionRules = response.errorTracking?.suppressionRules ?? []\n        const captureExtensionExceptions = response.errorTracking?.captureExtensionExceptions\n\n        // store this in-memory in case persistence is disabled\n        this._suppressionRules = suppressionRules\n\n        if (this._instance.persistence) {\n            this._instance.persistence.register({\n                [ERROR_TRACKING_SUPPRESSION_RULES]: this._suppressionRules,\n                [ERROR_TRACKING_CAPTURE_EXTENSION_EXCEPTIONS]: captureExtensionExceptions,\n            })\n        }\n    }\n\n    private get _captureExtensionExceptions() {\n        const enabled_server_side = !!this._instance.get_property(ERROR_TRACKING_CAPTURE_EXTENSION_EXCEPTIONS)\n        const enabled_client_side = this._instance.config.error_tracking.captureExtensionExceptions\n        return enabled_client_side ?? enabled_server_side ?? false\n    }\n\n    buildProperties(\n        input: unknown,\n        metadata?: { handled?: boolean; syntheticException?: Error }\n    ): ErrorTracking.ErrorProperties {\n        return this._errorPropertiesBuilder.buildFromUnknown(input, {\n            syntheticException: metadata?.syntheticException,\n            mechanism: {\n                handled: metadata?.handled,\n            },\n        })\n    }\n\n    sendExceptionEvent(properties: Properties): CaptureResult | undefined {\n        if (this._matchesSuppressionRule(properties)) {\n            logger.info('Skipping exception capture because a suppression rule matched')\n            return\n        }\n\n        if (!this._captureExtensionExceptions && this._isExtensionException(properties)) {\n            logger.info('Skipping exception capture because it was thrown by an extension')\n            return\n        }\n\n        return this._instance.capture('$exception', properties, {\n            _noTruncate: true,\n            _batchKey: 'exceptionEvent',\n        })\n    }\n\n    private _matchesSuppressionRule(properties: Properties): boolean {\n        const exceptionList = properties.$exception_list\n\n        if (!exceptionList || !isArray(exceptionList) || exceptionList.length === 0) {\n            return false\n        }\n\n        const exceptionValues = exceptionList.reduce(\n            (acc, { type, value }) => {\n                if (isString(type) && type.length > 0) {\n                    acc['$exception_types'].push(type)\n                }\n                if (isString(value) && value.length > 0) {\n                    acc['$exception_values'].push(value)\n                }\n                return acc\n            },\n            {\n                $exception_types: [],\n                $exception_values: [],\n            }\n        )\n\n        return this._suppressionRules.some((rule) => {\n            const results = rule.values.map((v) => {\n                const compare = propertyComparisons[v.operator]\n                const targets = isArray(v.value) ? v.value : [v.value]\n                const values = exceptionValues[v.key] ?? []\n                return targets.length > 0 ? compare(targets, values) : false\n            })\n            return rule.type === 'OR' ? results.some(Boolean) : results.every(Boolean)\n        })\n    }\n\n    private _isExtensionException(properties: Properties): boolean {\n        const exceptionList = properties.$exception_list\n\n        if (!exceptionList || !isArray(exceptionList)) {\n            return false\n        }\n\n        const frames = (exceptionList as ErrorTracking.Exception[]).flatMap((e) => e.stacktrace?.frames ?? [])\n        return frames.some((f) => f.filename && f.filename.startsWith('chrome-extension://'))\n    }\n}\n"],"names":["win","window","undefined","global","globalThis","navigator","document","location","fetch","XMLHttpRequest","AbortController","userAgent","assignableWindow","nativeIsArray","Array","isArray","type_utils_toString","Object","prototype","toString","obj","call","isUndefined","x","isString","isPrimitive","value","isBuiltin","candidate","className","isEvent","Event","base","_unused","isInstanceOf","parsedStackResults","lastKeysCount","cachedFilenameChunkIds","getFilenameToChunkIdMap","stackParser","chunkIdMap","_posthogChunkIds","chunkIdKeys","keys","length","reduce","acc","stackKey","result","parsedStack","i","stackFrame","filename","chunkId","UNKNOWN_FUNCTION","createFrame","func","lineno","colno","frame","platform","function","in_app","extractSafariExtensionDetails","isSafariExtension","indexOf","isSafariWebExtension","split","chromeRegexNoFnName","chromeRegex","chromeEvalRegex","chromeStackLineParser","line","noFnParts","exec","col","parts","subMatch","geckoREgex","geckoEvalRegex","geckoStackLineParser","WEBPACK_ERROR_REGEXP","STACKTRACE_FRAME_LIMIT","createStackParser","_len","arguments","parsers","_key","stack","skipFirstLines","frames","lines","cleanedLine","test","replace","match","parser","push","localStack","from","reverse","slice","map","_extends","arr","reverseAndStripFrames","ErrorPropertiesBuilder","constructor","coercers","modifiers","this","buildFromUnknown","input","hint","mechanism","handled","type","exceptionWithCause","buildCoercingContext","apply","parsingContext","buildParsingContext","exceptionWithStack","parseStacktrace","$exception_list","convertToExceptionList","$exception_level","modifyFrames","exceptionList","_this","_asyncToGenerator","exc","stacktrace","applyModifiers","coerceFallback","ctx","_ctx$syntheticExcepti","syntheticException","synthetic","err","cause","applyChunkIds","chunk_id","applyCoercers","adapter","coerce","_this2","newFrames","modifier","_mechanism$type","_mechanism$handled","_exceptionWithStack$s","currentException","depth","next","DOMExceptionCoercer","isDOMException","isDOMError","hasStack","getType","getValue","name","message","ErrorCoercer","Error","getMessage","getStack","_ctx","error","String","ErrorEventCoercer","exceptionLike","ERROR_TYPES_PATTERN","StringCoercer","getInfos","groups","severityLevels","extractExceptionKeysForMessage","maxLength","sort","serialized","join","ObjectCoercer","errorProperty","getErrorPropertyFromObject","level","isSeverityLevel","getObjectClassName","trim","isEmptyString","prop","hasOwnProperty","getPrototypeOf","e","EventCoercer","evt","constructorName","PrimitiveCoercer","PromiseRejectionEventCoercer","reason","getUnhandledRejectionReason","detail","_createLogger","prefix","logger","_log","console","consoleLog","args","info","_len2","_key2","warn","_len3","_key3","_len4","_key4","critical","_len5","_key5","uninitializedWarning","methodName","createLogger","additionalPrefix","sendBeacon","errorPropertiesBuilder","ErrorTracking","errorToProperties","_ref","event","posthogErrorWrappingFunctions","wrapOnError","captureFn","originalOnError","onerror","_originalOnError","errorProperties","__POSTHOG_INSTRUMENTED__","_win$onerror","wrapUnhandledRejection","originalOnUnhandledRejection","onunhandledrejection","ev","_originalOnUnhandledR","_win$onunhandledrejec","wrapConsoleError","con","originalConsoleError","find","arg","_con$error","__PosthogExtensions__","errorWrappingFunctions"],"mappings":"yBA2BA,IAAMA,EAAkE,oBAAXC,OAAyBA,YAASC,EAmMzFC,EAA8D,oBAAfC,WAA6BA,WAAaJ,EAMlFK,EAAkB,MAANF,OAAM,EAANA,EAAQE,UACH,MAANF,GAAAA,EAAQG,SACF,MAANH,GAAAA,EAAQI,SACL,MAANJ,GAAAA,EAAQK,YAEzBL,GAAAA,EAAQM,gBAAkB,oBAAqB,IAAIN,EAAOM,gBAAmBN,EAAOM,eACnD,MAANN,GAAAA,EAAQO,gBACL,MAATL,GAAAA,EAAWM,UAC7B,IAAMC,EAAqCZ,QAAAA,EAAQ,CAAA,shBC1O1D,IAAMa,EAAgBC,MAAMC,QAGtBC,EAFWC,OAAOC,UAEaC,SAC/BJ,EAAUF,GAAiB,SAASO,GACtC,MAAO,mBAAqBJ,EAAoBK,KAAKD,EACzD,EAWME,EAAeC,QAAI,IAAWA,EAC9BC,EAAYD,GAAI,mBAAqBP,EAAoBK,KAAKE,GAiBpE,SAASE,EAAYC,GACjB,OAAO,OAASA,GAAS,iBAAmBA,CAChD,CACA,SAASC,EAAUC,EAAWC,GAC1B,OAAOZ,OAAOC,UAAUC,SAASE,KAAKO,KAAU,WAAgBC,EAAS,GAC7E,CAgBA,SAASC,EAAQF,GACb,OAAQN,EAAYS,QA7BxB,SAAsBH,EAAWI,GAC7B,IACI,OAAOJ,aAAqBI,CAChC,CAAE,MAAAC,GACE,OAAO,CACX,CACJ,CAuBkCC,CAAaN,EAAWG,MAC1D,CClBA,IC1CII,EACAC,EACAC,EACJ,SAASC,EAAwBC,GAC7B,IAAMC,EAAapC,WAAWqC,iBAC9B,GAAKD,EAAL,CACA,IAAME,EAAczB,OAAO0B,KAAKH,GAChC,OAAIH,GAA0BK,EAAYE,SAAWR,EAAsBC,GAC3ED,EAAgBM,EAAYE,OAC5BP,EAAyBK,EAAYG,QAAO,CAACC,EAAKC,KACzCZ,IAAoBA,EAAqB,CAAA,GAC9C,IAAMa,EAASb,EAAmBY,GAClC,GAAIC,EAAQF,EAAIE,EAAO,IAAMA,EAAO,QAGhC,IADA,IAAMC,EAAcV,EAAYQ,GACxBG,EAAID,EAAYL,OAAS,EAAGM,GAAK,EAAGA,IAAI,CAC5C,IAAMC,EAAaF,EAAYC,GACzBE,EAAqB,MAAVD,OAAU,EAAVA,EAAYC,SACvBC,EAAUb,EAAWO,GAC3B,GAAIK,GAAYC,EAAS,CACrBP,EAAIM,GAAYC,EAChBlB,EAAmBY,GAAY,CAC3BK,EACAC,GAEJ,KACJ,CACJ,CAEJ,OAAOP,CAAG,GACX,CAAA,GAzBc,CA2BrB,CC/BA,IAAMQ,EAAmB,IACzB,SAASC,EAAYH,EAAUI,EAAMC,EAAQC,GACzC,IAAMC,EAAQ,CACVC,SAAU,iBACVR,WACAS,SAAU,gBAAkBL,EAAOF,EAAmBE,EACtDM,QAAQ,GAIZ,OAFKxC,EAAYmC,KAASE,EAAMF,OAASA,GACpCnC,EAAYoC,KAAQC,EAAMD,MAAQA,GAChCC,CACX,CCXA,IAAMI,EAAgCA,CAACP,EAAMJ,KACzC,IAAMY,GAAoB,IAAOR,EAAKS,QAAQ,oBACxCC,GAAuB,IAAOV,EAAKS,QAAQ,wBACjD,OAAOD,GAAqBE,EAAuB,MACxCV,EAAKS,QAAQ,KAAOT,EAAKW,MAAM,KAAK,GAAKb,EAChDU,EAAiB,oBAAuBZ,EAAQ,wBAA6BA,GAC7E,CACAI,EACAJ,EACH,ECRCgB,EAAsB,yCACtBC,EAAc,6IACdC,EAAkB,gCAClBC,EAAyBC,IAC3B,IAAMC,EAAYL,EAAoBM,KAAKF,GAC3C,GAAIC,EAAW,CACX,KAASrB,EAAUoB,EAAMG,GAAOF,EAChC,OAAOlB,EAAYH,EAAUE,GAAmBkB,GAAOG,EAC3D,CACA,IAAMC,EAAQP,EAAYK,KAAKF,GAC/B,GAAII,EAAO,CAEP,GADeA,EAAM,IAAM,IAAMA,EAAM,GAAGX,QAAQ,QACtC,CACR,IAAMY,EAAWP,EAAgBI,KAAKE,EAAM,IACxCC,IACAD,EAAM,GAAKC,EAAS,GACpBD,EAAM,GAAKC,EAAS,GACpBD,EAAM,GAAKC,EAAS,GAE5B,CACA,IAAOrB,EAAMJ,GAAYW,EAA8Ba,EAAM,IAAMtB,EAAkBsB,EAAM,IAC3F,OAAOrB,EAAYH,EAAUI,EAAMoB,EAAM,IAAMA,EAAM,QAAK,EAAQA,EAAM,IAAMA,EAAM,QAAK,EAC7F,GCtBEE,EAAa,uIACbC,EAAiB,gDACjBC,EAAwBR,IAC1B,IAAMI,EAAQE,EAAWJ,KAAKF,GAC9B,GAAII,EAAO,CAEP,GADeA,EAAM,IAAMA,EAAM,GAAGX,QAAQ,YAAa,EAC7C,CACR,IAAMY,EAAWE,EAAeL,KAAKE,EAAM,IACvCC,IACAD,EAAM,GAAKA,EAAM,IAAM,OACvBA,EAAM,GAAKC,EAAS,GACpBD,EAAM,GAAKC,EAAS,GACpBD,EAAM,GAAK,GAEnB,CACA,IAAIxB,EAAWwB,EAAM,GACjBpB,EAAOoB,EAAM,IAAMtB,EAEvB,OADCE,EAAMJ,GAAYW,EAA8BP,EAAMJ,GAChDG,EAAYH,EAAUI,EAAMoB,EAAM,IAAMA,EAAM,QAAK,EAAQA,EAAM,IAAMA,EAAM,QAAK,EAC7F,GCfEK,EAAuB,kBACvBC,EAAyB,GAc/B,SAASC,IAA8B,IAAA,IAAAC,EAAAC,UAAAzC,OAAT0C,EAAO,IAAAxE,MAAAsE,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAPD,EAAOC,GAAAF,UAAAE,GACjC,OAAO,SAACC,EAAOC,QAAc,IAAdA,IAAAA,EAAiB,GAG5B,IAFA,IAAMC,EAAS,GACTC,EAAQH,EAAMrB,MAAM,MAClBjB,EAAIuC,EAAgBvC,EAAIyC,EAAM/C,OAAQM,IAAI,CAC9C,IAAMsB,EAAOmB,EAAMzC,GACnB,KAAIsB,EAAK5B,OAAS,MAAlB,CACA,IAAMgD,EAAcX,EAAqBY,KAAKrB,GAAQA,EAAKsB,QAAQb,EAAsB,MAAQT,EACjG,IAAKoB,EAAYG,MAAM,cAAe,CAClC,IAAK,IAAMC,KAAUV,EAAQ,CACzB,IAAM3B,EAAQqC,EAAOJ,GACrB,GAAIjC,EAAO,CACP+B,EAAOO,KAAKtC,GACZ,KACJ,CACJ,CACA,GAAI+B,EAAO9C,QAAUsC,EAAwB,KACjD,CAXwB,CAY5B,CACA,OAhCR,SAA+BM,GAC3B,IAAKA,EAAM5C,OAAQ,MAAO,GAC1B,IAAMsD,EAAapF,MAAMqF,KAAKX,GAE9B,OADAU,EAAWE,UACJF,EAAWG,MAAM,EAAGnB,GAAwBoB,KAAK3C,IAAK4C,YAClD5C,EAAK,CACRP,SAAUO,EAAMP,WAIDoD,EAJ+BN,EAK/CM,EAAIA,EAAI5D,OAAS,IAAM,CAAA,GALoCQ,SAC1DS,SAAUF,EAAME,UAAYP,IAGxC,IAA2BkD,CAFjB,GACV,CAuBeC,CAAsBf,EACjC,CACJ,CCtCA,MAAMgB,EACFC,WAAAA,CAAYC,EAAetB,EAAcuB,QAArB,IAARD,IAAAA,EAAW,SAAW,IAAPtB,IAAAA,EAAU,SAAa,IAATuB,IAAAA,EAAY,IACjDC,KAAKF,SAAWA,EAChBE,KAAKD,UAAYA,EACjBC,KAAKvE,YAAc4C,KAAqBG,EAC5C,CACAyB,gBAAAA,CAAiBC,EAAOC,QAAI,IAAJA,IAAAA,EAAO,CAAA,GAC3B,IACMC,EADoBD,GAAQA,EAAKC,WACA,CACnCC,SAAS,EACTC,KAAM,WAGJC,EADkBP,KAAKQ,qBAAqBJ,EAAWD,EAAM,GACxBM,MAAMP,GAC3CQ,EAAiBV,KAAKW,sBACtBC,EAAqBZ,KAAKa,gBAAgBN,EAAoBG,GAEpE,MAAO,CACHI,gBAFkBd,KAAKe,uBAAuBH,EAAoBR,GAGlEY,iBAAkB,QAE1B,CACMC,YAAAA,CAAaC,GAAe,IAAAC,EAAAnB,KAAA,OAAAoB,GAAA,YAC9B,IAAK,IAAMC,KAAOH,EAAkBG,EAAIC,YAAcD,EAAIC,WAAW1C,QAAU3E,EAAQoH,EAAIC,WAAW1C,UAASyC,EAAIC,WAAW1C,aAAeuC,EAAKI,eAAeF,EAAIC,WAAW1C,SAChL,OAAOsC,CAAc,GAFSE,EAGlC,CACAI,cAAAA,CAAeC,GAAK,IAAAC,EAChB,MAAO,CACHpB,KAAM,QACN1F,MAAO,gBACP8D,MAA6B,OAAxBgD,EAAED,EAAIE,yBAAkB,EAAtBD,EAAwBhD,MAC/BkD,WAAW,EAEnB,CACAf,eAAAA,CAAgBgB,EAAKJ,GACjB,IAAIK,EAEApD,EAEJ,OAHI,MAAQmD,EAAIC,QAAOA,EAAQ9B,KAAKa,gBAAgBgB,EAAIC,MAAOL,IAE3D,IAAMI,EAAInD,OAAS,MAAQmD,EAAInD,QAAOA,EAAQsB,KAAK+B,cAAc/B,KAAKvE,YAAYoG,EAAInD,MAAOmD,EAAID,UAAY,EAAI,GAAIH,EAAI/F,aAC7H+D,KACOoC,EAAG,CACNC,QACApD,SAER,CACAqD,aAAAA,CAAcnD,EAAQlD,GAClB,OAAOkD,EAAOY,KAAK3C,IACXA,EAAMP,UAAYZ,IAAYmB,EAAMmF,SAAWtG,EAAWmB,EAAMP,WAC7DO,IAEf,CACAoF,aAAAA,CAAc/B,EAAOuB,GACjB,IAAK,IAAMS,KAAWlC,KAAKF,SAAS,GAAIoC,EAAQjD,MAAMiB,GAAQ,OAAOgC,EAAQC,OAAOjC,EAAOuB,GAC3F,OAAOzB,KAAKwB,eAAeC,EAC/B,CACMF,cAAAA,CAAe3C,GAAQ,IAAAwD,EAAApC,KAAA,OAAAoB,GAAA,YACzB,IAAIiB,EAAYzD,EAChB,IAAK,IAAM0D,KAAYF,EAAKrC,UAAUsC,QAAkBC,EAASD,GACjE,OAAOA,CAAU,GAHQjB,EAI7B,CACAL,sBAAAA,CAAuBH,EAAoBR,GAAW,IAAAmC,EAAAC,EAAAC,EAC5CC,EAAmB,CACrBpC,KAAMM,EAAmBN,KACzB1F,MAAOgG,EAAmBhG,MAC1BwF,UAAW,CACPE,KAAoB,QAAhBiC,EAAEnC,EAAUE,YAAI,IAAAiC,EAAAA,EAAI,UACxBlC,QAA0B,QAAnBmC,EAAEpC,EAAUC,eAAO,IAAAmC,GAAAA,EAC1BZ,UAAuC,QAA9Ba,EAAE7B,EAAmBgB,iBAAS,IAAAa,GAAAA,IAG3C7B,EAAmBlC,QAAOgE,EAAiBpB,WAAa,CACxDhB,KAAM,MACN1B,OAAQgC,EAAmBlC,QAE/B,IAAMwC,EAAgB,CAClBwB,GAMJ,OAJI,MAAQ9B,EAAmBkB,OAAOZ,EAAc/B,QAAQa,KAAKe,uBAAuBH,EAAmBkB,MAAKrC,EAAA,CAAA,EACzGW,EAAS,CACZC,SAAS,MAENa,CACX,CACAP,mBAAAA,GAII,MAHgB,CACZjF,WAAYF,EAAwBwE,KAAKvE,aAGjD,CACA+E,oBAAAA,CAAqBJ,EAAWD,EAAMwC,QAAK,IAALA,IAAAA,EAAQ,GAC1C,IAAMR,EAASA,CAACjC,EAAOyC,KACnB,GAAMA,GA5FU,EA4FhB,CAEI,IAAMlB,EAAMzB,KAAKQ,qBAAqBJ,EAAWD,EAAMwC,GACvD,OAAO3C,KAAKiC,cAAc/B,EAAOuB,EAHA,CAIrC,EASJ,OAPahC,EAAA,CAAA,EACNU,EAAI,CACPwB,mBAAoB,GAAKgB,EAAQxC,EAAKwB,wBAAqB,EAC3DvB,YACAK,MAAQP,GAAQiC,EAAOjC,EAAOyC,GAC9BC,KAAO1C,GAAQiC,EAAOjC,EAAOyC,EAAQ,IAG7C,EC5GJ,MAAME,EACF5D,KAAAA,CAAM4C,GACF,OAAO7B,KAAK8C,eAAejB,IAAQ7B,KAAK+C,WAAWlB,EACvD,CACAM,MAAAA,CAAON,EAAKJ,GACR,IAAMuB,EAAWtI,EAASmH,EAAInD,OAC9B,MAAO,CACH4B,KAAMN,KAAKiD,QAAQpB,GACnBjH,MAAOoF,KAAKkD,SAASrB,GACrBnD,MAAOsE,EAAWnB,EAAInD,WAAQ,EAC9BoD,MAAOD,EAAIC,MAAQL,EAAImB,KAAKf,EAAIC,YAAS,EACzCF,WAAW,EAEnB,CACAqB,OAAAA,CAAQnI,GACJ,OAAOkF,KAAK+C,WAAWjI,GAAa,WAAa,cACrD,CACAoI,QAAAA,CAASrB,GACL,IAAMsB,EAAOtB,EAAIsB,OAASnD,KAAK+C,WAAWlB,GAAO,WAAa,gBAE9D,OADgBA,EAAIuB,QAAaD,EAAI,KAAKtB,EAAIuB,QAAYD,CAE9D,CACAL,cAAAA,CAAejB,GACX,OAAOhH,EAAUgH,EAAK,eAC1B,CACAkB,UAAAA,CAAWlB,GACP,OAAOhH,EAAUgH,EAAK,WAC1B,EC3BJ,MAAMwB,EACFpE,KAAAA,CAAM4C,GACF,OAAoBA,aVyBWyB,KUxBnC,CACAnB,MAAAA,CAAON,EAAKJ,GACR,MAAO,CACHnB,KAAMN,KAAKiD,QAAQpB,GACnBjH,MAAOoF,KAAKuD,WAAW1B,EAAKJ,GAC5B/C,MAAOsB,KAAKwD,SAAS3B,GACrBC,MAAOD,EAAIC,MAAQL,EAAImB,KAAKf,EAAIC,YAAS,EACzCF,WAAW,EAEnB,CACAqB,OAAAA,CAAQpB,GACJ,OAAOA,EAAIsB,MAAQtB,EAAIhC,YAAYsD,IACvC,CACAI,UAAAA,CAAW1B,EAAK4B,GACZ,IAAML,EAAUvB,EAAIuB,QACpB,OAAIA,EAAQM,OAAS,iBAAmBN,EAAQM,MAAMN,QAAgBO,OAAOP,EAAQM,MAAMN,SACpFO,OAAOP,EAClB,CACAI,QAAAA,CAAS3B,GACL,OAAOA,EAAIP,YAAcO,EAAInD,YAAS,CAC1C,ECvBJ,MAAMkF,EACF/D,WAAAA,GAAc,CACdZ,KAAAA,CAAM4C,GACF,OXoDGhH,EWpDiBgH,EXoDA,eWpDQ,MAAUA,EAAI6B,KAC9C,CACAvB,MAAAA,CAAON,EAAKJ,GAAK,IAAAC,EACPmC,EAAgBpC,EAAIhB,MAAMoB,EAAI6B,OACpC,OAAKG,GAAsB,CACvBvD,KAAM,aACN1F,MAAOiH,EAAIuB,QACX1E,MAA6B,OAAxBgD,EAAED,EAAIE,yBAAkB,EAAtBD,EAAwBhD,MAC/BkD,WAAW,EAGnB,ECfJ,IAAMkC,EAAsB,2GAC5B,MAAMC,EACF9E,KAAAA,CAAMiB,GACF,MAAO,iBAAmBA,CAC9B,CACAiC,MAAAA,CAAOjC,EAAOuB,GAAK,IAAAC,GACRpB,EAAM1F,GAASoF,KAAKgE,SAAS9D,GACpC,MAAO,CACHI,KAAMA,QAAAA,EAAQ,QACd1F,MAAOA,QAAAA,EAASsF,EAChBxB,MAA6B,OAAxBgD,EAAED,EAAIE,yBAAkB,EAAtBD,EAAwBhD,MAC/BkD,WAAW,EAEnB,CACAoC,QAAAA,CAASlJ,GACL,IAAIwF,EAAO,QACP1F,EAAQE,EACNmJ,EAASnJ,EAAUmE,MAAM6E,GAK/B,OAJIG,IACA3D,EAAO2D,EAAO,GACdrJ,EAAQqJ,EAAO,IAEZ,CACH3D,EACA1F,EAER,EC1BJ,IAAMsJ,EAAiB,CACnB,QACA,QACA,UACA,MACA,OACA,SCFJ,SAASC,EAA+BtC,EAAKuC,QAAS,IAATA,IAAAA,EAAY,IACrD,IAAMvI,EAAO1B,OAAO0B,KAAKgG,GAEzB,GADAhG,EAAKwI,QACAxI,EAAKC,OAAQ,MAAO,uBACzB,IAAI,IAAIM,EAAIP,EAAKC,OAAQM,EAAI,EAAGA,IAAI,CAChC,IAAMkI,EAAazI,EAAK0D,MAAM,EAAGnD,GAAGmI,KAAK,MACzC,KAAMD,EAAWxI,OAASsI,GACtB,OAAIhI,IAAMP,EAAKC,QACRwI,EAAWxI,QAAUsI,EADEE,EAC0BA,EAAW/E,MAAM,EAAG6E,GAAU,KAE9F,CACA,MAAO,EACX,CCbA,MAAMI,EACFvF,KAAAA,CAAMnE,GACF,MAAO,iBAAmBA,GAAa,OAASA,CACpD,CACAqH,MAAAA,CAAOrH,EAAW2G,GAAK,IAAAC,EACb+C,EAAgBzE,KAAK0E,2BAA2B5J,GACtD,OAAI2J,EAAsBhD,EAAIhB,MAAMgE,GAC7B,CACHnE,KAAMN,KAAKiD,QAAQnI,GACnBF,MAAOoF,KAAKkD,SAASpI,GACrB4D,MAA6B,OAAxBgD,EAAED,EAAIE,yBAAkB,EAAtBD,EAAwBhD,MAC/BiG,MAAO3E,KAAK4E,gBAAgB9J,EAAU6J,OAAS7J,EAAU6J,MAAQ,QACjE/C,WAAW,EAEnB,CACAqB,OAAAA,CAAQpB,GACJ,OAAO7G,EAAQ6G,GAAOA,EAAIhC,YAAYsD,KAAO,OACjD,CACAD,QAAAA,CAASrB,GACL,GAAI,SAAUA,GAAO,iBAAmBA,EAAIsB,KAAM,CAC9C,IAAIC,EAAO,IAAOvB,EAAIsB,KAAI,0BAE1B,MADI,YAAatB,GAAO,iBAAmBA,EAAIuB,UAASA,GAAO,mBAAuBvB,EAAIuB,QAAO,KAC1FA,CACX,CACA,GAAI,YAAavB,GAAO,iBAAmBA,EAAIuB,QAAS,OAAOvB,EAAIuB,QACnE,IAAMrI,EAAYiF,KAAK6E,mBAAmBhD,GAE1C,OAAU9G,GAAa,WAAaA,MAAgBA,EAAS,IAAM,UAAQ,qCAD9DoJ,EAA+BtC,EAEhD,CACA+C,eAAAA,CAAgBnK,GACZ,OAAOC,EAASD,KfZDA,IAAIC,EAASD,IAAM,IAAMA,EAAEqK,OAAOhJ,OeY1BiJ,CAActK,IAAMyJ,EAAe/G,QAAQ1C,IAAM,CAC5E,CACAiK,0BAAAA,CAA2BpK,GACvB,IAAI,IAAM0K,KAAQ1K,EAAI,GAAIH,OAAOC,UAAU6K,eAAe1K,KAAKD,EAAK0K,GAAO,CACvE,IAAMpK,EAAQN,EAAI0K,GAClB,GAAYpK,adIU0I,McJF,OAAO1I,CAC/B,CACJ,CACAiK,kBAAAA,CAAmBvK,GACf,IACI,IAAMF,EAAYD,OAAO+K,eAAe5K,GACxC,OAAOF,EAAYA,EAAUyF,YAAYsD,UAAO,CACpD,CAAE,MAAOgC,GACL,MACJ,CACJ,EC9CJ,MAAMC,EACFnG,KAAAA,CAAM4C,GACF,OAAO7G,EAAQ6G,EACnB,CACAM,MAAAA,CAAOkD,EAAK5D,GAAK,IAAAC,EACP4D,EAAkBD,EAAIxF,YAAYsD,KACxC,MAAO,CACH7C,KAAMgF,EACN1K,MAAU0K,EAAe,qCAAqCnB,EAA+BkB,GAC7F3G,MAA6B,OAAxBgD,EAAED,EAAIE,yBAAkB,EAAtBD,EAAwBhD,MAC/BkD,WAAW,EAEnB,ECbJ,MAAM2D,EACFtG,KAAAA,CAAMnE,GACF,OAAOH,EAAYG,EACvB,CACAqH,MAAAA,CAAOvH,EAAO6G,GAAK,IAAAC,EACf,MAAO,CACHpB,KAAM,QACN1F,MAAK,0CAA4C+I,OAAO/I,GACxD8D,MAA6B,OAAxBgD,EAAED,EAAIE,yBAAkB,EAAtBD,EAAwBhD,MAC/BkD,WAAW,EAEnB,ECXJ,MAAM4D,EACFvG,KAAAA,CAAM4C,GACF,OAAOhH,EAAUgH,EAAK,wBAC1B,CACAM,MAAAA,CAAON,EAAKJ,GAAK,IAAAC,EACP+D,EAASzF,KAAK0F,4BAA4B7D,GAChD,OAAIlH,EAAY8K,GAAgB,CAC5BnF,KAAM,qBACN1F,MAAK,oDAAsD+I,OAAO8B,GAClE/G,MAA6B,OAAxBgD,EAAED,EAAIE,yBAAkB,EAAtBD,EAAwBhD,MAC/BkD,WAAW,GAERH,EAAIhB,MAAMgF,EACrB,CACAC,2BAAAA,CAA4BhC,GACxB,GAAI/I,EAAY+I,GAAQ,OAAOA,EAC/B,IACI,GAAI,WAAYA,EAAO,OAAOA,EAAM+B,OACpC,GAAI,WAAY/B,GAAS,WAAYA,EAAMiC,OAAQ,OAAOjC,EAAMiC,OAAOF,MAC3E,CAAE,MAAAtK,GAAQ,CACV,OAAOuI,CACX,ECXJ,IAAMkC,EAAiBC,IACnB,IAAMC,EAA0B,CAC5BC,EAAM,SAACpB,GACH,GACIxL,GACiBW,EAA8B,gBAC9CU,EAAYrB,EAAO6M,UACpB7M,EAAO6M,QACT,CAME,IALA,IAAMC,GACF,uBAAwB9M,EAAO6M,QAAQrB,GAChCxL,EAAO6M,QAAQrB,GAAmC,mBACnDxL,EAAO6M,QAAQrB,IAEzBrG,EAAAC,UAAAzC,OAZmCoK,MAAIlM,MAAAsE,EAAA,EAAAA,OAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAJyH,EAAIzH,EAAA,GAAAF,UAAAE,GAavCwH,EAAWJ,KAAWK,EAC1B,CACJ,EAEAC,KAAM,WAAoB,IAAA,IAAAC,EAAA7H,UAAAzC,OAAhBoK,EAAI,IAAAlM,MAAAoM,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAJH,EAAIG,GAAA9H,UAAA8H,GACVP,EAAOC,EAAK,SAAUG,EAC1B,EAEAI,KAAM,WAAoB,IAAA,IAAAC,EAAAhI,UAAAzC,OAAhBoK,EAAI,IAAAlM,MAAAuM,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAJN,EAAIM,GAAAjI,UAAAiI,GACVV,EAAOC,EAAK,UAAWG,EAC3B,EAEAxC,MAAO,WAAoB,IAAA,IAAA+C,EAAAlI,UAAAzC,OAAhBoK,EAAI,IAAAlM,MAAAyM,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAJR,EAAIQ,GAAAnI,UAAAmI,GACXZ,EAAOC,EAAK,WAAYG,EAC5B,EAEAS,SAAU,WAAoB,IAAA,IAAAC,EAAArI,UAAAzC,OAAhBoK,EAAI,IAAAlM,MAAA4M,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAJX,EAAIW,GAAAtI,UAAAsI,GAGdb,QAAQtC,MAAMmC,KAAWK,EAC7B,EAEAY,qBAAuBC,IACnBjB,EAAOpC,MAAK,8CAA+CqD,EAAa,EAG5EC,aAAeC,GAA6BrB,EAAiBC,MAAUoB,IAE3E,OAAOnB,CAAM,EAKJkB,EAFSpB,EAAc,gBAEDoB,aCoLtB,MAATzN,GAAAA,EAAW2N,WCzOf,IAAMpB,EAASkB,EAAa,0BACtBG,ECIK,IAAIC,EACP,CACI,IAAIA,EACJ,IAAIA,EACJ,IAAIA,EACJ,IAAIA,EACJ,IAAIA,EACJ,IAAIA,EACJ,IAAIA,EACJ,IAAIA,GAER,CAACA,EAAqCA,IDb9C,SAASC,EAAiBC,GAA6D,IAA5DC,MAAEA,EAAK7D,MAAEA,GAAiD4D,EACjF,OAAOH,EAAuBlH,iBAAiByD,GAAS6D,EAAO,CAC3DnH,UAAW,CACPC,SAAS,IAGrB,CAEA,IAgEMmH,EAAgC,CAClCC,YAjEiBC,IACjB,IAAMxO,EAAMC,EACPD,GACD4M,EAAOK,KAAK,6CAEhB,IAAMwB,EAAkBzO,EAAI0O,QAS5B,OAPA1O,EAAI0O,QAAU,WAA4C,IAAA,IAAAC,EAAAvJ,EAAAC,UAAAzC,OAA/BoK,EAAI,IAAAlM,MAAAsE,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAJyH,EAAIzH,GAAAF,UAAAE,GAC3B,IAAMqJ,EAAkBT,EAAkB,CAAEE,MAAOrB,EAAK,GAAIxC,MAAOwC,EAAK,KAExE,OADAwB,EAAUI,GACuB,QAAjCD,EAAsB,MAAfF,OAAe,EAAfA,KAAqBzB,UAAK,IAAA2B,GAAAA,CACrC,EACA3O,EAAI0O,QAAQG,0BAA2B,EAEhC,KAAM,IAAAC,EACS,OAAlBA,EAAO9O,EAAI0O,iBAAJI,EAAaD,yBACpB7O,EAAI0O,QAAUD,CAAe,CAChC,EAiDDM,uBA9C4BP,IAC5B,IAAMxO,EAAMC,EACPD,GACD4M,EAAOK,KAAK,0DAGhB,IAAM+B,EAA+BhP,EAAIiP,qBASzC,OAPAjP,EAAIiP,qBAAuB,SAAUC,GAAoC,IAAAC,EAC/DP,EAAkBT,EAAkB,CAAEE,MAAOa,IAEnD,OADAV,EAAUI,GAC2C,QAArDO,QAAOH,SAAAA,EAA8BzH,MAAMvH,EAAK,CAACkP,WAAI,IAAAC,GAAAA,CACzD,EACAnP,EAAIiP,qBAAqBJ,0BAA2B,EAE7C,KAAM,IAAAO,EACsB,OAA/BA,EAAOpP,EAAIiP,8BAAJG,EAA0BP,yBACjC7O,EAAIiP,qBAAuBD,CAA4B,CAC1D,EA6BDK,iBA1BsBb,IACtB,IAAMc,EAAMxC,QACPwC,GACD1C,EAAOK,KAAK,oDAGhB,IAAMsC,EAAuBD,EAAI9E,MAWjC,OATA8E,EAAI9E,MAAQ,WAAgC,IAAA,IAAA0C,EAAA7H,UAAAzC,OAAnBoK,EAAI,IAAAlM,MAAAoM,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAJH,EAAIG,GAAA9H,UAAA8H,GACzB,IAAMkB,EAAQrB,EAAK3B,KAAK,KAElBuD,EAAkBT,EAAkB,CAAE3D,MAD9BwC,EAAKwC,MAAMC,GAAQA,aAAerF,QACGiE,UAEnD,OADAG,EAAUI,GACiB,MAApBW,OAAoB,EAApBA,KAA0BvC,EACrC,EACAsC,EAAI9E,MAAMqE,0BAA2B,EAE9B,KAAM,IAAAa,EACO,OAAhBA,EAAOJ,EAAI9E,eAAJkF,EAAWb,yBAClBS,EAAI9E,MAAQ+E,CAAoB,CACnC,GASL3O,EAAiB+O,sBAAwB/O,EAAiB+O,uBAAyB,CAAA,EACnF/O,EAAiB+O,sBAAsBC,uBAAyBtB,EAOhE1N,EAAiB0N,8BAAgCA"}