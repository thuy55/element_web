var H = { exports: {} }, ee, Ze;
function k() {
  if (Ze) return ee;
  Ze = 1;
  const r = "2.0.0", i = 256, t = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, s = 16, a = i - 6;
  return ee = {
    MAX_LENGTH: i,
    MAX_SAFE_COMPONENT_LENGTH: s,
    MAX_SAFE_BUILD_LENGTH: a,
    MAX_SAFE_INTEGER: t,
    RELEASE_TYPES: [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ],
    SEMVER_SPEC_VERSION: r,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  }, ee;
}
var re, Je;
function B() {
  if (Je) return re;
  Je = 1;
  var r = { env: {} };
  return re = typeof r == "object" && r.env && r.env.NODE_DEBUG && /\bsemver\b/i.test(r.env.NODE_DEBUG) ? (...t) => console.error("SEMVER", ...t) : () => {
  }, re;
}
var Qe;
function M() {
  return Qe || (Qe = 1, function(r, i) {
    const {
      MAX_SAFE_COMPONENT_LENGTH: t,
      MAX_SAFE_BUILD_LENGTH: s,
      MAX_LENGTH: a
    } = k(), p = B();
    i = r.exports = {};
    const u = i.re = [], f = i.safeRe = [], n = i.src = [], e = i.t = {};
    let o = 0;
    const c = "[a-zA-Z0-9-]", l = [
      ["\\s", 1],
      ["\\d", a],
      [c, s]
    ], m = (g) => {
      for (const [O, w] of l)
        g = g.split(`${O}*`).join(`${O}{0,${w}}`).split(`${O}+`).join(`${O}{1,${w}}`);
      return g;
    }, E = (g, O, w) => {
      const _ = m(O), A = o++;
      p(g, A, O), e[g] = A, n[A] = O, u[A] = new RegExp(O, w ? "g" : void 0), f[A] = new RegExp(_, w ? "g" : void 0);
    };
    E("NUMERICIDENTIFIER", "0|[1-9]\\d*"), E("NUMERICIDENTIFIERLOOSE", "\\d+"), E("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${c}*`), E("MAINVERSION", `(${n[e.NUMERICIDENTIFIER]})\\.(${n[e.NUMERICIDENTIFIER]})\\.(${n[e.NUMERICIDENTIFIER]})`), E("MAINVERSIONLOOSE", `(${n[e.NUMERICIDENTIFIERLOOSE]})\\.(${n[e.NUMERICIDENTIFIERLOOSE]})\\.(${n[e.NUMERICIDENTIFIERLOOSE]})`), E("PRERELEASEIDENTIFIER", `(?:${n[e.NUMERICIDENTIFIER]}|${n[e.NONNUMERICIDENTIFIER]})`), E("PRERELEASEIDENTIFIERLOOSE", `(?:${n[e.NUMERICIDENTIFIERLOOSE]}|${n[e.NONNUMERICIDENTIFIER]})`), E("PRERELEASE", `(?:-(${n[e.PRERELEASEIDENTIFIER]}(?:\\.${n[e.PRERELEASEIDENTIFIER]})*))`), E("PRERELEASELOOSE", `(?:-?(${n[e.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${n[e.PRERELEASEIDENTIFIERLOOSE]})*))`), E("BUILDIDENTIFIER", `${c}+`), E("BUILD", `(?:\\+(${n[e.BUILDIDENTIFIER]}(?:\\.${n[e.BUILDIDENTIFIER]})*))`), E("FULLPLAIN", `v?${n[e.MAINVERSION]}${n[e.PRERELEASE]}?${n[e.BUILD]}?`), E("FULL", `^${n[e.FULLPLAIN]}$`), E("LOOSEPLAIN", `[v=\\s]*${n[e.MAINVERSIONLOOSE]}${n[e.PRERELEASELOOSE]}?${n[e.BUILD]}?`), E("LOOSE", `^${n[e.LOOSEPLAIN]}$`), E("GTLT", "((?:<|>)?=?)"), E("XRANGEIDENTIFIERLOOSE", `${n[e.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), E("XRANGEIDENTIFIER", `${n[e.NUMERICIDENTIFIER]}|x|X|\\*`), E("XRANGEPLAIN", `[v=\\s]*(${n[e.XRANGEIDENTIFIER]})(?:\\.(${n[e.XRANGEIDENTIFIER]})(?:\\.(${n[e.XRANGEIDENTIFIER]})(?:${n[e.PRERELEASE]})?${n[e.BUILD]}?)?)?`), E("XRANGEPLAINLOOSE", `[v=\\s]*(${n[e.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[e.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[e.XRANGEIDENTIFIERLOOSE]})(?:${n[e.PRERELEASELOOSE]})?${n[e.BUILD]}?)?)?`), E("XRANGE", `^${n[e.GTLT]}\\s*${n[e.XRANGEPLAIN]}$`), E("XRANGELOOSE", `^${n[e.GTLT]}\\s*${n[e.XRANGEPLAINLOOSE]}$`), E("COERCEPLAIN", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?`), E("COERCE", `${n[e.COERCEPLAIN]}(?:$|[^\\d])`), E("COERCEFULL", n[e.COERCEPLAIN] + `(?:${n[e.PRERELEASE]})?(?:${n[e.BUILD]})?(?:$|[^\\d])`), E("COERCERTL", n[e.COERCE], !0), E("COERCERTLFULL", n[e.COERCEFULL], !0), E("LONETILDE", "(?:~>?)"), E("TILDETRIM", `(\\s*)${n[e.LONETILDE]}\\s+`, !0), i.tildeTrimReplace = "$1~", E("TILDE", `^${n[e.LONETILDE]}${n[e.XRANGEPLAIN]}$`), E("TILDELOOSE", `^${n[e.LONETILDE]}${n[e.XRANGEPLAINLOOSE]}$`), E("LONECARET", "(?:\\^)"), E("CARETTRIM", `(\\s*)${n[e.LONECARET]}\\s+`, !0), i.caretTrimReplace = "$1^", E("CARET", `^${n[e.LONECARET]}${n[e.XRANGEPLAIN]}$`), E("CARETLOOSE", `^${n[e.LONECARET]}${n[e.XRANGEPLAINLOOSE]}$`), E("COMPARATORLOOSE", `^${n[e.GTLT]}\\s*(${n[e.LOOSEPLAIN]})$|^$`), E("COMPARATOR", `^${n[e.GTLT]}\\s*(${n[e.FULLPLAIN]})$|^$`), E("COMPARATORTRIM", `(\\s*)${n[e.GTLT]}\\s*(${n[e.LOOSEPLAIN]}|${n[e.XRANGEPLAIN]})`, !0), i.comparatorTrimReplace = "$1$2$3", E("HYPHENRANGE", `^\\s*(${n[e.XRANGEPLAIN]})\\s+-\\s+(${n[e.XRANGEPLAIN]})\\s*$`), E("HYPHENRANGELOOSE", `^\\s*(${n[e.XRANGEPLAINLOOSE]})\\s+-\\s+(${n[e.XRANGEPLAINLOOSE]})\\s*$`), E("STAR", "(<|>)?=?\\s*\\*"), E("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), E("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }(H, H.exports)), H.exports;
}
var te, er;
function ke() {
  if (er) return te;
  er = 1;
  const r = Object.freeze({ loose: !0 }), i = Object.freeze({});
  return te = (s) => s ? typeof s != "object" ? r : s : i, te;
}
var se, rr;
function Mr() {
  if (rr) return se;
  rr = 1;
  const r = /^[0-9]+$/, i = (s, a) => {
    const p = r.test(s), u = r.test(a);
    return p && u && (s = +s, a = +a), s === a ? 0 : p && !u ? -1 : u && !p ? 1 : s < a ? -1 : 1;
  };
  return se = {
    compareIdentifiers: i,
    rcompareIdentifiers: (s, a) => i(a, s)
  }, se;
}
var ne, tr;
function G() {
  if (tr) return ne;
  tr = 1;
  const r = B(), { MAX_LENGTH: i, MAX_SAFE_INTEGER: t } = k(), { safeRe: s, t: a } = M(), p = ke(), { compareIdentifiers: u } = Mr();
  class f {
    constructor(e, o) {
      if (o = p(o), e instanceof f) {
        if (e.loose === !!o.loose && e.includePrerelease === !!o.includePrerelease)
          return e;
        e = e.version;
      } else if (typeof e != "string")
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof e}".`);
      if (e.length > i)
        throw new TypeError(
          `version is longer than ${i} characters`
        );
      r("SemVer", e, o), this.options = o, this.loose = !!o.loose, this.includePrerelease = !!o.includePrerelease;
      const c = e.trim().match(o.loose ? s[a.LOOSE] : s[a.FULL]);
      if (!c)
        throw new TypeError(`Invalid Version: ${e}`);
      if (this.raw = e, this.major = +c[1], this.minor = +c[2], this.patch = +c[3], this.major > t || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > t || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > t || this.patch < 0)
        throw new TypeError("Invalid patch version");
      c[4] ? this.prerelease = c[4].split(".").map((l) => {
        if (/^[0-9]+$/.test(l)) {
          const m = +l;
          if (m >= 0 && m < t)
            return m;
        }
        return l;
      }) : this.prerelease = [], this.build = c[5] ? c[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(e) {
      if (r("SemVer.compare", this.version, this.options, e), !(e instanceof f)) {
        if (typeof e == "string" && e === this.version)
          return 0;
        e = new f(e, this.options);
      }
      return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
    }
    compareMain(e) {
      return e instanceof f || (e = new f(e, this.options)), u(this.major, e.major) || u(this.minor, e.minor) || u(this.patch, e.patch);
    }
    comparePre(e) {
      if (e instanceof f || (e = new f(e, this.options)), this.prerelease.length && !e.prerelease.length)
        return -1;
      if (!this.prerelease.length && e.prerelease.length)
        return 1;
      if (!this.prerelease.length && !e.prerelease.length)
        return 0;
      let o = 0;
      do {
        const c = this.prerelease[o], l = e.prerelease[o];
        if (r("prerelease compare", o, c, l), c === void 0 && l === void 0)
          return 0;
        if (l === void 0)
          return 1;
        if (c === void 0)
          return -1;
        if (c === l)
          continue;
        return u(c, l);
      } while (++o);
    }
    compareBuild(e) {
      e instanceof f || (e = new f(e, this.options));
      let o = 0;
      do {
        const c = this.build[o], l = e.build[o];
        if (r("build compare", o, c, l), c === void 0 && l === void 0)
          return 0;
        if (l === void 0)
          return 1;
        if (c === void 0)
          return -1;
        if (c === l)
          continue;
        return u(c, l);
      } while (++o);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(e, o, c) {
      switch (e) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", o, c);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", o, c);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", o, c), this.inc("pre", o, c);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", o, c), this.inc("pre", o, c);
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre": {
          const l = Number(c) ? 1 : 0;
          if (!o && c === !1)
            throw new Error("invalid increment argument: identifier is empty");
          if (this.prerelease.length === 0)
            this.prerelease = [l];
          else {
            let m = this.prerelease.length;
            for (; --m >= 0; )
              typeof this.prerelease[m] == "number" && (this.prerelease[m]++, m = -2);
            if (m === -1) {
              if (o === this.prerelease.join(".") && c === !1)
                throw new Error("invalid increment argument: identifier already exists");
              this.prerelease.push(l);
            }
          }
          if (o) {
            let m = [o, l];
            c === !1 && (m = [o]), u(this.prerelease[0], o) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = m) : this.prerelease = m;
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${e}`);
      }
      return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
    }
  }
  return ne = f, ne;
}
var ie, sr;
function X() {
  if (sr) return ie;
  sr = 1;
  const r = G();
  return ie = (t, s, a = !1) => {
    if (t instanceof r)
      return t;
    try {
      return new r(t, s);
    } catch (p) {
      if (!a)
        return null;
      throw p;
    }
  }, ie;
}
var ae, nr;
function Yr() {
  if (nr) return ae;
  nr = 1;
  const r = X();
  return ae = (t, s) => {
    const a = r(t, s);
    return a ? a.version : null;
  }, ae;
}
var oe, ir;
function Wr() {
  if (ir) return oe;
  ir = 1;
  const r = X();
  return oe = (t, s) => {
    const a = r(t.trim().replace(/^[=v]+/, ""), s);
    return a ? a.version : null;
  }, oe;
}
var ce, ar;
function zr() {
  if (ar) return ce;
  ar = 1;
  const r = G();
  return ce = (t, s, a, p, u) => {
    typeof a == "string" && (u = p, p = a, a = void 0);
    try {
      return new r(
        t instanceof r ? t.version : t,
        a
      ).inc(s, p, u).version;
    } catch {
      return null;
    }
  }, ce;
}
var ue, or;
function Kr() {
  if (or) return ue;
  or = 1;
  const r = X();
  return ue = (t, s) => {
    const a = r(t, null, !0), p = r(s, null, !0), u = a.compare(p);
    if (u === 0)
      return null;
    const f = u > 0, n = f ? a : p, e = f ? p : a, o = !!n.prerelease.length;
    if (!!e.prerelease.length && !o)
      return !e.patch && !e.minor ? "major" : n.patch ? "patch" : n.minor ? "minor" : "major";
    const l = o ? "pre" : "";
    return a.major !== p.major ? l + "major" : a.minor !== p.minor ? l + "minor" : a.patch !== p.patch ? l + "patch" : "prerelease";
  }, ue;
}
var le, cr;
function Zr() {
  if (cr) return le;
  cr = 1;
  const r = G();
  return le = (t, s) => new r(t, s).major, le;
}
var fe, ur;
function Jr() {
  if (ur) return fe;
  ur = 1;
  const r = G();
  return fe = (t, s) => new r(t, s).minor, fe;
}
var he, lr;
function Qr() {
  if (lr) return he;
  lr = 1;
  const r = G();
  return he = (t, s) => new r(t, s).patch, he;
}
var Ee, fr;
function et() {
  if (fr) return Ee;
  fr = 1;
  const r = X();
  return Ee = (t, s) => {
    const a = r(t, s);
    return a && a.prerelease.length ? a.prerelease : null;
  }, Ee;
}
var pe, hr;
function F() {
  if (hr) return pe;
  hr = 1;
  const r = G();
  return pe = (t, s, a) => new r(t, a).compare(new r(s, a)), pe;
}
var Re, Er;
function rt() {
  if (Er) return Re;
  Er = 1;
  const r = F();
  return Re = (t, s, a) => r(s, t, a), Re;
}
var me, pr;
function tt() {
  if (pr) return me;
  pr = 1;
  const r = F();
  return me = (t, s) => r(t, s, !0), me;
}
var de, Rr;
function Be() {
  if (Rr) return de;
  Rr = 1;
  const r = G();
  return de = (t, s, a) => {
    const p = new r(t, a), u = new r(s, a);
    return p.compare(u) || p.compareBuild(u);
  }, de;
}
var $e, mr;
function st() {
  if (mr) return $e;
  mr = 1;
  const r = Be();
  return $e = (t, s) => t.sort((a, p) => r(a, p, s)), $e;
}
var Ie, dr;
function nt() {
  if (dr) return Ie;
  dr = 1;
  const r = Be();
  return Ie = (t, s) => t.sort((a, p) => r(p, a, s)), Ie;
}
var ve, $r;
function Y() {
  if ($r) return ve;
  $r = 1;
  const r = F();
  return ve = (t, s, a) => r(t, s, a) > 0, ve;
}
var Le, Ir;
function Ye() {
  if (Ir) return Le;
  Ir = 1;
  const r = F();
  return Le = (t, s, a) => r(t, s, a) < 0, Le;
}
var Ne, vr;
function Hr() {
  if (vr) return Ne;
  vr = 1;
  const r = F();
  return Ne = (t, s, a) => r(t, s, a) === 0, Ne;
}
var Oe, Lr;
function kr() {
  if (Lr) return Oe;
  Lr = 1;
  const r = F();
  return Oe = (t, s, a) => r(t, s, a) !== 0, Oe;
}
var Se, Nr;
function We() {
  if (Nr) return Se;
  Nr = 1;
  const r = F();
  return Se = (t, s, a) => r(t, s, a) >= 0, Se;
}
var ge, Or;
function ze() {
  if (Or) return ge;
  Or = 1;
  const r = F();
  return ge = (t, s, a) => r(t, s, a) <= 0, ge;
}
var Ae, Sr;
function Br() {
  if (Sr) return Ae;
  Sr = 1;
  const r = Hr(), i = kr(), t = Y(), s = We(), a = Ye(), p = ze();
  return Ae = (f, n, e, o) => {
    switch (n) {
      case "===":
        return typeof f == "object" && (f = f.version), typeof e == "object" && (e = e.version), f === e;
      case "!==":
        return typeof f == "object" && (f = f.version), typeof e == "object" && (e = e.version), f !== e;
      case "":
      case "=":
      case "==":
        return r(f, e, o);
      case "!=":
        return i(f, e, o);
      case ">":
        return t(f, e, o);
      case ">=":
        return s(f, e, o);
      case "<":
        return a(f, e, o);
      case "<=":
        return p(f, e, o);
      default:
        throw new TypeError(`Invalid operator: ${n}`);
    }
  }, Ae;
}
var Te, gr;
function it() {
  if (gr) return Te;
  gr = 1;
  const r = G(), i = X(), { safeRe: t, t: s } = M();
  return Te = (p, u) => {
    if (p instanceof r)
      return p;
    if (typeof p == "number" && (p = String(p)), typeof p != "string")
      return null;
    u = u || {};
    let f = null;
    if (!u.rtl)
      f = p.match(u.includePrerelease ? t[s.COERCEFULL] : t[s.COERCE]);
    else {
      const m = u.includePrerelease ? t[s.COERCERTLFULL] : t[s.COERCERTL];
      let E;
      for (; (E = m.exec(p)) && (!f || f.index + f[0].length !== p.length); )
        (!f || E.index + E[0].length !== f.index + f[0].length) && (f = E), m.lastIndex = E.index + E[1].length + E[2].length;
      m.lastIndex = -1;
    }
    if (f === null)
      return null;
    const n = f[2], e = f[3] || "0", o = f[4] || "0", c = u.includePrerelease && f[5] ? `-${f[5]}` : "", l = u.includePrerelease && f[6] ? `+${f[6]}` : "";
    return i(`${n}.${e}.${o}${c}${l}`, u);
  }, Te;
}
var we, Ar;
function at() {
  if (Ar) return we;
  Ar = 1;
  class r {
    constructor() {
      this.max = 1e3, this.map = /* @__PURE__ */ new Map();
    }
    get(t) {
      const s = this.map.get(t);
      if (s !== void 0)
        return this.map.delete(t), this.map.set(t, s), s;
    }
    delete(t) {
      return this.map.delete(t);
    }
    set(t, s) {
      if (!this.delete(t) && s !== void 0) {
        if (this.map.size >= this.max) {
          const p = this.map.keys().next().value;
          this.delete(p);
        }
        this.map.set(t, s);
      }
      return this;
    }
  }
  return we = r, we;
}
var qe, Tr;
function V() {
  if (Tr) return qe;
  Tr = 1;
  const r = /\s+/g;
  class i {
    constructor(h, I) {
      if (I = a(I), h instanceof i)
        return h.loose === !!I.loose && h.includePrerelease === !!I.includePrerelease ? h : new i(h.raw, I);
      if (h instanceof p)
        return this.raw = h.value, this.set = [[h]], this.formatted = void 0, this;
      if (this.options = I, this.loose = !!I.loose, this.includePrerelease = !!I.includePrerelease, this.raw = h.trim().replace(r, " "), this.set = this.raw.split("||").map((d) => this.parseRange(d.trim())).filter((d) => d.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const d = this.set[0];
        if (this.set = this.set.filter((v) => !g(v[0])), this.set.length === 0)
          this.set = [d];
        else if (this.set.length > 1) {
          for (const v of this.set)
            if (v.length === 1 && O(v[0])) {
              this.set = [v];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let h = 0; h < this.set.length; h++) {
          h > 0 && (this.formatted += "||");
          const I = this.set[h];
          for (let d = 0; d < I.length; d++)
            d > 0 && (this.formatted += " "), this.formatted += I[d].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(h) {
      const d = ((this.options.includePrerelease && m) | (this.options.loose && E)) + ":" + h, v = s.get(d);
      if (v)
        return v;
      const $ = this.options.loose, L = $ ? n[e.HYPHENRANGELOOSE] : n[e.HYPHENRANGE];
      h = h.replace(L, J(this.options.includePrerelease)), u("hyphen replace", h), h = h.replace(n[e.COMPARATORTRIM], o), u("comparator trim", h), h = h.replace(n[e.TILDETRIM], c), u("tilde trim", h), h = h.replace(n[e.CARETTRIM], l), u("caret trim", h);
      let T = h.split(" ").map((P) => _(P, this.options)).join(" ").split(/\s+/).map((P) => Z(P, this.options));
      $ && (T = T.filter((P) => (u("loose invalid filter", P, this.options), !!P.match(n[e.COMPARATORLOOSE])))), u("range list", T);
      const S = /* @__PURE__ */ new Map(), q = T.map((P) => new p(P, this.options));
      for (const P of q) {
        if (g(P))
          return [P];
        S.set(P.value, P);
      }
      S.size > 1 && S.has("") && S.delete("");
      const D = [...S.values()];
      return s.set(d, D), D;
    }
    intersects(h, I) {
      if (!(h instanceof i))
        throw new TypeError("a Range is required");
      return this.set.some((d) => w(d, I) && h.set.some((v) => w(v, I) && d.every(($) => v.every((L) => $.intersects(L, I)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(h) {
      if (!h)
        return !1;
      if (typeof h == "string")
        try {
          h = new f(h, this.options);
        } catch {
          return !1;
        }
      for (let I = 0; I < this.set.length; I++)
        if (Q(this.set[I], h, this.options))
          return !0;
      return !1;
    }
  }
  qe = i;
  const t = at(), s = new t(), a = ke(), p = W(), u = B(), f = G(), {
    safeRe: n,
    t: e,
    comparatorTrimReplace: o,
    tildeTrimReplace: c,
    caretTrimReplace: l
  } = M(), { FLAG_INCLUDE_PRERELEASE: m, FLAG_LOOSE: E } = k(), g = (R) => R.value === "<0.0.0-0", O = (R) => R.value === "", w = (R, h) => {
    let I = !0;
    const d = R.slice();
    let v = d.pop();
    for (; I && d.length; )
      I = d.every(($) => v.intersects($, h)), v = d.pop();
    return I;
  }, _ = (R, h) => (u("comp", R, h), R = C(R, h), u("caret", R), R = U(R, h), u("tildes", R), R = N(R, h), u("xrange", R), R = K(R, h), u("stars", R), R), A = (R) => !R || R.toLowerCase() === "x" || R === "*", U = (R, h) => R.trim().split(/\s+/).map((I) => j(I, h)).join(" "), j = (R, h) => {
    const I = h.loose ? n[e.TILDELOOSE] : n[e.TILDE];
    return R.replace(I, (d, v, $, L, T) => {
      u("tilde", R, d, v, $, L, T);
      let S;
      return A(v) ? S = "" : A($) ? S = `>=${v}.0.0 <${+v + 1}.0.0-0` : A(L) ? S = `>=${v}.${$}.0 <${v}.${+$ + 1}.0-0` : T ? (u("replaceTilde pr", T), S = `>=${v}.${$}.${L}-${T} <${v}.${+$ + 1}.0-0`) : S = `>=${v}.${$}.${L} <${v}.${+$ + 1}.0-0`, u("tilde return", S), S;
    });
  }, C = (R, h) => R.trim().split(/\s+/).map((I) => y(I, h)).join(" "), y = (R, h) => {
    u("caret", R, h);
    const I = h.loose ? n[e.CARETLOOSE] : n[e.CARET], d = h.includePrerelease ? "-0" : "";
    return R.replace(I, (v, $, L, T, S) => {
      u("caret", R, v, $, L, T, S);
      let q;
      return A($) ? q = "" : A(L) ? q = `>=${$}.0.0${d} <${+$ + 1}.0.0-0` : A(T) ? $ === "0" ? q = `>=${$}.${L}.0${d} <${$}.${+L + 1}.0-0` : q = `>=${$}.${L}.0${d} <${+$ + 1}.0.0-0` : S ? (u("replaceCaret pr", S), $ === "0" ? L === "0" ? q = `>=${$}.${L}.${T}-${S} <${$}.${L}.${+T + 1}-0` : q = `>=${$}.${L}.${T}-${S} <${$}.${+L + 1}.0-0` : q = `>=${$}.${L}.${T}-${S} <${+$ + 1}.0.0-0`) : (u("no pr"), $ === "0" ? L === "0" ? q = `>=${$}.${L}.${T}${d} <${$}.${L}.${+T + 1}-0` : q = `>=${$}.${L}.${T}${d} <${$}.${+L + 1}.0-0` : q = `>=${$}.${L}.${T} <${+$ + 1}.0.0-0`), u("caret return", q), q;
    });
  }, N = (R, h) => (u("replaceXRanges", R, h), R.split(/\s+/).map((I) => x(I, h)).join(" ")), x = (R, h) => {
    R = R.trim();
    const I = h.loose ? n[e.XRANGELOOSE] : n[e.XRANGE];
    return R.replace(I, (d, v, $, L, T, S) => {
      u("xRange", R, d, v, $, L, T, S);
      const q = A($), D = q || A(L), P = D || A(T), b = P;
      return v === "=" && b && (v = ""), S = h.includePrerelease ? "-0" : "", q ? v === ">" || v === "<" ? d = "<0.0.0-0" : d = "*" : v && b ? (D && (L = 0), T = 0, v === ">" ? (v = ">=", D ? ($ = +$ + 1, L = 0, T = 0) : (L = +L + 1, T = 0)) : v === "<=" && (v = "<", D ? $ = +$ + 1 : L = +L + 1), v === "<" && (S = "-0"), d = `${v + $}.${L}.${T}${S}`) : D ? d = `>=${$}.0.0${S} <${+$ + 1}.0.0-0` : P && (d = `>=${$}.${L}.0${S} <${$}.${+L + 1}.0-0`), u("xRange return", d), d;
    });
  }, K = (R, h) => (u("replaceStars", R, h), R.trim().replace(n[e.STAR], "")), Z = (R, h) => (u("replaceGTE0", R, h), R.trim().replace(n[h.includePrerelease ? e.GTE0PRE : e.GTE0], "")), J = (R) => (h, I, d, v, $, L, T, S, q, D, P, b) => (A(d) ? I = "" : A(v) ? I = `>=${d}.0.0${R ? "-0" : ""}` : A($) ? I = `>=${d}.${v}.0${R ? "-0" : ""}` : L ? I = `>=${I}` : I = `>=${I}${R ? "-0" : ""}`, A(q) ? S = "" : A(D) ? S = `<${+q + 1}.0.0-0` : A(P) ? S = `<${q}.${+D + 1}.0-0` : b ? S = `<=${q}.${D}.${P}-${b}` : R ? S = `<${q}.${D}.${+P + 1}-0` : S = `<=${S}`, `${I} ${S}`.trim()), Q = (R, h, I) => {
    for (let d = 0; d < R.length; d++)
      if (!R[d].test(h))
        return !1;
    if (h.prerelease.length && !I.includePrerelease) {
      for (let d = 0; d < R.length; d++)
        if (u(R[d].semver), R[d].semver !== p.ANY && R[d].semver.prerelease.length > 0) {
          const v = R[d].semver;
          if (v.major === h.major && v.minor === h.minor && v.patch === h.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return qe;
}
var Ce, wr;
function W() {
  if (wr) return Ce;
  wr = 1;
  const r = Symbol("SemVer ANY");
  class i {
    static get ANY() {
      return r;
    }
    constructor(o, c) {
      if (c = t(c), o instanceof i) {
        if (o.loose === !!c.loose)
          return o;
        o = o.value;
      }
      o = o.trim().split(/\s+/).join(" "), u("comparator", o, c), this.options = c, this.loose = !!c.loose, this.parse(o), this.semver === r ? this.value = "" : this.value = this.operator + this.semver.version, u("comp", this);
    }
    parse(o) {
      const c = this.options.loose ? s[a.COMPARATORLOOSE] : s[a.COMPARATOR], l = o.match(c);
      if (!l)
        throw new TypeError(`Invalid comparator: ${o}`);
      this.operator = l[1] !== void 0 ? l[1] : "", this.operator === "=" && (this.operator = ""), l[2] ? this.semver = new f(l[2], this.options.loose) : this.semver = r;
    }
    toString() {
      return this.value;
    }
    test(o) {
      if (u("Comparator.test", o, this.options.loose), this.semver === r || o === r)
        return !0;
      if (typeof o == "string")
        try {
          o = new f(o, this.options);
        } catch {
          return !1;
        }
      return p(o, this.operator, this.semver, this.options);
    }
    intersects(o, c) {
      if (!(o instanceof i))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new n(o.value, c).test(this.value) : o.operator === "" ? o.value === "" ? !0 : new n(this.value, c).test(o.semver) : (c = t(c), c.includePrerelease && (this.value === "<0.0.0-0" || o.value === "<0.0.0-0") || !c.includePrerelease && (this.value.startsWith("<0.0.0") || o.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && o.operator.startsWith(">") || this.operator.startsWith("<") && o.operator.startsWith("<") || this.semver.version === o.semver.version && this.operator.includes("=") && o.operator.includes("=") || p(this.semver, "<", o.semver, c) && this.operator.startsWith(">") && o.operator.startsWith("<") || p(this.semver, ">", o.semver, c) && this.operator.startsWith("<") && o.operator.startsWith(">")));
    }
  }
  Ce = i;
  const t = ke(), { safeRe: s, t: a } = M(), p = Br(), u = B(), f = G(), n = V();
  return Ce;
}
var Pe, qr;
function z() {
  if (qr) return Pe;
  qr = 1;
  const r = V();
  return Pe = (t, s, a) => {
    try {
      s = new r(s, a);
    } catch {
      return !1;
    }
    return s.test(t);
  }, Pe;
}
var ye, Cr;
function ot() {
  if (Cr) return ye;
  Cr = 1;
  const r = V();
  return ye = (t, s) => new r(t, s).set.map((a) => a.map((p) => p.value).join(" ").trim().split(" ")), ye;
}
var De, Pr;
function ct() {
  if (Pr) return De;
  Pr = 1;
  const r = G(), i = V();
  return De = (s, a, p) => {
    let u = null, f = null, n = null;
    try {
      n = new i(a, p);
    } catch {
      return null;
    }
    return s.forEach((e) => {
      n.test(e) && (!u || f.compare(e) === -1) && (u = e, f = new r(u, p));
    }), u;
  }, De;
}
var Ge, yr;
function ut() {
  if (yr) return Ge;
  yr = 1;
  const r = G(), i = V();
  return Ge = (s, a, p) => {
    let u = null, f = null, n = null;
    try {
      n = new i(a, p);
    } catch {
      return null;
    }
    return s.forEach((e) => {
      n.test(e) && (!u || f.compare(e) === 1) && (u = e, f = new r(u, p));
    }), u;
  }, Ge;
}
var _e, Dr;
function lt() {
  if (Dr) return _e;
  Dr = 1;
  const r = G(), i = V(), t = Y();
  return _e = (a, p) => {
    a = new i(a, p);
    let u = new r("0.0.0");
    if (a.test(u) || (u = new r("0.0.0-0"), a.test(u)))
      return u;
    u = null;
    for (let f = 0; f < a.set.length; ++f) {
      const n = a.set[f];
      let e = null;
      n.forEach((o) => {
        const c = new r(o.semver.version);
        switch (o.operator) {
          case ">":
            c.prerelease.length === 0 ? c.patch++ : c.prerelease.push(0), c.raw = c.format();
          /* fallthrough */
          case "":
          case ">=":
            (!e || t(c, e)) && (e = c);
            break;
          case "<":
          case "<=":
            break;
          /* istanbul ignore next */
          default:
            throw new Error(`Unexpected operation: ${o.operator}`);
        }
      }), e && (!u || t(u, e)) && (u = e);
    }
    return u && a.test(u) ? u : null;
  }, _e;
}
var je, Gr;
function ft() {
  if (Gr) return je;
  Gr = 1;
  const r = V();
  return je = (t, s) => {
    try {
      return new r(t, s).range || "*";
    } catch {
      return null;
    }
  }, je;
}
var Fe, _r;
function Ke() {
  if (_r) return Fe;
  _r = 1;
  const r = G(), i = W(), { ANY: t } = i, s = V(), a = z(), p = Y(), u = Ye(), f = ze(), n = We();
  return Fe = (o, c, l, m) => {
    o = new r(o, m), c = new s(c, m);
    let E, g, O, w, _;
    switch (l) {
      case ">":
        E = p, g = f, O = u, w = ">", _ = ">=";
        break;
      case "<":
        E = u, g = n, O = p, w = "<", _ = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (a(o, c, m))
      return !1;
    for (let A = 0; A < c.set.length; ++A) {
      const U = c.set[A];
      let j = null, C = null;
      if (U.forEach((y) => {
        y.semver === t && (y = new i(">=0.0.0")), j = j || y, C = C || y, E(y.semver, j.semver, m) ? j = y : O(y.semver, C.semver, m) && (C = y);
      }), j.operator === w || j.operator === _ || (!C.operator || C.operator === w) && g(o, C.semver))
        return !1;
      if (C.operator === _ && O(o, C.semver))
        return !1;
    }
    return !0;
  }, Fe;
}
var Ve, jr;
function ht() {
  if (jr) return Ve;
  jr = 1;
  const r = Ke();
  return Ve = (t, s, a) => r(t, s, ">", a), Ve;
}
var Ue, Fr;
function Et() {
  if (Fr) return Ue;
  Fr = 1;
  const r = Ke();
  return Ue = (t, s, a) => r(t, s, "<", a), Ue;
}
var Xe, Vr;
function pt() {
  if (Vr) return Xe;
  Vr = 1;
  const r = V();
  return Xe = (t, s, a) => (t = new r(t, a), s = new r(s, a), t.intersects(s, a)), Xe;
}
var xe, Ur;
function Rt() {
  if (Ur) return xe;
  Ur = 1;
  const r = z(), i = F();
  return xe = (t, s, a) => {
    const p = [];
    let u = null, f = null;
    const n = t.sort((l, m) => i(l, m, a));
    for (const l of n)
      r(l, s, a) ? (f = l, u || (u = l)) : (f && p.push([u, f]), f = null, u = null);
    u && p.push([u, null]);
    const e = [];
    for (const [l, m] of p)
      l === m ? e.push(l) : !m && l === n[0] ? e.push("*") : m ? l === n[0] ? e.push(`<=${m}`) : e.push(`${l} - ${m}`) : e.push(`>=${l}`);
    const o = e.join(" || "), c = typeof s.raw == "string" ? s.raw : String(s);
    return o.length < c.length ? o : s;
  }, xe;
}
var be, Xr;
function mt() {
  if (Xr) return be;
  Xr = 1;
  const r = V(), i = W(), { ANY: t } = i, s = z(), a = F(), p = (c, l, m = {}) => {
    if (c === l)
      return !0;
    c = new r(c, m), l = new r(l, m);
    let E = !1;
    e: for (const g of c.set) {
      for (const O of l.set) {
        const w = n(g, O, m);
        if (E = E || w !== null, w)
          continue e;
      }
      if (E)
        return !1;
    }
    return !0;
  }, u = [new i(">=0.0.0-0")], f = [new i(">=0.0.0")], n = (c, l, m) => {
    if (c === l)
      return !0;
    if (c.length === 1 && c[0].semver === t) {
      if (l.length === 1 && l[0].semver === t)
        return !0;
      m.includePrerelease ? c = u : c = f;
    }
    if (l.length === 1 && l[0].semver === t) {
      if (m.includePrerelease)
        return !0;
      l = f;
    }
    const E = /* @__PURE__ */ new Set();
    let g, O;
    for (const N of c)
      N.operator === ">" || N.operator === ">=" ? g = e(g, N, m) : N.operator === "<" || N.operator === "<=" ? O = o(O, N, m) : E.add(N.semver);
    if (E.size > 1)
      return null;
    let w;
    if (g && O) {
      if (w = a(g.semver, O.semver, m), w > 0)
        return null;
      if (w === 0 && (g.operator !== ">=" || O.operator !== "<="))
        return null;
    }
    for (const N of E) {
      if (g && !s(N, String(g), m) || O && !s(N, String(O), m))
        return null;
      for (const x of l)
        if (!s(N, String(x), m))
          return !1;
      return !0;
    }
    let _, A, U, j, C = O && !m.includePrerelease && O.semver.prerelease.length ? O.semver : !1, y = g && !m.includePrerelease && g.semver.prerelease.length ? g.semver : !1;
    C && C.prerelease.length === 1 && O.operator === "<" && C.prerelease[0] === 0 && (C = !1);
    for (const N of l) {
      if (j = j || N.operator === ">" || N.operator === ">=", U = U || N.operator === "<" || N.operator === "<=", g) {
        if (y && N.semver.prerelease && N.semver.prerelease.length && N.semver.major === y.major && N.semver.minor === y.minor && N.semver.patch === y.patch && (y = !1), N.operator === ">" || N.operator === ">=") {
          if (_ = e(g, N, m), _ === N && _ !== g)
            return !1;
        } else if (g.operator === ">=" && !s(g.semver, String(N), m))
          return !1;
      }
      if (O) {
        if (C && N.semver.prerelease && N.semver.prerelease.length && N.semver.major === C.major && N.semver.minor === C.minor && N.semver.patch === C.patch && (C = !1), N.operator === "<" || N.operator === "<=") {
          if (A = o(O, N, m), A === N && A !== O)
            return !1;
        } else if (O.operator === "<=" && !s(O.semver, String(N), m))
          return !1;
      }
      if (!N.operator && (O || g) && w !== 0)
        return !1;
    }
    return !(g && U && !O && w !== 0 || O && j && !g && w !== 0 || y || C);
  }, e = (c, l, m) => {
    if (!c)
      return l;
    const E = a(c.semver, l.semver, m);
    return E > 0 ? c : E < 0 || l.operator === ">" && c.operator === ">=" ? l : c;
  }, o = (c, l, m) => {
    if (!c)
      return l;
    const E = a(c.semver, l.semver, m);
    return E < 0 ? c : E > 0 || l.operator === "<" && c.operator === "<=" ? l : c;
  };
  return be = p, be;
}
var Me, xr;
function dt() {
  if (xr) return Me;
  xr = 1;
  const r = M(), i = k(), t = G(), s = Mr(), a = X(), p = Yr(), u = Wr(), f = zr(), n = Kr(), e = Zr(), o = Jr(), c = Qr(), l = et(), m = F(), E = rt(), g = tt(), O = Be(), w = st(), _ = nt(), A = Y(), U = Ye(), j = Hr(), C = kr(), y = We(), N = ze(), x = Br(), K = it(), Z = W(), J = V(), Q = z(), R = ot(), h = ct(), I = ut(), d = lt(), v = ft(), $ = Ke(), L = ht(), T = Et(), S = pt(), q = Rt(), D = mt();
  return Me = {
    parse: a,
    valid: p,
    clean: u,
    inc: f,
    diff: n,
    major: e,
    minor: o,
    patch: c,
    prerelease: l,
    compare: m,
    rcompare: E,
    compareLoose: g,
    compareBuild: O,
    sort: w,
    rsort: _,
    gt: A,
    lt: U,
    eq: j,
    neq: C,
    gte: y,
    lte: N,
    cmp: x,
    coerce: K,
    Comparator: Z,
    Range: J,
    satisfies: Q,
    toComparators: R,
    maxSatisfying: h,
    minSatisfying: I,
    minVersion: d,
    validRange: v,
    outside: $,
    gtr: L,
    ltr: T,
    intersects: S,
    simplifyRange: q,
    subset: D,
    SemVer: t,
    re: r.re,
    src: r.src,
    tokens: r.t,
    SEMVER_SPEC_VERSION: i.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: i.RELEASE_TYPES,
    compareIdentifiers: s.compareIdentifiers,
    rcompareIdentifiers: s.rcompareIdentifiers
  }, Me;
}
var $t = dt();
const It = {
  load: "function"
}, vt = {
  moduleApiVersion: "string",
  prototype: "object"
}, Lt = {
  default: "function"
};
function He(r, i, t) {
  if (r === null || typeof r !== i) return !1;
  for (const s in t)
    if (typeof r[s] !== t[s]) return !1;
  return !0;
}
function Nt(r) {
  return He(r, "object", Lt) && He(r.default, "function", vt) && He(r.default.prototype, "object", It);
}
class Ot extends Error {
  constructor(i) {
    super(`Plugin version ${i} is incompatible with engine version 1.4.1`);
  }
}
class gt {
  constructor(i) {
    this.api = i;
  }
  modules = [];
  started = !1;
  async load(i) {
    if (this.started)
      throw new Error("PluginEngine.start() has already been called");
    if (!Nt(i))
      throw new Error("Invalid plugin");
    if (!$t.satisfies("1.4.1", i.default.moduleApiVersion))
      throw new Ot(i.default.moduleApiVersion);
    const { default: t } = i;
    this.modules.push(new t(this.api));
  }
  async start() {
    if (this.started)
      throw new Error("PluginEngine.start() has already been called");
    this.started = !0, await Promise.all(this.modules.map((i) => i.load()));
  }
}
function St(r, i) {
  return Object.keys(r).length === Object.keys(i).length && Object.keys(r).every((t) => r[t] === i[t]);
}
function br(r) {
  return r !== null && typeof r == "object";
}
class At {
  constructor(i) {
    this.currentValue = i;
  }
  listeners = /* @__PURE__ */ new Set();
  get value() {
    return this.currentValue;
  }
  set value(i) {
    if (i !== this.currentValue && !(br(i) && br(this.currentValue) && St(this.currentValue, i))) {
      this.currentValue = i;
      for (const t of this.listeners)
        t(this.currentValue);
    }
  }
  watch(i) {
    this.listeners.add(i);
  }
  unwatch(i) {
    this.listeners.delete(i);
  }
}
function Tt(r) {
  const [i, t] = window.React.useState(r.value);
  return window.React.useEffect(() => (t(r.value), r.watch(t), () => {
    r.unwatch(t);
  }), [r]), i;
}
export {
  Ot as ModuleIncompatibleError,
  gt as ModuleLoader,
  At as Watchable,
  Tt as useWatchable
};
//# sourceMappingURL=element-web-plugin-engine.js.map
