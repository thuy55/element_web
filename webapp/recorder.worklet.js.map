{"version":3,"file":"recorder.worklet.js","mappings":"mBAAA,SAASA,EAAQC,GAGf,OAAOD,EAAU,mBAAqBE,QAAU,iBAAmBA,OAAOC,SAAW,SAAUF,GAC7F,cAAcA,CAChB,EAAI,SAAUA,GACZ,OAAOA,GAAK,mBAAqBC,QAAUD,EAAEG,cAAgBF,QAAUD,IAAMC,OAAOG,UAAY,gBAAkBJ,CACpH,EAAGD,EAAQC,EACb,CCNA,SAASK,EAAcC,GACrB,IAAIC,ECFN,SAAqBD,EAAGE,GACtB,GAAI,UAAYT,EAAQO,KAAOA,EAAG,OAAOA,EACzC,IAAIG,EAAIH,EAAEL,OAAOS,aACjB,QAAI,IAAWD,EAAG,CAChB,IAAIF,EAAIE,EAAEE,KAAKL,EAAGE,GAAK,WACvB,GAAI,UAAYT,EAAQQ,GAAI,OAAOA,EACnC,MAAM,IAAIK,UAAU,+CACtB,CACA,OAAQ,WAAaJ,EAAIK,OAASC,QAAQR,EAC5C,CDPUI,CAAYJ,EAAG,UACvB,MAAO,UAAYP,EAAQQ,GAAKA,EAAIA,EAAI,EAC1C,CEJA,SAASQ,EAAgBN,EAAGD,EAAGF,GAC7B,OAAQE,EAAIH,EAAcG,MAAOC,EAAIO,OAAOC,eAAeR,EAAGD,EAAG,CAC/DU,MAAOZ,EACPa,YAAY,EACZC,cAAc,EACdC,UAAU,IACPZ,EAAED,GAAKF,EAAGG,CACjB,CCiGO,SAASa,EAAaC,EAAQC,GAGjC,OAAO,IAAIC,MAASD,GAAQE,KAAKH,EACrC,CCjGO,IAAKI,EAAY,SAAZA,GAAY,OAAZA,EAAY,oBAAZA,EAAY,+BAAZA,CAAY,MAqBQL,EAAU,EADD,ICDlC,SAASM,EAAaL,EAAaM,EAAaC,GACnD,MAAMC,GAAcR,EAAMM,IAAQC,EAAMD,GACxC,OAAOf,OAAOkB,MAAMD,GAAc,EAAIA,CAC1C,CCRA,SAASE,EAAsBC,GAE3B,OAAOC,KAAKC,MAJmB,IAIZF,EAAUpB,OAAOuB,UAJL,EAKnC,CAOA,MAAMC,UAAuBC,sBAAsBpC,WAAAA,IAAAqC,GAAA,SAAAA,GAAAzB,EAAA,2BACjB,GAACA,EAAA,sBACN,EAAC,CAEnB0B,OAAAA,CACHC,EACAC,EACAC,GAEA,MAAMC,EAAgBZ,EAAsBa,aAO5C,GAAID,IAAkBE,KAAKC,qBAAoD,IAA7BD,KAAKC,oBAA2B,CAG9E,MAAMC,EAAWP,EAAO,GAAG,GAOrBQ,EAASf,KAAKN,OAAOoB,GAErBE,EAAYvB,EADHO,KAAKL,OAAOmB,IACa,EAAG,GAAKrB,EAAasB,GAAS,EAAG,GAEzEH,KAAKK,KAAKC,YAA+B,CACrCC,GAAI3B,EAAa4B,cACjBJ,UAAWA,EACXK,SAAUT,KAAKU,mBAEnBV,KAAKC,oBAtCNf,EAsCkDY,EAtCX,EATf,GAgD3B,CAQA,OALAE,KAAKK,KAAKC,YAA4B,CAAEC,GAAI3B,EAAa+B,SAAUC,YAAab,eAKzE,CACX,EAGJc,kBF1E4B,mBE0EItB,E","sources":["webpack://element-web/./node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://element-web/./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","webpack://element-web/./node_modules/@babel/runtime/helpers/esm/toPrimitive.js","webpack://element-web/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://element-web/./src/utils/arrays.ts","webpack://element-web/./src/audio/consts.ts","webpack://element-web/./packages/shared-components/src/utils/numbers.ts","webpack://element-web/./src/audio/RecorderWorklet.ts"],"sourcesContent":["function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };","import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nexport { _defineProperty as default };","/*\r\nCopyright 2024 New Vector Ltd.\r\nCopyright 2020, 2021 The Matrix.org Foundation C.I.C.\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\nimport { percentageOf, percentageWithin } from \"../../packages/shared-components/src/utils/numbers\";\r\n\r\n/**\r\n * Quickly resample an array to have less/more data points. If an input which is larger\r\n * than the desired size is provided, it will be downsampled. Similarly, if the input\r\n * is smaller than the desired size then it will be upsampled.\r\n * @param {number[]} input The input array to resample.\r\n * @param {number} points The number of samples to end up with.\r\n * @returns {number[]} The resampled array.\r\n */\r\nexport function arrayFastResample(input: number[], points: number): number[] {\r\n    if (input.length === points) return input; // short-circuit a complicated call\r\n\r\n    // Heavily inspired by matrix-media-repo (used with permission)\r\n    // https://github.com/turt2live/matrix-media-repo/blob/abe72c87d2e29/util/util_audio/fastsample.go#L10\r\n    const samples: number[] = [];\r\n    if (input.length > points) {\r\n        // Danger: this loop can cause out of memory conditions if the input is too small.\r\n        const everyNth = Math.round(input.length / points);\r\n        for (let i = 0; i < input.length; i += everyNth) {\r\n            samples.push(input[i]);\r\n        }\r\n    } else {\r\n        // Smaller inputs mean we have to spread the values over the desired length. We\r\n        // end up overshooting the target length in doing this, but we're not looking to\r\n        // be super accurate so we'll let the sanity trims do their job.\r\n        const spreadFactor = Math.ceil(points / input.length);\r\n        for (const val of input) {\r\n            samples.push(...arraySeed(val, spreadFactor));\r\n        }\r\n    }\r\n\r\n    // Trim to size & return\r\n    return arrayTrimFill(samples, points, arraySeed(input[input.length - 1], points));\r\n}\r\n\r\n/**\r\n * Attempts a smooth resample of the given array. This is functionally similar to arrayFastResample\r\n * though can take longer due to the smoothing of data.\r\n * @param {number[]} input The input array to resample.\r\n * @param {number} points The number of samples to end up with.\r\n * @returns {number[]} The resampled array.\r\n */\r\nexport function arraySmoothingResample(input: number[], points: number): number[] {\r\n    if (input.length === points) return input; // short-circuit a complicated call\r\n\r\n    let samples: number[] = [];\r\n    if (input.length > points) {\r\n        // We're downsampling. To preserve the curve we'll actually reduce our sample\r\n        // selection and average some points between them.\r\n\r\n        // All we're doing here is repeatedly averaging the waveform down to near our\r\n        // target value. We don't average down to exactly our target as the loop might\r\n        // never end, and we can over-average the data. Instead, we'll get as far as\r\n        // we can and do a followup fast resample (the neighbouring points will be close\r\n        // to the actual waveform, so we can get away with this safely).\r\n        while (samples.length > points * 2 || samples.length === 0) {\r\n            samples = [];\r\n            for (let i = 1; i < input.length - 1; i += 2) {\r\n                const prevPoint = input[i - 1];\r\n                const nextPoint = input[i + 1];\r\n                const currPoint = input[i];\r\n                const average = (prevPoint + nextPoint + currPoint) / 3;\r\n                samples.push(average);\r\n            }\r\n            input = samples;\r\n        }\r\n\r\n        return arrayFastResample(samples, points);\r\n    } else {\r\n        // In practice there's not much purpose in burning CPU for short arrays only to\r\n        // end up with a result that can't possibly look much different than the fast\r\n        // resample, so just skip ahead to the fast resample.\r\n        return arrayFastResample(input, points);\r\n    }\r\n}\r\n\r\n/**\r\n * Rescales the input array to have values that are inclusively within the provided\r\n * minimum and maximum.\r\n * @param {number[]} input The array to rescale.\r\n * @param {number} newMin The minimum value to scale to.\r\n * @param {number} newMax The maximum value to scale to.\r\n * @returns {number[]} The rescaled array.\r\n */\r\nexport function arrayRescale(input: number[], newMin: number, newMax: number): number[] {\r\n    const min: number = Math.min(...input);\r\n    const max: number = Math.max(...input);\r\n    return input.map((v) => percentageWithin(percentageOf(v, min, max), newMin, newMax));\r\n}\r\n\r\n/**\r\n * Creates an array of the given length, seeded with the given value.\r\n * @param {T} val The value to seed the array with.\r\n * @param {number} length The length of the array to create.\r\n * @returns {T[]} The array.\r\n */\r\nexport function arraySeed<T>(val: T, length: number): T[] {\r\n    // Size the array up front for performance, and use `fill` to let the browser\r\n    // optimize the operation better than we can with a `for` loop, if it wants.\r\n    return new Array<T>(length).fill(val);\r\n}\r\n\r\n/**\r\n * Trims or fills the array to ensure it meets the desired length. The seed array\r\n * given is pulled from to fill any missing slots - it is recommended that this be\r\n * at least `len` long. The resulting array will be exactly `len` long, either\r\n * trimmed from the source or filled with the some/all of the seed array.\r\n * @param {T[]} a The array to trim/fill.\r\n * @param {number} len The length to trim or fill to, as needed.\r\n * @param {T[]} seed Values to pull from if the array needs filling.\r\n * @returns {T[]} The resulting array of `len` length.\r\n */\r\nexport function arrayTrimFill<T>(a: T[], len: number, seed: T[]): T[] {\r\n    // Dev note: we do length checks because the spread operator can result in some\r\n    // performance penalties in more critical code paths. As a utility, it should be\r\n    // as fast as possible to not cause a problem for the call stack, no matter how\r\n    // critical that stack is.\r\n    if (a.length === len) return a;\r\n    if (a.length > len) return a.slice(0, len);\r\n    return a.concat(seed.slice(0, len - a.length));\r\n}\r\n\r\n/**\r\n * Clones an array as fast as possible, retaining references of the array's values.\r\n * @param a The array to clone. Must be defined.\r\n * @returns A copy of the array.\r\n */\r\nexport function arrayFastClone<T>(a: T[]): T[] {\r\n    return a.slice(0, a.length);\r\n}\r\n\r\n/**\r\n * Determines if the two arrays are different either in length, contents,\r\n * or order of those contents.\r\n * @param a The first array. Must be defined.\r\n * @param b The second array. Must be defined.\r\n * @returns True if they are different, false otherwise.\r\n */\r\nexport function arrayHasOrderChange(a: any[], b: any[]): boolean {\r\n    if (a.length === b.length) {\r\n        for (let i = 0; i < a.length; i++) {\r\n            if (a[i] !== b[i]) return true;\r\n        }\r\n        return false;\r\n    } else {\r\n        return true; // like arrayHasDiff, a difference in length is a natural change\r\n    }\r\n}\r\n\r\n/**\r\n * Determines if two arrays are different through a shallow comparison.\r\n * @param a The first array. Must be defined.\r\n * @param b The second array. Must be defined.\r\n * @returns True if they are different, false otherwise.\r\n */\r\nexport function arrayHasDiff(a: any[], b: any[]): boolean {\r\n    if (a.length === b.length) {\r\n        // When the lengths are equal, check to see if either array is missing\r\n        // an element from the other.\r\n        if (b.some((i) => !a.includes(i))) return true;\r\n        if (a.some((i) => !b.includes(i))) return true;\r\n\r\n        // if all the keys are common, say so\r\n        return false;\r\n    } else {\r\n        return true; // different lengths means they are naturally diverged\r\n    }\r\n}\r\n\r\nexport type Diff<T> = { added: T[]; removed: T[] };\r\n\r\n/**\r\n * Performs a diff on two arrays. The result is what is different with the\r\n * first array (`added` in the returned object means objects in B that aren't\r\n * in A). Shallow comparisons are used to perform the diff.\r\n * @param a The first array. Must be defined.\r\n * @param b The second array. Must be defined.\r\n * @returns The diff between the arrays.\r\n */\r\nexport function arrayDiff<T>(a: T[], b: T[]): Diff<T> {\r\n    return {\r\n        added: b.filter((i) => !a.includes(i)),\r\n        removed: a.filter((i) => !b.includes(i)),\r\n    };\r\n}\r\n\r\n/**\r\n * Returns the intersection of two arrays.\r\n * @param a The first array. Must be defined.\r\n * @param b The second array. Must be defined.\r\n * @returns The intersection of the arrays.\r\n */\r\nexport function arrayIntersection<T>(a: T[], b: T[]): T[] {\r\n    return a.filter((i) => b.includes(i));\r\n}\r\n\r\n/**\r\n * Unions arrays, deduping contents using a Set.\r\n * @param a The arrays to merge.\r\n * @returns The union of all given arrays.\r\n */\r\nexport function arrayUnion<T>(...a: T[][]): T[] {\r\n    return Array.from(\r\n        a.reduce((c, v) => {\r\n            v.forEach((i) => c.add(i));\r\n            return c;\r\n        }, new Set<T>()),\r\n    );\r\n}\r\n\r\n/**\r\n * Moves a single element from fromIndex to toIndex.\r\n * @param {array} list the list from which to construct the new list.\r\n * @param {number} fromIndex the index of the element to move.\r\n * @param {number} toIndex the index of where to put the element.\r\n * @returns {array} A new array with the requested value moved.\r\n */\r\nexport function moveElement<T>(list: T[], fromIndex: number, toIndex: number): T[] {\r\n    const result = Array.from(list);\r\n    const [removed] = result.splice(fromIndex, 1);\r\n    result.splice(toIndex, 0, removed);\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Helper functions to perform LINQ-like queries on arrays.\r\n */\r\nexport class ArrayUtil<T> {\r\n    /**\r\n     * Create a new array helper.\r\n     * @param a The array to help. Can be modified in-place.\r\n     */\r\n    public constructor(private a: T[]) {}\r\n\r\n    /**\r\n     * The value of this array, after all appropriate alterations.\r\n     */\r\n    public get value(): T[] {\r\n        return this.a;\r\n    }\r\n\r\n    /**\r\n     * Groups an array by keys.\r\n     * @param fn The key-finding function.\r\n     * @returns This.\r\n     */\r\n    public groupBy<K>(fn: (a: T) => K): GroupedArray<K, T> {\r\n        const obj = this.a.reduce((rv: Map<K, T[]>, val: T) => {\r\n            const k = fn(val);\r\n            if (!rv.has(k)) rv.set(k, []);\r\n            rv.get(k)!.push(val);\r\n            return rv;\r\n        }, new Map<K, T[]>());\r\n        return new GroupedArray(obj);\r\n    }\r\n}\r\n\r\n/**\r\n * Helper functions to perform LINQ-like queries on groups (maps).\r\n */\r\nexport class GroupedArray<K, T> {\r\n    /**\r\n     * Creates a new group helper.\r\n     * @param val The group to help. Can be modified in-place.\r\n     */\r\n    public constructor(private val: Map<K, T[]>) {}\r\n\r\n    /**\r\n     * The value of this group, after all applicable alterations.\r\n     */\r\n    public get value(): Map<K, T[]> {\r\n        return this.val;\r\n    }\r\n\r\n    /**\r\n     * Orders the grouping into an array using the provided key order.\r\n     * @param keyOrder The key order.\r\n     * @returns An array helper of the result.\r\n     */\r\n    public orderBy(keyOrder: K[]): ArrayUtil<T> {\r\n        const a: T[] = [];\r\n        for (const k of keyOrder) {\r\n            if (!this.val.has(k)) continue;\r\n            a.push(...this.val.get(k)!);\r\n        }\r\n        return new ArrayUtil(a);\r\n    }\r\n}\r\n\r\nexport const concat = (...arrays: Uint8Array[]): Uint8Array => {\r\n    return arrays.reduce((concatenatedSoFar: Uint8Array, toBeConcatenated: Uint8Array) => {\r\n        const concatenated = new Uint8Array(concatenatedSoFar.length + toBeConcatenated.length);\r\n        concatenated.set(concatenatedSoFar, 0);\r\n        concatenated.set(toBeConcatenated, concatenatedSoFar.length);\r\n        return concatenated;\r\n    }, new Uint8Array(0));\r\n};\r\n\r\n/**\r\n * Async version of Array.every.\r\n */\r\nexport async function asyncEvery<T>(values: Iterable<T>, predicate: (value: T) => Promise<boolean>): Promise<boolean> {\r\n    for (const value of values) {\r\n        if (!(await predicate(value))) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n/**\r\n * Async version of Array.some.\r\n */\r\nexport async function asyncSome<T>(values: Iterable<T>, predicate: (value: T) => Promise<boolean>): Promise<boolean> {\r\n    for (const value of values) {\r\n        if (await predicate(value)) return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Async version of Array.some that runs all promises in parallel.\r\n * @param values\r\n * @param predicate\r\n */\r\nexport async function asyncSomeParallel<T>(\r\n    values: Array<T>,\r\n    predicate: (value: T) => Promise<boolean>,\r\n): Promise<boolean> {\r\n    try {\r\n        return await Promise.any<boolean>(\r\n            values.map((value) =>\r\n                predicate(value).then((result) => (result ? Promise.resolve(true) : Promise.reject(false))),\r\n            ),\r\n        );\r\n    } catch (e) {\r\n        // If the array is empty or all the promises are false, Promise.any will reject an AggregateError\r\n        if (e instanceof AggregateError) return false;\r\n        throw e;\r\n    }\r\n}\r\n\r\n/**\r\n * Async version of Array.filter.\r\n * If one of the promises rejects, the whole operation will reject.\r\n * @param values\r\n * @param predicate\r\n */\r\nexport async function asyncFilter<T>(values: Array<T>, predicate: (value: T) => Promise<boolean>): Promise<Array<T>> {\r\n    const results = await Promise.all(values.map(predicate));\r\n    return values.filter((_, i) => results[i]);\r\n}\r\n\r\nexport function filterBoolean<T>(values: Array<T | null | undefined>): T[] {\r\n    return values.filter(Boolean) as T[];\r\n}\r\n","/*\r\nCopyright 2024 New Vector Ltd.\r\nCopyright 2021 The Matrix.org Foundation C.I.C.\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\nimport { arraySeed } from \"../utils/arrays\";\r\n\r\nexport const WORKLET_NAME = \"mx-voice-worklet\";\r\n\r\nexport enum PayloadEvent {\r\n    Timekeep = \"timekeep\",\r\n    AmplitudeMark = \"amplitude_mark\",\r\n}\r\n\r\nexport interface IPayload {\r\n    ev: PayloadEvent;\r\n}\r\n\r\nexport interface ITimingPayload extends IPayload {\r\n    ev: PayloadEvent.Timekeep;\r\n    timeSeconds: number;\r\n}\r\n\r\nexport interface IAmplitudePayload extends IPayload {\r\n    ev: PayloadEvent.AmplitudeMark;\r\n    forIndex: number;\r\n    amplitude: number;\r\n}\r\n\r\nexport const PLAYBACK_WAVEFORM_SAMPLES = 39;\r\nexport const DEFAULT_WAVEFORM = arraySeed(0, PLAYBACK_WAVEFORM_SAMPLES);\r\n","/*\r\nCopyright 2024 New Vector Ltd.\r\nCopyright 2021 The Matrix.org Foundation C.I.C.\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\n/**\r\n * Returns the default number if the given value, i, is not a number. Otherwise\r\n * returns the given value.\r\n * @param {*} i The value to check.\r\n * @param {number} def The default value.\r\n * @returns {number} Either the value or the default value, whichever is a number.\r\n */\r\nexport function defaultNumber(i: unknown, def: number): number {\r\n    return Number.isFinite(i) ? Number(i) : def;\r\n}\r\n\r\nexport function clamp(i: number, min: number, max: number): number {\r\n    return Math.min(Math.max(i, min), max);\r\n}\r\n\r\nexport function sum(...i: number[]): number {\r\n    return [...i].reduce((p, c) => c + p, 0);\r\n}\r\n\r\nexport function percentageWithin(pct: number, min: number, max: number): number {\r\n    return pct * (max - min) + min;\r\n}\r\n\r\nexport function percentageOf(val: number, min: number, max: number): number {\r\n    const percentage = (val - min) / (max - min);\r\n    return Number.isNaN(percentage) ? 0 : percentage;\r\n}\r\n","/*\r\nCopyrimport { type IAmplitudePayload, type ITimingPayload, PayloadEvent, WORKLET_NAME } from \"./consts\";\r\nimport { percentageOf } from \"../../packages/shared-components/src/utils/numbers\";\r\n\r\n// from AudioWorkletGlobalScope: https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletGlobalScope\" 2024 New Vector Ltd.\r\nCopyright 2021 The Matrix.org Foundation C.I.C.\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\nimport { type IAmplitudePayload, type ITimingPayload, PayloadEvent, WORKLET_NAME } from \"./consts\";\r\nimport { percentageOf } from \"../../packages/shared-components/src/utils/numbers\";\r\n\r\n// from AudioWorkletGlobalScope: https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletGlobalScope\r\ndeclare const currentTime: number;\r\n// declare const currentFrame: number;\r\n// declare const sampleRate: number;\r\n\r\n// We rate limit here to avoid overloading downstream consumers with amplitude information.\r\n// The two major consumers are the voice message waveform thumbnail (resampled down to an\r\n// appropriate length) and the live waveform shown to the user. Effectively, this controls\r\n// the refresh rate of that live waveform and the number of samples the thumbnail has to\r\n// work with.\r\nconst TARGET_AMPLITUDE_FREQUENCY = 16; // Hz\r\n\r\nfunction roundTimeToTargetFreq(seconds: number): number {\r\n    // Epsilon helps avoid floating point rounding issues (1 + 1 = 1.999999, etc)\r\n    return Math.round((seconds + Number.EPSILON) * TARGET_AMPLITUDE_FREQUENCY) / TARGET_AMPLITUDE_FREQUENCY;\r\n}\r\n\r\nfunction nextTimeForTargetFreq(roundedSeconds: number): number {\r\n    // The extra round is just to make sure we cut off any floating point issues\r\n    return roundTimeToTargetFreq(roundedSeconds + 1 / TARGET_AMPLITUDE_FREQUENCY);\r\n}\r\n\r\nclass MxVoiceWorklet extends AudioWorkletProcessor {\r\n    private nextAmplitudeSecond = 0;\r\n    private amplitudeIndex = 0;\r\n\r\n    public process(\r\n        inputs: Float32Array[][],\r\n        outputs: Float32Array[][],\r\n        parameters: Record<string, Float32Array>,\r\n    ): boolean {\r\n        const currentSecond = roundTimeToTargetFreq(currentTime);\r\n        // We special case the first ping because there's a fairly good chance that we'll miss the zeroth\r\n        // update. Firefox for instance takes 0.06 seconds (roughly) to call this function for the first\r\n        // time. Edge and Chrome occasionally lag behind too, but for the most part are on time.\r\n        //\r\n        // When this doesn't work properly we end up producing a waveform of nulls and no live preview\r\n        // of the recorded message.\r\n        if (currentSecond === this.nextAmplitudeSecond || this.nextAmplitudeSecond === 0) {\r\n            // We're expecting exactly one mono input source, so just grab the very first frame of\r\n            // samples for the analysis.\r\n            const monoChan = inputs[0][0];\r\n\r\n            // The amplitude of the frame's samples is effectively the loudness of the frame. This\r\n            // translates into a bar which can be rendered as part of the whole recording clip's\r\n            // waveform.\r\n            //\r\n            // We translate the amplitude down to 0-1 for sanity's sake.\r\n            const minVal = Math.min(...monoChan);\r\n            const maxVal = Math.max(...monoChan);\r\n            const amplitude = percentageOf(maxVal, -1, 1) - percentageOf(minVal, -1, 1);\r\n\r\n            this.port.postMessage(<IAmplitudePayload>{\r\n                ev: PayloadEvent.AmplitudeMark,\r\n                amplitude: amplitude,\r\n                forIndex: this.amplitudeIndex++,\r\n            });\r\n            this.nextAmplitudeSecond = nextTimeForTargetFreq(currentSecond);\r\n        }\r\n\r\n        // We mostly use this worklet to fire regular clock updates through to components\r\n        this.port.postMessage(<ITimingPayload>{ ev: PayloadEvent.Timekeep, timeSeconds: currentTime });\r\n\r\n        // We're supposed to return false when we're \"done\" with the audio clip, but seeing as\r\n        // we are acting as a passive processor we are never truly \"done\". The browser will clean\r\n        // us up when it is done with us.\r\n        return true;\r\n    }\r\n}\r\n\r\nregisterProcessor(WORKLET_NAME, MxVoiceWorklet);\r\n\r\nexport default \"\"; // to appease module loaders (we never use the export)\r\n"],"names":["_typeof","o","Symbol","iterator","constructor","prototype","toPropertyKey","t","i","r","e","toPrimitive","call","TypeError","String","Number","_defineProperty","Object","defineProperty","value","enumerable","configurable","writable","arraySeed","val","length","Array","fill","PayloadEvent","percentageOf","min","max","percentage","isNaN","roundTimeToTargetFreq","seconds","Math","round","EPSILON","MxVoiceWorklet","AudioWorkletProcessor","args","process","inputs","outputs","parameters","currentSecond","currentTime","this","nextAmplitudeSecond","monoChan","minVal","amplitude","port","postMessage","ev","AmplitudeMark","forIndex","amplitudeIndex","Timekeep","timeSeconds","registerProcessor"],"sourceRoot":""}