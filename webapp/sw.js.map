{"version":3,"file":"sw.js","mappings":"uEAAA,SAMC,WACG,aAEI,EAMA,WAIJ,IAAIA,EAAO,WAAY,EACnBC,EAAgB,YAChBC,SAAeC,SAAWF,UAA0BE,OAAOC,YAAcH,GACzE,kBAAkBI,KAAKF,OAAOC,UAAUE,WAGxCC,EAAa,CACb,QACA,QACA,OACA,OACA,SAGAC,EAAiB,CAAC,EAClBC,EAAgB,KAGpB,SAASC,EAAWC,EAAKC,GACrB,IAAIC,EAASF,EAAIC,GACjB,GAA2B,mBAAhBC,EAAOC,KACd,OAAOD,EAAOC,KAAKH,GAEnB,IACI,OAAOI,SAASC,UAAUF,KAAKG,KAAKJ,EAAQF,EAChD,CAAE,MAAOO,GAEL,OAAO,WACH,OAAOH,SAASC,UAAUG,MAAMA,MAAMN,EAAQ,CAACF,EAAKS,WACxD,CACJ,CAER,CAGA,SAASC,IACDC,QAAQC,MACJD,QAAQC,IAAIJ,MACZG,QAAQC,IAAIJ,MAAMG,QAASF,WAG3BL,SAASC,UAAUG,MAAMA,MAAMG,QAAQC,IAAK,CAACD,QAASF,aAG1DE,QAAQE,OAAOF,QAAQE,OAC/B,CAIA,SAASC,EAAWb,GAKhB,MAJmB,UAAfA,IACAA,EAAa,cAGNU,UAAYrB,IAEG,UAAfW,GAA0BV,EAC1BmB,OACwBK,IAAxBJ,QAAQV,GACRF,EAAWY,QAASV,QACJc,IAAhBJ,QAAQC,IACRb,EAAWY,QAAS,OAEpBtB,EAEf,CAIA,SAAS2B,IAKL,IAHA,IAAIC,EAAQC,KAAKC,WAGRC,EAAI,EAAGA,EAAIxB,EAAWyB,OAAQD,IAAK,CACxC,IAAInB,EAAaL,EAAWwB,GAC5BF,KAAKjB,GAAemB,EAAIH,EACpB5B,EACA6B,KAAKI,cAAcrB,EAAYgB,EAAOC,KAAKK,KACnD,CAMA,GAHAL,KAAKN,IAAMM,KAAKM,aAGLb,UAAYrB,GAAiB2B,EAAQC,KAAKO,OAAOC,OACxD,MAAO,kCAEf,CAIA,SAASC,EAAgC1B,GACrC,OAAO,kBACQU,UAAYrB,IACnB0B,EAAsBV,KAAKY,MAC3BA,KAAKjB,GAAYO,MAAMU,KAAMT,WAErC,CACJ,CAIA,SAASmB,EAAqB3B,EAAY4B,EAAQC,GAE9C,OAAOhB,EAAWb,IACX0B,EAAgCnB,MAAMU,KAAMT,UACvD,CAEA,SAASsB,EAAOR,EAAMS,GAEpB,IASIC,EAMAC,EAMAC,EArBAC,EAAOlB,KAuBPmB,EAAa,WAOjB,SAASC,EAAuBC,GAC5B,IAAIC,GAAa5C,EAAW2C,IAAa,UAAUE,cAEnD,UAAWjD,SAAWF,GAAkB+C,EAAxC,CAGA,IAEI,YADA7C,OAAOkD,aAAaL,GAAcG,EAEtC,CAAE,MAAOG,GAAS,CAGlB,IACInD,OAAOoD,SAASC,OACdC,mBAAmBT,GAAc,IAAMG,EAAY,GACzD,CAAE,MAAOG,GAAS,CAZwC,CAa9D,CAEA,SAASI,IACL,IAAIC,EAEJ,UAAWxD,SAAWF,GAAkB+C,EAAxC,CAEA,IACIW,EAAcxD,OAAOkD,aAAaL,EACtC,CAAE,MAAOM,GAAS,CAGlB,UAAWK,IAAgB1D,EACvB,IACI,IAAIuD,EAASrD,OAAOoD,SAASC,OACzBI,EAAaH,mBAAmBT,GAChCa,EAAWL,EAAOM,QAAQF,EAAa,MACzB,IAAdC,IACAF,EAAc,WAAWI,KACrBP,EAAOQ,MAAMH,EAAWD,EAAW5B,OAAS,IAC9C,GAEV,CAAE,MAAOsB,GAAS,CAQtB,YAJiC5B,IAA7BqB,EAAKX,OAAOuB,KACZA,OAAcjC,GAGXiC,CAzBmD,CA0B9D,CAEA,SAASM,IACL,UAAW9D,SAAWF,GAAkB+C,EAAxC,CAGA,IACI7C,OAAOkD,aAAaa,WAAWlB,EACnC,CAAE,MAAOM,GAAS,CAGlB,IACInD,OAAOoD,SAASC,OACdC,mBAAmBT,GAAc,0CACvC,CAAE,MAAOM,GAAS,CAXwC,CAY9D,CAEA,SAASa,EAAeC,GACpB,IAAIxC,EAAQwC,EAIZ,GAHqB,iBAAVxC,QAA2DF,IAArCqB,EAAKX,OAAOR,EAAMwB,iBAC/CxB,EAAQmB,EAAKX,OAAOR,EAAMwB,gBAET,iBAAVxB,GAAsBA,GAAS,GAAKA,GAASmB,EAAKX,OAAOC,OAChE,OAAOT,EAEP,MAAM,IAAIyC,UAAU,6CAA+CD,EAE3E,CAhFoB,iBAATlC,EACTc,GAAc,IAAMd,EACK,iBAATA,IAChBc,OAAatB,GAqFfqB,EAAKb,KAAOA,EAEZa,EAAKX,OAAS,CAAE,MAAS,EAAG,MAAS,EAAG,KAAQ,EAAG,KAAQ,EACvD,MAAS,EAAG,OAAU,GAE1BW,EAAKd,cAAgBU,GAAWJ,EAEhCQ,EAAKjB,SAAW,WACZ,OAAiB,MAAbgB,EACKA,EACkB,MAAhBD,EACFA,EAEAD,CAEb,EAEAG,EAAKuB,SAAW,SAAU1C,EAAO2C,GAO7B,OANAzB,EAAYqB,EAAevC,IACX,IAAZ2C,GACAtB,EAAuBH,GAIpBnB,EAAsBV,KAAK8B,EACtC,EAEAA,EAAKyB,gBAAkB,SAAU5C,GAC7BiB,EAAesB,EAAevC,GACzB8B,KACDX,EAAKuB,SAAS1C,GAAO,EAE7B,EAEAmB,EAAK0B,WAAa,WACd3B,EAAY,KACZmB,IACAtC,EAAsBV,KAAK8B,EAC/B,EAEAA,EAAK2B,UAAY,SAASH,GACtBxB,EAAKuB,SAASvB,EAAKX,OAAOuC,MAAOJ,EACrC,EAEAxB,EAAK6B,WAAa,SAASL,GACvBxB,EAAKuB,SAASvB,EAAKX,OAAOC,OAAQkC,EACtC,EAEAxB,EAAK8B,QAAU,WAMX,GALIpE,IAAkBsC,IAClBH,EAAiBuB,EAAe1D,EAAcqB,aAElDH,EAAsBV,KAAK8B,GAEvBtC,IAAkBsC,EAClB,IAAK,IAAI+B,KAAatE,EACpBA,EAAesE,GAAWD,SAGpC,EAGAjC,EAAiBuB,EACb1D,EAAgBA,EAAcqB,WAAa,QAE/C,IAAIiD,EAAerB,IACC,MAAhBqB,IACAjC,EAAYqB,EAAeY,IAE/BpD,EAAsBV,KAAK8B,EAC7B,EAQAtC,EAAgB,IAAIiC,GAENsC,UAAY,SAAmB9C,GACzC,GAAqB,iBAATA,GAAqC,iBAATA,GAA+B,KAATA,EAC1D,MAAM,IAAImC,UAAU,kDAGxB,IAAIY,EAASzE,EAAe0B,GAO5B,OANK+C,IACDA,EAASzE,EAAe0B,GAAQ,IAAIQ,EAChCR,EACAzB,EAAcwB,gBAGfgD,CACX,EAGA,IAAIC,SAAe/E,SAAWF,EAAiBE,OAAOoB,SAAMG,EAiB5D,OAhBAjB,EAAc0E,WAAa,WAMvB,cALWhF,SAAWF,GACfE,OAAOoB,MAAQd,IAClBN,OAAOoB,IAAM2D,GAGVzE,CACX,EAEAA,EAAc2E,WAAa,WACvB,OAAO5E,CACX,EAGAC,EAAuB,QAAIA,EAEpBA,CACX,OA3VyB,6DAMzB,CATA,E,GCLI4E,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqB7D,IAAjB8D,EACH,OAAOA,EAAaC,QAGrB,IAAIC,EAASL,EAAyBE,GAAY,CAGjDE,QAAS,CAAC,GAOX,OAHAE,EAAoBJ,GAAUtE,KAAKyE,EAAOD,QAASC,EAAQA,EAAOD,QAASH,GAGpEI,EAAOD,OACf,CCrBAH,EAAoBM,EAAKF,IACxB,IAAIG,EAASH,GAAUA,EAAOI,WAC7B,IAAOJ,EAAiB,QACxB,IAAM,EAEP,OADAJ,EAAoBS,EAAEF,EAAQ,CAAEG,EAAGH,IAC5BA,GCLRP,EAAoBS,EAAI,CAACN,EAASQ,KACjC,IAAI,IAAIC,KAAOD,EACXX,EAAoBa,EAAEF,EAAYC,KAASZ,EAAoBa,EAAEV,EAASS,IAC5EE,OAAOC,eAAeZ,EAASS,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3EZ,EAAoBkB,EAAI,WACvB,GAA0B,iBAAfC,WAAyB,OAAOA,WAC3C,IACC,OAAO5E,MAAQ,IAAId,SAAS,cAAb,EAChB,CAAE,MAAOG,GACR,GAAsB,iBAAXf,OAAqB,OAAOA,MACxC,CACA,CAPuB,GCAxBmF,EAAoBa,EAAI,CAACxF,EAAK+F,IAAUN,OAAOpF,UAAU2F,eAAe1F,KAAKN,EAAK+F,GCAlF,MACE,QAAmC,IAAxBpB,EAAqC,CAC9C,IAAIsB,EAAetB,EAAoBuB,EACnCC,EAAgBxB,EAAoBpE,EACpC6F,EAAW,CAAC,EACZC,EAAW,CAAC,EAIhB1B,EAAoBuB,EAAI,SAAUI,GAEhC,OADaL,EAAaK,IAGvBF,EAASJ,eAAeM,GAAW,IAAMF,EAASE,GAAW,GAElE,EACA3B,EAAoBpE,EAAI,SAAU+F,GAEhC,OADaH,EAAcG,GACbC,MAAM,SAAUC,GAC5B,IAAIC,EAAUJ,EAASL,eAAeM,GAAWD,EAASC,GAAW,EACrE,GAAIG,EAAU,EAAG,CACf,IAAIC,EAAUT,EAAaK,GAQ3B,MAPAE,EAAMG,QACJ,iBACAL,EACA,8BACAI,EACA,IACFF,EAAMI,QAAUF,EACVF,CACR,CACA,OAAO,IAAIK,QAAQ,SAAUC,GAE3BC,WAAW,WACT,IACIC,EAAmBC,KAAKC,MAE5Bd,EAASE,GAAWU,EACpBX,EAASC,GAAWG,EAAU,EAC9BK,EAAQnC,EAAoBpE,EAAE+F,GAChC,EAjCG,IAkCL,EACF,EACF,CACF,CACD,EA7CD,G,mBCaO,SAASa,IAKZ,IAAI,IAAAC,EAIA,OAAW,QAAJA,EAAAhF,YAAI,IAAAgF,GAAJA,EAAMC,UAAYjF,KAAKiF,UAAY7H,OAAO6H,SACrD,CAAE,MAAO,CACb,CAEA,IAAIC,EAA0B,KAE9BC,eAAeC,IACX,IAAKL,IACD,MAAM,IAAIM,MAAM,2BAEpBH,QAAY,IAAIT,QAAQ,CAACC,EAASY,KAC9B,MAAMd,EAAUO,IAAiBQ,KAAK,mBAAoB,GAC1Df,EAAQgB,QAAUF,EAClBd,EAAQiB,UAAY,KAChBf,EAAQF,EAAQkB,SAEpBlB,EAAQmB,gBAAkB,KACtB,MAAMC,EAAKpB,EAAQkB,OACnBE,EAAGC,kBAAkB,aACrBD,EAAGC,kBAAkB,aAGjC,CAEAV,eAAeW,EACXC,EACAC,EACAC,GAKA,OAHKf,SACKE,IAEH,IAAIX,QAAQ,CAACC,EAASY,KACzB,MAAMY,EAAMhB,EAAKiB,YAAY,CAACJ,GAAQC,GACtCE,EAAIV,QAAUF,EAEd,MAAMc,EAAcF,EAAIE,YAAYL,GAC9BvB,EAAUyB,EAAGG,GACnB5B,EAAQgB,QAAUF,EAClBd,EAAQiB,UAAY,KAChBf,EAAQF,EAAQkB,UAG5B,CAWOP,eAAekB,EAAQN,EAAe5C,GAIzC,OAHK+B,SACKE,IAEHU,EAAeC,EAAO,WAAaK,GAAgBA,EAAY5C,IAAIL,GAC9E,C,4DCiBAmD,IAAAA,cAAyB,SAAUzI,EAAY0I,EAAUC,GACrD,OAAO,YAAmCC,GAElC3H,KAAK4H,QACLD,EAAKE,QAAQ7H,KAAK4H,QAUtB,MANmB,UAAf7I,GACe,SAAfA,GACe,UAAfA,GACe,SAAfA,GACe,UAAfA,EAGOU,QAAQV,MAAe4I,GAEvBlI,QAAQC,OAAOiI,EAG9B,CACJ,EA+CO,MAAMvE,EA/Bb,SAAS0E,EAAkBF,GACvB,MAAMF,EA7CgB,eA6C6B7H,IAAX+H,EAAuB,GAAK,IAAIA,KAClEG,EAAeP,IAAAA,UAAmBE,GAmBxC,YAjB8B7H,IAA1BkI,EAAaC,WAEbD,EAAaH,OAASA,EACtBG,EAAaC,SAAYC,IAErB,MAAMC,EAAcJ,GAAmBF,QAAAA,EAAU,IAAMK,GAOvD,OAHAC,EAAY9H,cAAgB2H,EAAa3H,cAEzC8H,EAAYlF,UACLkF,GAEXH,EAAatF,SAAS+E,IAAAA,OAAgBW,OAAO,IAG1CJ,CACX,CASsBD,GClJtB,SAASM,EAASC,EAAwBC,GACtC,GAAmC,mBAAxBD,EAAWD,SAIlB,OAAOC,EAAWD,SAASE,GAG/B,IAAIC,EAASC,KAAKH,EAAWI,OAAO,CAACC,EAAKC,IAAYD,EAAME,OAAOC,aAAaF,GAAU,KAQ1F,OAPIL,EAAQQ,cACRP,EAASA,EAAOQ,QAAQ,UAAW,KAEd,cAArBT,EAAQU,WACRT,EAASA,EAAOQ,QAAQ,MAAO,KAAKA,QAAQ,MAAO,MAGhDR,CACX,CA6CO,SAASU,EAAaV,GAEzB,OAlBJ,SAAoBA,EAAgBD,GAChC,MAAqC,mBAA1BY,WAAWC,WAIXD,WAAWC,WAAWZ,EAAQD,GAGlCY,WAAWE,KAAKC,KAAKd,GAAUe,GAAMA,EAAEC,WAAW,GAC7D,CASWJ,CAAWZ,EAAOQ,QAAQ,KAAM,KAAKA,QAAQ,KAAM,KAAM,CAAEC,SAAU,SAAUQ,kBAAmB,SAC7G,CCpEA,MAAMC,EAAW,IAAIP,WAAW,GCYjB7C,eAAeqD,EAC1BC,EACAtF,EACAhE,GAEA,MAAOuJ,EAAQC,SDPZxD,eAA0BhC,EAAiBhE,GAC9C,MAAMyJ,QAAgBlF,WAAWmF,OAAOC,OAAOC,UAAU,MAAO5F,EAAK,CAAEhE,KAAM,SAAU,EAAO,CAAC,eACzF6J,QAAgBtF,WAAWmF,OAAOC,OAAOG,WAC3C,CACI9J,KAAM,OACN+J,KAAMX,EAGNY,MAAM,IAAIC,aAAcC,OAAOlK,GAC/BmK,KAAM,WAEVV,EACA,KAGEF,EAASM,EAAQ/H,MAAM,EAAG,IAC1B0H,EAAUK,EAAQ/H,MAAM,IAExBsI,EAAU7F,WAAWmF,OAAOC,OAAOC,UAAU,MAAOL,EAAQ,CAAEvJ,KAAM,YAAa,EAAO,CAC1F,UACA,YAGEqK,EAAW9F,WAAWmF,OAAOC,OAAOC,UACtC,MACAJ,EACA,CACIxJ,KAAM,OACNmK,KAAM,CAAEnK,KAAM,aAElB,EACA,CAAC,OAAQ,WAGb,OAAOsF,QAAQgF,IAAI,CAACF,EAASC,GACjC,CC5BoCE,CAAWvG,EAAKhE,GAE1CwK,EAAa5B,EAAaU,EAAKkB,YAErC,UAAYjG,WAAWmF,OAAOC,OAAOc,OAAO,CAAEzK,KAAM,QAAUwJ,EAASZ,EAAaU,EAAKoB,KAAMF,GAC3F,MAAM,IAAItE,MAAM,2BAA2BlG,cAG/C,MAAM2K,QAAkBpG,WAAWmF,OAAOC,OAAOiB,QAC7C,CACI5K,KAAM,UACN6K,QAASjC,EAAaU,EAAKwB,IAC3BhL,OAAQ,IAEZyJ,EACAiB,GAGJ,OAAO,IAAIO,aAAcC,OAAO,IAAInC,WAAW8B,GACnD,CC/BO,MAMMM,EAAkB,eAa/BjF,eAAekF,EAAkBC,GAC7B,MAAMC,EAAkB,IAAIvC,WAAWsC,EAAUrL,QACjD,IAAK,IAAID,EAAI,EAAGA,EAAIsL,EAAUrL,OAAQD,IAClCuL,EAAgBvL,GAAKsL,EAAUjC,WAAWrJ,GAE9C,MAAMwL,QAAgB3B,OAAOC,OAAOC,UAAU,MAAOwB,EAAiB,QAAQ,EAAO,CAAC,eAEtF,OADAA,EAAgBE,KAAK,GACd,IAAIzC,iBACDa,OAAOC,OAAOG,WAChB,CACI9J,KAAM,OACNmK,KAAM,UAGNJ,KAAM,IAAIlB,WAAW,IACrBmB,KAAM,IAAInB,WAAW,IAEzBwC,EACA,KAGZ,CCZO,SAASE,EAAwBC,EAAgBC,GACpD,MAAMC,EAAiB,IAAI7C,WAAW2C,EAAO1L,OAAS2L,EAAS3L,OAAS,GACxE,IAAK,IAAID,EAAI,EAAGA,EAAI2L,EAAO1L,OAAQD,IAC/B6L,EAAe7L,GAAK2L,EAAOtC,WAAWrJ,GAE1C6L,EAAeF,EAAO1L,QAAU,IAChC,IAAK,IAAID,EAAI,EAAGA,EAAI4L,EAAS3L,OAAQD,IACjC6L,EAAeF,EAAO1L,OAAS,EAAID,GAAK4L,EAASvC,WAAWrJ,GAEhE,OAAO6L,CACX,CAwCO1F,eAAe2F,EAClBrC,EACAkC,EACAC,GAC2B,IAAAG,EAC3B,GAAW,QAAPA,EAAClC,cAAM,IAAAkC,GAANA,EAAQjC,SAGRL,GAASA,EAAKuC,WAAcvC,EAAKwB,IAAOxB,EAAKwC,WAIlD,IACI,MAAMJ,EAAiBH,EAAwBC,EAAQC,GACjDM,QAAqBrC,OAAOC,OAAOiB,QACrC,CAAE5K,KAAM,UAAW8K,GAAIxB,EAAKwB,GAAIY,kBAChCpC,EAAKwC,UACLxC,EAAKuC,WAET,GAAIE,EACA,OJlEDhE,EIkE6B,IAAIc,WAAWkD,GJlEvB,CAAEpD,SAAU,SAAUF,aAAa,GIoE/D,CAAE,MACE1F,EAAOkC,MAAM,8BACjB,CAGJ,CCpHA,MAAM+G,EAKF,CAAC,EAoKL,SAASC,EAAoBC,GACzB,GAAKA,EAIL,MAAO,CACHC,QAAS,CACLC,cAAe,UAAUF,KAGrC,CA5KAG,EAAAA,EAAOC,iBAAiB,UAAYC,IAGhCA,EAAMC,UAAUC,iBAGpBJ,EAAAA,EAAOC,iBAAiB,WAAaC,IAGjCA,EAAMC,UAAUE,QAAQC,WAM5BN,EAAAA,EAAOC,iBAAiB,QAAUC,IAG9B,GAA6B,QAAzBA,EAAMlH,QAAQ1G,OACd,OAKJ,MAAMiO,EAAM,IAAIC,IAAIN,EAAMlH,QAAQuH,MAM7BA,EAAIE,SAASC,WAAW,+BACxBH,EAAIE,SAASC,WAAW,iCAO7BR,EAAMS,YACF,OAAChH,IACG,IAAIiH,EACJ,IAEI,MAAMC,EAAQN,EAAIO,aAGZ,IAAI7H,QAAeC,GAAYC,WAAW,IAAMD,IAA2B,GAAhB6H,KAAKC,WAItE,MAAMC,QAAejB,EAAAA,EAAOK,QAAQrI,IAAIkI,EAAMgB,UAC9CN,QAkDhBjH,eAA2BsH,GAGvB,MAAME,QAA6BtG,EAAQ,UAAW,oBAIhD,OAAEsE,EAAM,SAAEC,EAAQ,WAAEgC,SAoB9BzH,eACIsH,GAEA,OAAO,IAAIhI,QAAQ,CAACC,EAASY,KAWzB,MAAMuH,EAAYlI,WAAW,IAAMW,EAAO,IAAID,MAAM,2BAA4B,KAI1EyH,EAAcP,KAAKC,SAASO,SAAS,IAGrCC,EAAYtB,IAA8B,IAAAuB,GAC9B,QAAVA,EAAAvB,EAAMjD,YAAI,IAAAwE,OAAA,EAAVA,EAAYH,eAAgBA,IAChCI,aAAaL,GACbnI,EAAQgH,EAAMjD,MACd+C,EAAAA,EAAO2B,oBAAoB,UAAWH,KAE1CxB,EAAAA,EAAOC,iBAAiB,UAAWuB,GAGlCP,EAAkBW,YAAY,CAAEN,cAAaO,KAAM,cAE5D,CApDmDC,CAAyBb,GAGlEc,QAAsBlH,EAAQ,YAAa,CAACsE,EAAQC,IAC1D,GAAI2C,KAAmBA,EAAcvC,YAAcuC,EAActD,KAAOsD,EAActC,WAClF,MAAM,IAAI5F,MAAM,4CAIpB,IACI,MAAMiF,QAAkBQ,EAAwByC,EAAe5C,EAAQC,GACjES,QFzDPlG,eACHmF,EACAkD,EACAC,GAEA,GAAqB,iBAAVD,EAEP,OAAOA,EAIX,IAAKlD,EACD,MAAM,IAAIjF,MAAM,2BAA2BoI,2BAG/C,MAAMC,QAAgBrD,EAAkBC,GAClCqD,QAAuBnF,EAA4BgF,EAAOE,EAASD,GAEzE,OADAC,EAAQjD,KAAK,GACNkD,CACX,CEsCkCC,CAAgBtD,EAAWqC,EAAsBvC,GAC3E,MAAO,CAAEiB,cAAauB,aAC1B,CAAE,MAAOzO,GACL,MAAM,IAAIkH,MAAM,qCAAsC,CAAEwI,MAAO1P,GACnE,CACJ,CAzE6B2P,CAAYrB,GAIzB,KAD8BV,EAAIO,SAAW,IAAIN,IAAII,EAAKQ,YAAYN,QAElE,MAAM,IAAIjH,MAAM,wEAwBpCF,eAAyC4I,EAAsB1C,GAAqC,IAAA2C,EAAAC,EAEhG,IAAkC,QAA9BD,EAAA7C,EAAiB4C,UAAa,IAAAC,OAAA,EAA9BA,EAAgCE,oBAAoB,IAAIrJ,MAAOsJ,UAC/D,OAGJ,MAAMC,EAAShD,EAAoBC,GAC7BgD,cAAwBC,MAAM,GAAGP,4BAAwCK,IAASG,OACxFhQ,QAAQC,IAAI,2CAA2CuP,OAAkBS,KAAKC,UAAUJ,MAExFlD,EAAiB4C,GAAgB,CAC7BW,oBAAqBC,QAAQN,SAAkB,QAAVJ,EAARI,EAAUA,gBAAQ,IAAAJ,OAAA,EAAlBA,EAAoBW,SAAS,UAC1DV,mBAAmB,IAAIrJ,MAAOsJ,UAAY,MAE9C5P,QAAQC,IACJ,gDAAgDuP,OAAkBS,KAAKC,UAAUtD,EAAiB4C,MAE1G,CArCsBc,CAA0BxC,EAAOD,EAAKf,aAGxCF,EAAiBkB,GAAOqC,qBAAuBtC,EAAKf,cACpDU,EAAI+C,KAAO/C,EAAI+C,KAAKjH,QAAQ,sBAAuB,wBAE3D,CAAE,MAAOkH,GAEL3C,OAAOzN,EACPJ,QAAQ6F,MAAM,gCAAiC2K,EACnD,CAKA,OAAOT,MAAMvC,EAAKX,EAAwB,QAAL4D,EAAC5C,SAAI,IAAA4C,OAAA,EAAJA,EAAM3D,aAC/C,EArCD,K","sources":["webpack://element-web/./node_modules/loglevel/lib/loglevel.js","webpack://element-web/webpack/bootstrap","webpack://element-web/webpack/runtime/compat get default export","webpack://element-web/webpack/runtime/define property getters","webpack://element-web/webpack/runtime/global","webpack://element-web/webpack/runtime/hasOwnProperty shorthand","webpack://element-web/webpack/runtime/compat","webpack://element-web/./src/utils/StorageAccess.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/logger.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/base64.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/utils/internal/deriveKeys.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/utils/decryptAESSecretStorageItem.ts","webpack://element-web/./src/utils/tokens/tokens.ts","webpack://element-web/./src/utils/tokens/pickling.ts","webpack://element-web/./src/serviceworker/index.ts"],"sourcesContent":["/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    var _loggersByName = {};\n    var defaultLogger = null;\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods() {\n        /*jshint validthis:true */\n        var level = this.getLevel();\n\n        // Replace the actual methods.\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, this.name);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n\n        // Return any important warnings.\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\n            return \"No console available for logging\";\n        }\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, _level, _loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, factory) {\n      // Private instance variables.\n      var self = this;\n      /**\n       * The level inherited from a parent logger (or a global default). We\n       * cache this here rather than delegating to the parent so that it stays\n       * in sync with the actual logging methods that we have installed (the\n       * parent could change levels but we might not have rebuilt the loggers\n       * in this child yet).\n       * @type {number}\n       */\n      var inheritedLevel;\n      /**\n       * The default level for this logger, if any. If set, this overrides\n       * `inheritedLevel`.\n       * @type {number|null}\n       */\n      var defaultLevel;\n      /**\n       * A user-specific level for this logger. If set, this overrides\n       * `defaultLevel`.\n       * @type {number|null}\n       */\n      var userLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var cookieName = encodeURIComponent(storageKey);\n                  var location = cookie.indexOf(cookieName + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(\n                          cookie.slice(location + cookieName.length + 1)\n                      )[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      function normalizeLevel(input) {\n          var level = input;\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              return level;\n          } else {\n              throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n          }\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          if (userLevel != null) {\n            return userLevel;\n          } else if (defaultLevel != null) {\n            return defaultLevel;\n          } else {\n            return inheritedLevel;\n          }\n      };\n\n      self.setLevel = function (level, persist) {\n          userLevel = normalizeLevel(level);\n          if (persist !== false) {  // defaults to true\n              persistLevelIfPossible(userLevel);\n          }\n\n          // NOTE: in v2, this should call rebuild(), which updates children.\n          return replaceLoggingMethods.call(self);\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = normalizeLevel(level);\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          userLevel = null;\n          clearPersistedLevel();\n          replaceLoggingMethods.call(self);\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      self.rebuild = function () {\n          if (defaultLogger !== self) {\n              inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n          }\n          replaceLoggingMethods.call(self);\n\n          if (defaultLogger === self) {\n              for (var childName in _loggersByName) {\n                _loggersByName[childName].rebuild();\n              }\n          }\n      };\n\n      // Initialize all the internal levels.\n      inheritedLevel = normalizeLevel(\n          defaultLogger ? defaultLogger.getLevel() : \"WARN\"\n      );\n      var initialLevel = getPersistedLevel();\n      if (initialLevel != null) {\n          userLevel = normalizeLevel(initialLevel);\n      }\n      replaceLoggingMethods.call(self);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    defaultLogger = new Logger();\n\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n            throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n            logger = _loggersByName[name] = new Logger(\n                name,\n                defaultLogger.methodFactory\n            );\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","(() => {\n  if (typeof __webpack_require__ !== 'undefined') {\n    var oldGetScript = __webpack_require__.u;\n    var oldLoadScript = __webpack_require__.e;\n    var queryMap = {};\n    var countMap = {};\n    var getRetryDelay = function () {\n      return 500;\n    };\n    __webpack_require__.u = function (chunkId) {\n      var result = oldGetScript(chunkId);\n      return (\n        result +\n        (queryMap.hasOwnProperty(chunkId) ? '?' + queryMap[chunkId] : '')\n      );\n    };\n    __webpack_require__.e = function (chunkId) {\n      var result = oldLoadScript(chunkId);\n      return result.catch(function (error) {\n        var retries = countMap.hasOwnProperty(chunkId) ? countMap[chunkId] : 3;\n        if (retries < 1) {\n          var realSrc = oldGetScript(chunkId);\n          error.message =\n            'Loading chunk ' +\n            chunkId +\n            ' failed after 3 retries.\\n(' +\n            realSrc +\n            ')';\n          error.request = realSrc;\n          throw error;\n        }\n        return new Promise(function (resolve) {\n          var retryAttempt = 3 - retries + 1;\n          setTimeout(function () {\n            var retryAttemptString = '&retry-attempt=' + retryAttempt;\n            var cacheBust = (() => Date.now())();\n            +retryAttemptString;\n            queryMap[chunkId] = cacheBust;\n            countMap[chunkId] = retries - 1;\n            resolve(__webpack_require__.e(chunkId));\n          }, getRetryDelay(retryAttempt));\n        });\n      });\n    };\n  }\n})();\n","/*\r\nCopyright 2024 New Vector Ltd.\r\nCopyright 2019-2021 , 2024 The Matrix.org Foundation C.I.C.\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\n/**\r\n * Retrieves the IndexedDB factory object.\r\n *\r\n * @returns {IDBFactory | undefined} The IndexedDB factory object if available, or undefined if it is not supported.\r\n */\r\nexport function getIDBFactory(): IDBFactory | undefined {\r\n    // IndexedDB loading is lazy for easier testing.\r\n\r\n    // just *accessing* _indexedDB throws an exception in firefox with\r\n    // indexeddb disabled.\r\n    try {\r\n        // `self` is preferred for service workers, which access this file's functions.\r\n        // We check `self` first because `window` returns something which doesn't work for service workers.\r\n        // Note: `self?.indexedDB ?? window.indexedDB` breaks in service workers for unknown reasons.\r\n        return self?.indexedDB ? self.indexedDB : window.indexedDB;\r\n    } catch {}\r\n}\r\n\r\nlet idb: IDBDatabase | null = null;\r\n\r\nasync function idbInit(): Promise<void> {\r\n    if (!getIDBFactory()) {\r\n        throw new Error(\"IndexedDB not available\");\r\n    }\r\n    idb = await new Promise((resolve, reject) => {\r\n        const request = getIDBFactory()!.open(\"matrix-react-sdk\", 1);\r\n        request.onerror = reject;\r\n        request.onsuccess = (): void => {\r\n            resolve(request.result);\r\n        };\r\n        request.onupgradeneeded = (): void => {\r\n            const db = request.result;\r\n            db.createObjectStore(\"pickleKey\");\r\n            db.createObjectStore(\"account\");\r\n        };\r\n    });\r\n}\r\n\r\nasync function idbTransaction(\r\n    table: string,\r\n    mode: IDBTransactionMode,\r\n    fn: (objectStore: IDBObjectStore) => IDBRequest<any>,\r\n): Promise<any> {\r\n    if (!idb) {\r\n        await idbInit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n        const txn = idb!.transaction([table], mode);\r\n        txn.onerror = reject;\r\n\r\n        const objectStore = txn.objectStore(table);\r\n        const request = fn(objectStore);\r\n        request.onerror = reject;\r\n        request.onsuccess = (): void => {\r\n            resolve(request.result);\r\n        };\r\n    });\r\n}\r\n\r\n/**\r\n * Loads an item from an IndexedDB table within the underlying `matrix-react-sdk` database.\r\n *\r\n * If IndexedDB access is not supported in the environment, an error is thrown.\r\n *\r\n * @param {string} table The name of the object store in IndexedDB.\r\n * @param {string | string[]} key The key where the data is stored.\r\n * @returns {Promise<any>} A promise that resolves with the retrieved item from the table.\r\n */\r\nexport async function idbLoad(table: string, key: string | string[]): Promise<any> {\r\n    if (!idb) {\r\n        await idbInit();\r\n    }\r\n    return idbTransaction(table, \"readonly\", (objectStore) => objectStore.get(key));\r\n}\r\n\r\n/**\r\n * Saves data to an IndexedDB table within the underlying `matrix-react-sdk` database.\r\n *\r\n * If IndexedDB access is not supported in the environment, an error is thrown.\r\n *\r\n * @param {string} table The name of the object store in the IndexedDB.\r\n * @param {string|string[]} key The key to use for storing the data.\r\n * @param {*} data The data to be saved.\r\n * @returns {Promise<void>} A promise that resolves when the data is saved successfully.\r\n */\r\nexport async function idbSave(table: string, key: string | string[], data: any): Promise<void> {\r\n    if (!idb) {\r\n        await idbInit();\r\n    }\r\n    return idbTransaction(table, \"readwrite\", (objectStore) => objectStore.put(data, key));\r\n}\r\n\r\n/**\r\n * Deletes a record from an IndexedDB table within the underlying `matrix-react-sdk` database.\r\n *\r\n * If IndexedDB access is not supported in the environment, an error is thrown.\r\n *\r\n * @param {string} table The name of the object store where the record is stored.\r\n * @param {string|string[]} key The key of the record to be deleted.\r\n * @returns {Promise<void>} A Promise that resolves when the record(s) have been successfully deleted.\r\n */\r\nexport async function idbDelete(table: string, key: string | string[]): Promise<void> {\r\n    if (!idb) {\r\n        await idbInit();\r\n    }\r\n    return idbTransaction(table, \"readwrite\", (objectStore) => objectStore.delete(key));\r\n}\r\n\r\n/**\r\n * Clears all records from an IndexedDB table within the underlying `matrix-react-sdk` database.\r\n *\r\n * If IndexedDB access is not supported in the environment, an error is thrown.\r\n *\r\n * @param {string} table The name of the object store where the records are stored.\r\n * @returns {Promise<void>} A Promise that resolves when the record(s) have been successfully deleted.\r\n */\r\nexport async function idbClear(table: string): Promise<void> {\r\n    if (!idb) {\r\n        await idbInit();\r\n    }\r\n    return idbTransaction(table, \"readwrite\", (objectStore) => objectStore.clear());\r\n}\r\n","/*\nCopyright 2018 AndrÃ© Jaenisch\nCopyright 2019-2025 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport loglevel from \"loglevel\";\n\n/** Backwards-compatibility hack to expose `log` to applications that might still be relying on it. */\ninterface LoggerWithLogMethod extends Logger {\n    /**\n     * Output debug message to the logger.\n     *\n     * @param msg - Data to log.\n     *\n     * @deprecated prefer {@link Logger.debug}.\n     */\n    log(...msg: any[]): void;\n}\n\n/** Logger interface used within the js-sdk codebase */\nexport interface Logger extends BaseLogger {\n    /**\n     * Create a child logger.\n     *\n     * This child will use the `methodFactory` of the parent, so any log extensions applied to the parent\n     * at the time of calling `getChild` will be applied to the child as well.\n     * It will NOT apply changes to the parent's `methodFactory` after the child was created.\n     * Those changes need to be applied to the child manually.\n     *\n     * @param namespace - name to add to the current logger to generate the child. Some implementations of `Logger`\n     *    use this as a prefix; others use a different mechanism.\n     */\n    getChild(namespace: string): Logger;\n}\n\n/** The basic interface for a logger which doesn't support children */\nexport interface BaseLogger {\n    /**\n     * Output trace message to the logger, with stack trace.\n     *\n     * @param msg - Data to log.\n     */\n    trace(...msg: any[]): void;\n\n    /**\n     * Output debug message to the logger.\n     *\n     * @param msg - Data to log.\n     */\n    debug(...msg: any[]): void;\n\n    /**\n     * Output info message to the logger.\n     *\n     * @param msg - Data to log.\n     */\n    info(...msg: any[]): void;\n\n    /**\n     * Output warn message to the logger.\n     *\n     * @param msg - Data to log.\n     */\n    warn(...msg: any[]): void;\n\n    /**\n     * Output error message to the logger.\n     *\n     * @param msg - Data to log.\n     */\n    error(...msg: any[]): void;\n}\n\n// This is to demonstrate, that you can use any namespace you want.\n// Namespaces allow you to turn on/off the logging for specific parts of the\n// application.\n// An idea would be to control this via an environment variable (on Node.js).\n// See https://www.npmjs.com/package/debug to see how this could be implemented\n// Part of #332 is introducing a logging library in the first place.\nconst DEFAULT_NAMESPACE = \"matrix\";\n\n// because rageshakes in react-sdk hijack the console log, also at module load time,\n// initializing the logger here races with the initialization of rageshakes.\n// to avoid the issue, we override the methodFactory of loglevel that binds to the\n// console methods at initialization time by a factory that looks up the console methods\n// when logging so we always get the current value of console methods.\nloglevel.methodFactory = function (methodName, logLevel, loggerName) {\n    return function (this: PrefixedLogger, ...args): void {\n        /* eslint-disable @typescript-eslint/no-invalid-this */\n        if (this.prefix) {\n            args.unshift(this.prefix);\n        }\n        /* eslint-enable @typescript-eslint/no-invalid-this */\n        const supportedByConsole =\n            methodName === \"error\" ||\n            methodName === \"warn\" ||\n            methodName === \"trace\" ||\n            methodName === \"info\" ||\n            methodName === \"debug\";\n        /* eslint-disable no-console */\n        if (supportedByConsole) {\n            return console[methodName](...args);\n        } else {\n            return console.log(...args);\n        }\n        /* eslint-enable no-console */\n    };\n};\n\n/**\n * Implementation of {@link Logger} based on `loglevel`.\n */\ninterface PrefixedLogger extends loglevel.Logger, LoggerWithLogMethod {\n    prefix?: string;\n}\n\n/**\n * Internal utility function: gets a {@link Logger} based on `loglevel`.\n *\n * Child loggers produced by {@link Logger.getChild} add the name of the child logger as a prefix on each log line.\n *\n * @param prefix Prefix to add to each logged line. If undefined, no prefix will be added.\n */\nfunction getPrefixedLogger(prefix?: string): PrefixedLogger {\n    const loggerName = DEFAULT_NAMESPACE + (prefix === undefined ? \"\" : `-${prefix}`);\n    const prefixLogger = loglevel.getLogger(loggerName) as PrefixedLogger;\n\n    if (prefixLogger.getChild === undefined) {\n        // This is a new loglevel Logger which has not been turned into a PrefixedLogger yet.\n        prefixLogger.prefix = prefix;\n        prefixLogger.getChild = (childPrefix): Logger => {\n            // create the new child logger\n            const childLogger = getPrefixedLogger((prefix ?? \"\") + childPrefix);\n            // Assign the methodFactory from the parent logger.\n            // This is useful if we add extensions to the parent logger that modifies\n            // its methodFactory. (An example extension is: storing each log to a rageshake db)\n            childLogger.methodFactory = prefixLogger.methodFactory;\n            // Rebuild the child logger with the new methodFactory.\n            childLogger.rebuild();\n            return childLogger;\n        };\n        prefixLogger.setLevel(loglevel.levels.DEBUG, false);\n    }\n\n    return prefixLogger;\n}\n\n/**\n * Drop-in replacement for `console` using {@link https://www.npmjs.com/package/loglevel|loglevel}.\n * Can be tailored down to specific use cases if needed.\n *\n * @deprecated avoid the use of this unless you are the constructor of `MatrixClient`: you should be using the logger\n *    associated with `MatrixClient`.\n */\nexport const logger = getPrefixedLogger() as LoggerWithLogMethod;\n\n/**\n * A \"span\" for grouping related log lines together.\n *\n * The current implementation just adds the name at the start of each log line.\n *\n * This offers a lighter-weight alternative to 'child' loggers returned by {@link Logger#getChild}. In particular,\n * it's not possible to apply individual filters to the LogSpan such as setting the verbosity level. On the other hand,\n * no reference to the LogSpan is retained in the logging framework, so it is safe to make lots of them over the course\n * of an application's life and just drop references to them when the job is done.\n */\nexport class LogSpan implements BaseLogger {\n    private readonly name;\n\n    public constructor(\n        private readonly parent: BaseLogger,\n        name: string,\n    ) {\n        this.name = name + \":\";\n    }\n\n    public trace(...msg: any[]): void {\n        this.parent.trace(this.name, ...msg);\n    }\n\n    public debug(...msg: any[]): void {\n        this.parent.debug(this.name, ...msg);\n    }\n\n    public info(...msg: any[]): void {\n        this.parent.info(this.name, ...msg);\n    }\n\n    public warn(...msg: any[]): void {\n        this.parent.warn(this.name, ...msg);\n    }\n\n    public error(...msg: any[]): void {\n        this.parent.error(this.name, ...msg);\n    }\n}\n\n/**\n * A simplification of the `Debugger` type exposed by the `debug` library. We reimplement the bits we need here\n * to avoid a dependency on `debug`.\n */\ninterface Debugger {\n    (formatter: any, ...args: any[]): void;\n    extend: (namespace: string, delimiter?: string) => Debugger;\n}\n\n/**\n * A `Logger` instance, suitable for use in {@link ICreateClientOpts.logger}, which will write to the `debug` library.\n *\n * @example\n * ```js\n *     import debug from \"debug\";\n *\n *     const client = createClient({\n *         baseUrl: homeserverUrl,\n *         userId: userId,\n *         accessToken: \"akjgkrgjs\",\n *         deviceId: \"xzcvb\",\n *         logger: new DebugLogger(debug(`matrix-js-sdk:${userId}`)),\n *     });\n * ```\n */\nexport class DebugLogger implements Logger {\n    public constructor(private debugInstance: Debugger) {}\n\n    public trace(...msg: any[]): void {\n        this.debugWithPrefix(\"[TRACE]\", ...msg);\n    }\n\n    public debug(...msg: any[]): void {\n        this.debugWithPrefix(\"[DEBUG]\", ...msg);\n    }\n\n    public info(...msg: any[]): void {\n        this.debugWithPrefix(\"[INFO]\", ...msg);\n    }\n\n    public warn(...msg: any[]): void {\n        this.debugWithPrefix(\"[WARN]\", ...msg);\n    }\n\n    public error(...msg: any[]): void {\n        this.debugWithPrefix(\"[ERROR]\", ...msg);\n    }\n\n    public getChild(namespace: string): DebugLogger {\n        return new DebugLogger(this.debugInstance.extend(namespace));\n    }\n\n    private debugWithPrefix(prefix: string, ...msg: any[]): void {\n        let formatter: string;\n\n        // Convert the first argument to a string, so that we can safely add a prefix. This is much the same logic that\n        // `debug()` uses.\n        if (msg.length === 0) {\n            formatter = \"\";\n        } else if (msg[0] instanceof Error) {\n            const err = msg.shift();\n            formatter = err.stack || err.message;\n        } else if (typeof msg[0] == \"string\") {\n            formatter = msg.shift();\n        } else {\n            formatter = \"%O\";\n        }\n        this.debugInstance(prefix + \" \" + formatter, ...msg);\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Base64 encoding and decoding utilities\n */\n\nfunction toBase64(uint8Array: Uint8Array, options: Uint8ArrayToBase64Options): string {\n    if (typeof uint8Array.toBase64 === \"function\") {\n        // Currently this is only supported in Firefox,\n        // but we match the options in the hope in the future we can rely on it for all environments.\n        // https://tc39.es/proposal-arraybuffer-base64/spec/#sec-uint8array.prototype.tobase64\n        return uint8Array.toBase64(options);\n    }\n\n    let base64 = btoa(uint8Array.reduce((acc, current) => acc + String.fromCharCode(current), \"\"));\n    if (options.omitPadding) {\n        base64 = base64.replace(/={1,2}$/, \"\");\n    }\n    if (options.alphabet === \"base64url\") {\n        base64 = base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    }\n\n    return base64;\n}\n\n/**\n * Encode a typed array of uint8 as base64.\n * @param uint8Array - The data to encode.\n * @returns The base64.\n */\nexport function encodeBase64(uint8Array: Uint8Array): string {\n    return toBase64(uint8Array, { alphabet: \"base64\", omitPadding: false });\n}\n\n/**\n * Encode a typed array of uint8 as unpadded base64.\n * @param uint8Array - The data to encode.\n * @returns The unpadded base64.\n */\nexport function encodeUnpaddedBase64(uint8Array: Uint8Array): string {\n    return toBase64(uint8Array, { alphabet: \"base64\", omitPadding: true });\n}\n\n/**\n * Encode a typed array of uint8 as unpadded base64 using the URL-safe encoding.\n * @param uint8Array - The data to encode.\n * @returns The unpadded base64.\n */\nexport function encodeUnpaddedBase64Url(uint8Array: Uint8Array): string {\n    return toBase64(uint8Array, { alphabet: \"base64url\", omitPadding: true });\n}\n\nfunction fromBase64(base64: string, options: Uint8ArrayFromBase64Options): Uint8Array {\n    if (typeof Uint8Array.fromBase64 === \"function\") {\n        // Currently this is only supported in Firefox,\n        // but we match the options in the hope in the future we can rely on it for all environments.\n        // https://tc39.es/proposal-arraybuffer-base64/spec/#sec-uint8array.frombase64\n        return Uint8Array.fromBase64(base64, options);\n    }\n\n    return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));\n}\n\n/**\n * Decode a base64 (or base64url) string to a typed array of uint8.\n * @param base64 - The base64 to decode.\n * @returns The decoded data.\n */\nexport function decodeBase64(base64: string): Uint8Array {\n    // The function requires us to select an alphabet, but we don't know if base64url was used so we convert.\n    return fromBase64(base64.replace(/-/g, \"+\").replace(/_/g, \"/\"), { alphabet: \"base64\", lastChunkHandling: \"loose\" });\n}\n","/*\n * Copyright 2024 The Matrix.org Foundation C.I.C.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// salt for HKDF, with 8 bytes of zeros\nconst zeroSalt = new Uint8Array(8);\n\n/**\n * Derive AES and HMAC keys from a master key.\n *\n * This is used for deriving secret storage keys: see https://spec.matrix.org/v1.11/client-server-api/#msecret_storagev1aes-hmac-sha2 (step 1).\n *\n * @param key\n * @param name\n */\nexport async function deriveKeys(key: Uint8Array, name: string): Promise<[CryptoKey, CryptoKey]> {\n    const hkdfkey = await globalThis.crypto.subtle.importKey(\"raw\", key, { name: \"HKDF\" }, false, [\"deriveBits\"]);\n    const keybits = await globalThis.crypto.subtle.deriveBits(\n        {\n            name: \"HKDF\",\n            salt: zeroSalt,\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore: https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/879\n            info: new TextEncoder().encode(name),\n            hash: \"SHA-256\",\n        },\n        hkdfkey,\n        512,\n    );\n\n    const aesKey = keybits.slice(0, 32);\n    const hmacKey = keybits.slice(32);\n\n    const aesProm = globalThis.crypto.subtle.importKey(\"raw\", aesKey, { name: \"AES-CTR\" }, false, [\n        \"encrypt\",\n        \"decrypt\",\n    ]);\n\n    const hmacProm = globalThis.crypto.subtle.importKey(\n        \"raw\",\n        hmacKey,\n        {\n            name: \"HMAC\",\n            hash: { name: \"SHA-256\" },\n        },\n        false,\n        [\"sign\", \"verify\"],\n    );\n\n    return Promise.all([aesProm, hmacProm]);\n}\n","/*\n * Copyright 2024 The Matrix.org Foundation C.I.C.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeBase64 } from \"../base64.ts\";\nimport { deriveKeys } from \"./internal/deriveKeys.ts\";\nimport { type AESEncryptedSecretStoragePayload } from \"../@types/AESEncryptedSecretStoragePayload.ts\";\n\n/**\n * Decrypt an AES-encrypted Secret Storage item.\n *\n * @param data - the encrypted data, returned by {@link utils/encryptAESSecretStorageItem.default | encryptAESSecretStorageItem}.\n * @param key - the encryption key to use as an input to the HKDF function which is used to derive the AES key. Must\n *    be the same as provided to {@link utils/encryptAESSecretStorageItem.default | encryptAESSecretStorageItem}.\n * @param name - the name of the secret. Also used as an input to the HKDF operation which is used to derive the AES\n *    key, so again must be the same as provided to {@link utils/encryptAESSecretStorageItem.default | encryptAESSecretStorageItem}.\n */\nexport default async function decryptAESSecretStorageItem(\n    data: AESEncryptedSecretStoragePayload,\n    key: Uint8Array,\n    name: string,\n): Promise<string> {\n    const [aesKey, hmacKey] = await deriveKeys(key, name);\n\n    const ciphertext = decodeBase64(data.ciphertext);\n\n    if (!(await globalThis.crypto.subtle.verify({ name: \"HMAC\" }, hmacKey, decodeBase64(data.mac), ciphertext))) {\n        throw new Error(`Error decrypting secret ${name}: bad MAC`);\n    }\n\n    const plaintext = await globalThis.crypto.subtle.decrypt(\n        {\n            name: \"AES-CTR\",\n            counter: decodeBase64(data.iv),\n            length: 64,\n        },\n        aesKey,\n        ciphertext,\n    );\n\n    return new TextDecoder().decode(new Uint8Array(plaintext));\n}\n","/*\r\nCopyright 2024 New Vector Ltd.\r\nCopyright 2023 The Matrix.org Foundation C.I.C.\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\nimport { logger } from \"matrix-js-sdk/src/logger\";\r\nimport decryptAESSecretStorageItem from \"matrix-js-sdk/src/utils/decryptAESSecretStorageItem\";\r\nimport encryptAESSecretStorageItem from \"matrix-js-sdk/src/utils/encryptAESSecretStorageItem\";\r\nimport { type AESEncryptedSecretStoragePayload } from \"matrix-js-sdk/src/types\";\r\n\r\nimport * as StorageAccess from \"../StorageAccess\";\r\n\r\n/**\r\n * Utility functions related to the storage and retrieval of access tokens\r\n */\r\n\r\n/*\r\n * Names used when storing the tokens in indexeddb or localstorage\r\n */\r\nexport const ACCESS_TOKEN_STORAGE_KEY = \"mx_access_token\";\r\nexport const REFRESH_TOKEN_STORAGE_KEY = \"mx_refresh_token\";\r\n/*\r\n * Names of the tokens. Used as part of the calculation to derive AES keys during encryption in persistTokenInStorage,\r\n * and decryption in restoreSessionFromStorage.\r\n */\r\nexport const ACCESS_TOKEN_IV = \"access_token\";\r\nexport const REFRESH_TOKEN_IV = \"refresh_token\";\r\n/*\r\n * Keys for localstorage items which indicate whether we expect a token in indexeddb.\r\n */\r\nexport const HAS_ACCESS_TOKEN_STORAGE_KEY = \"mx_has_access_token\";\r\nexport const HAS_REFRESH_TOKEN_STORAGE_KEY = \"mx_has_refresh_token\";\r\n\r\n/**\r\n * The pickle key is a string of unspecified length and format.  For AES, we need a 256-bit Uint8Array. So we HKDF the pickle key to generate the AES key.  The AES key should be zeroed after it is used.\r\n * @param pickleKey\r\n * @returns AES key\r\n */\r\nasync function pickleKeyToAesKey(pickleKey: string): Promise<Uint8Array> {\r\n    const pickleKeyBuffer = new Uint8Array(pickleKey.length);\r\n    for (let i = 0; i < pickleKey.length; i++) {\r\n        pickleKeyBuffer[i] = pickleKey.charCodeAt(i);\r\n    }\r\n    const hkdfKey = await crypto.subtle.importKey(\"raw\", pickleKeyBuffer, \"HKDF\", false, [\"deriveBits\"]);\r\n    pickleKeyBuffer.fill(0);\r\n    return new Uint8Array(\r\n        await crypto.subtle.deriveBits(\r\n            {\r\n                name: \"HKDF\",\r\n                hash: \"SHA-256\",\r\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n                // @ts-ignore: https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/879\r\n                salt: new Uint8Array(32),\r\n                info: new Uint8Array(0),\r\n            },\r\n            hkdfKey,\r\n            256,\r\n        ),\r\n    );\r\n}\r\n\r\n/**\r\n * Try to decrypt a token retrieved from storage\r\n *\r\n * Where token is not encrypted (plain text) returns the plain text token.\r\n *\r\n * Where token is encrypted, attempts decryption. Returns successfully decrypted token, or throws if\r\n * decryption failed.\r\n *\r\n * @param pickleKey Pickle key: used to derive the encryption key, or undefined if the token is not encrypted.\r\n *   Must be the same as provided to {@link persistTokenInStorage}.\r\n * @param token token to be decrypted.\r\n * @param tokenName Name of the token. Used in logging, but also used as an input when generating the actual AES key,\r\n *    so the same value must be provided to {@link persistTokenInStorage}.\r\n *\r\n * @returns the decrypted token, or the plain text token.\r\n */\r\nexport async function tryDecryptToken(\r\n    pickleKey: string | undefined,\r\n    token: AESEncryptedSecretStoragePayload | string,\r\n    tokenName: string,\r\n): Promise<string> {\r\n    if (typeof token === \"string\") {\r\n        // Looks like an unencrypted token\r\n        return token;\r\n    }\r\n\r\n    // Otherwise, it must be an encrypted token.\r\n    if (!pickleKey) {\r\n        throw new Error(`Error decrypting secret ${tokenName}: no pickle key found.`);\r\n    }\r\n\r\n    const encrKey = await pickleKeyToAesKey(pickleKey);\r\n    const decryptedToken = await decryptAESSecretStorageItem(token, encrKey, tokenName);\r\n    encrKey.fill(0);\r\n    return decryptedToken;\r\n}\r\n\r\n/**\r\n * Persist a token in storage\r\n *\r\n * When pickle key is present, will attempt to encrypt the token. If encryption fails (typically because\r\n * WebCrypto is unavailable), the key will be stored unencrypted.\r\n *\r\n * Stores in IndexedDB, falling back to localStorage.\r\n *\r\n * @param storageKey key used to store the token. Note: not an encryption key; rather a localstorage or indexeddb key.\r\n * @param tokenName Name of the token. Used in logging, but also used as an input when generating the actual AES key,\r\n *    so the same value must be provided to {@link tryDecryptToken} when decrypting.\r\n * @param token the token to store. When undefined, any existing token at the `storageKey` is removed from storage.\r\n * @param pickleKey Pickle key: used to derive the key used to encrypt token. If `undefined`, the token will be stored\r\n *    unencrypted.\r\n * @param hasTokenStorageKey Localstorage key for an item which stores whether we expect to have a token in indexeddb,\r\n *    eg \"mx_has_access_token\".\r\n */\r\nexport async function persistTokenInStorage(\r\n    storageKey: string,\r\n    tokenName: string,\r\n    token: string | undefined,\r\n    pickleKey: string | undefined,\r\n    hasTokenStorageKey: string,\r\n): Promise<void> {\r\n    // store whether we expect to find a token, to detect the case\r\n    // where IndexedDB is blown away\r\n    if (token) {\r\n        localStorage.setItem(hasTokenStorageKey, \"true\");\r\n    } else {\r\n        localStorage.removeItem(hasTokenStorageKey);\r\n    }\r\n\r\n    if (pickleKey) {\r\n        let encryptedToken: AESEncryptedSecretStoragePayload | undefined;\r\n        if (token) {\r\n            try {\r\n                // try to encrypt the access token using the pickle key\r\n                const encrKey = await pickleKeyToAesKey(pickleKey);\r\n                encryptedToken = await encryptAESSecretStorageItem(token, encrKey, tokenName);\r\n                encrKey.fill(0);\r\n            } catch (e) {\r\n                // This is likely due to the browser not having WebCrypto or somesuch.\r\n                // Warn about it, but fall back to storing the unencrypted token.\r\n                logger.warn(`Could not encrypt token for ${tokenName}`, e);\r\n            }\r\n        }\r\n        try {\r\n            // Save either the encrypted access token, or the plain access\r\n            // token if there is no token or we were unable to encrypt (e.g. if the browser doesn't\r\n            // have WebCrypto).\r\n            await StorageAccess.idbSave(\"account\", storageKey, encryptedToken || token);\r\n        } catch {\r\n            // if we couldn't save to indexedDB, fall back to localStorage.  We\r\n            // store the access token unencrypted since localStorage only saves\r\n            // strings.\r\n            if (!!token) {\r\n                localStorage.setItem(storageKey, token);\r\n            } else {\r\n                localStorage.removeItem(storageKey);\r\n            }\r\n        }\r\n    } else {\r\n        try {\r\n            await StorageAccess.idbSave(\"account\", storageKey, token);\r\n        } catch {\r\n            if (!!token) {\r\n                localStorage.setItem(storageKey, token);\r\n            } else {\r\n                localStorage.removeItem(storageKey);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Wraps {@link persistTokenInStorage} with accessToken storage keys\r\n *\r\n * @param token - The token to store. When undefined, any existing accessToken is removed from storage.\r\n * @param pickleKey - Pickle key: used to derive the key used to encrypt token. If `undefined`, the token will be stored\r\n *    unencrypted.\r\n */\r\nexport async function persistAccessTokenInStorage(\r\n    token: string | undefined,\r\n    pickleKey: string | undefined,\r\n): Promise<void> {\r\n    return persistTokenInStorage(\r\n        ACCESS_TOKEN_STORAGE_KEY,\r\n        ACCESS_TOKEN_IV,\r\n        token,\r\n        pickleKey,\r\n        HAS_ACCESS_TOKEN_STORAGE_KEY,\r\n    );\r\n}\r\n\r\n/**\r\n * Wraps {@link persistTokenInStorage} with refreshToken storage keys.\r\n *\r\n * @param token - The token to store. When undefined, any existing refreshToken is removed from storage.\r\n * @param pickleKey - Pickle key: used to derive the key used to encrypt token. If `undefined`, the token will be stored\r\n *    unencrypted.\r\n */\r\nexport async function persistRefreshTokenInStorage(\r\n    token: string | undefined,\r\n    pickleKey: string | undefined,\r\n): Promise<void> {\r\n    return persistTokenInStorage(\r\n        REFRESH_TOKEN_STORAGE_KEY,\r\n        REFRESH_TOKEN_IV,\r\n        token,\r\n        pickleKey,\r\n        HAS_REFRESH_TOKEN_STORAGE_KEY,\r\n    );\r\n}\r\n","/*\r\nCopyright 2024 New Vector Ltd.\r\nCopyright 2020-2024 The Matrix.org Foundation C.I.C.\r\nCopyright 2018 New Vector Ltd\r\nCopyright 2016 Aviral Dasgupta\r\nCopyright 2016 OpenMarket Ltd\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\n// Note: we don't import the base64 utils from `matrix-js-sdk/src/matrix` because this file\r\n// is used by Element Web's service worker, and importing `matrix` brings in ~1mb of stuff\r\n// we don't need. Instead, we ignore the import restriction and only bring in what we actually\r\n// need.\r\n// Note: `base64` is not public in the js-sdk, so if it changes/breaks, that's on us. We should\r\n// be okay with our frequent tests, locked versioning, etc though. We'll pick up problems well\r\n// before release.\r\n// eslint-disable-next-line no-restricted-imports\r\nimport { encodeUnpaddedBase64 } from \"matrix-js-sdk/src/base64\";\r\nimport { logger } from \"matrix-js-sdk/src/logger\";\r\n\r\n/**\r\n * Encrypted format of a pickle key, as stored in IndexedDB.\r\n */\r\nexport interface EncryptedPickleKey {\r\n    /** The encrypted payload. */\r\n    encrypted?: BufferSource;\r\n\r\n    /** Initialisation vector for the encryption. */\r\n    iv?: BufferSource;\r\n\r\n    /** The encryption key which was used to encrypt the payload. */\r\n    cryptoKey?: CryptoKey;\r\n}\r\n\r\n/**\r\n * Calculates the `additionalData` for the AES-GCM key used by the pickling processes. This\r\n * additional data is *not* encrypted, but *is* authenticated. The additional data is constructed\r\n * from the user ID and device ID provided.\r\n *\r\n * The later-constructed pickle key is used to decrypt values, such as access tokens, from IndexedDB.\r\n *\r\n * See https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams for more information on\r\n * `additionalData`.\r\n *\r\n * @param {string} userId The user ID who owns the pickle key.\r\n * @param {string} deviceId The device ID which owns the pickle key.\r\n * @return {Uint8Array} The additional data as a Uint8Array.\r\n */\r\nexport function getPickleAdditionalData(userId: string, deviceId: string): Uint8Array {\r\n    const additionalData = new Uint8Array(userId.length + deviceId.length + 1);\r\n    for (let i = 0; i < userId.length; i++) {\r\n        additionalData[i] = userId.charCodeAt(i);\r\n    }\r\n    additionalData[userId.length] = 124; // \"|\"\r\n    for (let i = 0; i < deviceId.length; i++) {\r\n        additionalData[userId.length + 1 + i] = deviceId.charCodeAt(i);\r\n    }\r\n    return additionalData;\r\n}\r\n\r\n/**\r\n * Encrypt the given pickle key, ready for storage in the database.\r\n *\r\n * @param pickleKey - The key to be encrypted.\r\n * @param userId - The user ID the pickle key belongs to.\r\n * @param deviceId - The device ID the pickle key belongs to.\r\n *\r\n * @returns Data object ready for storing in indexeddb.\r\n */\r\nexport async function encryptPickleKey(\r\n    pickleKey: Uint8Array,\r\n    userId: string,\r\n    deviceId: string,\r\n): Promise<EncryptedPickleKey | undefined> {\r\n    if (!crypto?.subtle) {\r\n        return undefined;\r\n    }\r\n    const cryptoKey = await crypto.subtle.generateKey({ name: \"AES-GCM\", length: 256 }, false, [\"encrypt\", \"decrypt\"]);\r\n    const iv = new Uint8Array(32);\r\n    crypto.getRandomValues(iv);\r\n\r\n    const additionalData = getPickleAdditionalData(userId, deviceId);\r\n    const encrypted = await crypto.subtle.encrypt({ name: \"AES-GCM\", iv, additionalData }, cryptoKey, pickleKey);\r\n    return { encrypted, iv, cryptoKey };\r\n}\r\n\r\n/**\r\n * Decrypts the provided data into a pickle key and base64-encodes it ready for use elsewhere.\r\n *\r\n * If `data` is undefined in part or in full, returns undefined.\r\n *\r\n *  If crypto functions are not available, returns undefined regardless of input.\r\n *\r\n * @param data An object containing the encrypted pickle key data: encrypted payload, initialization vector (IV), and crypto key. Typically loaded from indexedDB.\r\n * @param userId The user ID the pickle key belongs to.\r\n * @param deviceId The device ID the pickle key belongs to.\r\n * @returns A promise that resolves to the encoded pickle key, or undefined if the key cannot be built and encoded.\r\n */\r\nexport async function buildAndEncodePickleKey(\r\n    data: EncryptedPickleKey | undefined,\r\n    userId: string,\r\n    deviceId: string,\r\n): Promise<string | undefined> {\r\n    if (!crypto?.subtle) {\r\n        return undefined;\r\n    }\r\n    if (!data || !data.encrypted || !data.iv || !data.cryptoKey) {\r\n        return undefined;\r\n    }\r\n\r\n    try {\r\n        const additionalData = getPickleAdditionalData(userId, deviceId);\r\n        const pickleKeyBuf = await crypto.subtle.decrypt(\r\n            { name: \"AES-GCM\", iv: data.iv, additionalData },\r\n            data.cryptoKey,\r\n            data.encrypted,\r\n        );\r\n        if (pickleKeyBuf) {\r\n            return encodeUnpaddedBase64(new Uint8Array(pickleKeyBuf));\r\n        }\r\n    } catch {\r\n        logger.error(\"Error decrypting pickle key\");\r\n    }\r\n\r\n    return undefined;\r\n}\r\n","/*\r\nCopyright 2024 New Vector Ltd.\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\nimport { idbLoad } from \"../utils/StorageAccess\";\r\nimport { ACCESS_TOKEN_IV, tryDecryptToken } from \"../utils/tokens/tokens\";\r\nimport { buildAndEncodePickleKey } from \"../utils/tokens/pickling\";\r\n\r\nconst serverSupportMap: {\r\n    [serverUrl: string]: {\r\n        supportsAuthedMedia: boolean;\r\n        cacheExpiryTimeMs: number;\r\n    };\r\n} = {};\r\n\r\nglobal.addEventListener(\"install\", (event) => {\r\n    // We skipWaiting() to update the service worker more frequently, particularly in development environments.\r\n    // @ts-expect-error - service worker types are not available. See 'fetch' event handler.\r\n    event.waitUntil(skipWaiting());\r\n});\r\n\r\nglobal.addEventListener(\"activate\", (event) => {\r\n    // We force all clients to be under our control, immediately. This could be old tabs.\r\n    // @ts-expect-error - service worker types are not available. See 'fetch' event handler.\r\n    event.waitUntil(clients.claim());\r\n});\r\n\r\n// @ts-expect-error - the service worker types conflict with the DOM types available through TypeScript. Many hours\r\n// have been spent trying to convince the type system that there's no actual conflict, but it has yet to work. Instead\r\n// of trying to make it do the thing, we force-cast to something close enough where we can (and ignore errors otherwise).\r\nglobal.addEventListener(\"fetch\", (event: FetchEvent) => {\r\n    // This is the authenticated media (MSC3916) check, proxying what was unauthenticated to the authenticated variants.\r\n\r\n    if (event.request.method !== \"GET\") {\r\n        return; // not important to us\r\n    }\r\n\r\n    // Note: ideally we'd keep the request headers etc, but in practice we can't even see those details.\r\n    // See https://stackoverflow.com/a/59152482\r\n    const url = new URL(event.request.url);\r\n\r\n    // We only intercept v3 download and thumbnail requests as presumably everything else is deliberate.\r\n    // For example, `/_matrix/media/unstable` or `/_matrix/media/v3/preview_url` are something well within\r\n    // the control of the application, and appear to be choices made at a higher level than us.\r\n    if (\r\n        !url.pathname.startsWith(\"/_matrix/media/v3/download\") &&\r\n        !url.pathname.startsWith(\"/_matrix/media/v3/thumbnail\")\r\n    ) {\r\n        return; // not a URL we care about\r\n    }\r\n\r\n    // We need to call respondWith synchronously, otherwise we may never execute properly. This means\r\n    // later on we need to proxy the request through if it turns out the server doesn't support authentication.\r\n    event.respondWith(\r\n        (async (): Promise<Response> => {\r\n            let auth: { accessToken?: string; homeserver: string } | undefined;\r\n            try {\r\n                // Figure out which homeserver we're communicating with\r\n                const csApi = url.origin;\r\n\r\n                // Add jitter to reduce request spam, particularly to `/versions` on initial page load\r\n                await new Promise<void>((resolve) => setTimeout(() => resolve(), Math.random() * 10));\r\n\r\n                // Locate the access token and homeserver url\r\n                // @ts-expect-error - service worker types are not available. See 'fetch' event handler.\r\n                const client = await global.clients.get(event.clientId);\r\n                auth = await getAuthData(client);\r\n\r\n                // Is this request actually going to the homeserver?\r\n                const isRequestToHomeServer = url.origin === new URL(auth.homeserver).origin;\r\n                if (!isRequestToHomeServer) {\r\n                    throw new Error(\"Request appears to be for media endpoint but wrong homeserver!\");\r\n                }\r\n\r\n                // Update or populate the server support map using a (usually) authenticated `/versions` call.\r\n                await tryUpdateServerSupportMap(csApi, auth.accessToken);\r\n\r\n                // If we have server support (and a means of authentication), rewrite the URL to use MSC3916 endpoints.\r\n                if (serverSupportMap[csApi].supportsAuthedMedia && auth.accessToken) {\r\n                    url.href = url.href.replace(/\\/media\\/v3\\/(.*)\\//, \"/client/v1/media/$1/\");\r\n                } // else by default we make no changes\r\n            } catch (err) {\r\n                // In case of some error, we stay safe by not adding the access-token to the request.\r\n                auth = undefined;\r\n                console.error(\"SW: Error in request rewrite.\", err);\r\n            }\r\n\r\n            // Add authentication and send the request. We add authentication even if MSC3916 endpoints aren't\r\n            // being used to ensure patches like this work:\r\n            // https://github.com/matrix-org/synapse/commit/2390b66bf0ec3ff5ffb0c7333f3c9b239eeb92bb\r\n            return fetch(url, fetchConfigForToken(auth?.accessToken));\r\n        })(),\r\n    );\r\n});\r\n\r\nasync function tryUpdateServerSupportMap(clientApiUrl: string, accessToken?: string): Promise<void> {\r\n    // only update if we don't know about it, or if the data is stale\r\n    if (serverSupportMap[clientApiUrl]?.cacheExpiryTimeMs > new Date().getTime()) {\r\n        return; // up to date\r\n    }\r\n\r\n    const config = fetchConfigForToken(accessToken);\r\n    const versions = await (await fetch(`${clientApiUrl}/_matrix/client/versions`, config)).json();\r\n    console.log(`[ServiceWorker] /versions response for '${clientApiUrl}': ${JSON.stringify(versions)}`);\r\n\r\n    serverSupportMap[clientApiUrl] = {\r\n        supportsAuthedMedia: Boolean(versions?.versions?.includes(\"v1.11\")),\r\n        cacheExpiryTimeMs: new Date().getTime() + 2 * 60 * 60 * 1000, // 2 hours from now\r\n    };\r\n    console.log(\r\n        `[ServiceWorker] serverSupportMap update for '${clientApiUrl}': ${JSON.stringify(serverSupportMap[clientApiUrl])}`,\r\n    );\r\n}\r\n\r\n// Ideally we'd use the `Client` interface for `client`, but since it's not available (see 'fetch' listener), we use\r\n// unknown for now and force-cast it to something close enough later.\r\nasync function getAuthData(client: unknown): Promise<{ accessToken: string; homeserver: string }> {\r\n    // Access tokens are encrypted at rest, so while we can grab the \"access token\", we'll need to do work to get the\r\n    // real thing.\r\n    const encryptedAccessToken = await idbLoad(\"account\", \"mx_access_token\");\r\n\r\n    // We need to extract a user ID and device ID from localstorage, which means calling WebPlatform for the\r\n    // read operation. Service workers can't access localstorage.\r\n    const { userId, deviceId, homeserver } = await askClientForUserIdParams(client);\r\n\r\n    // ... and this is why we need the user ID and device ID: they're index keys for the pickle key table.\r\n    const pickleKeyData = await idbLoad(\"pickleKey\", [userId, deviceId]);\r\n    if (pickleKeyData && (!pickleKeyData.encrypted || !pickleKeyData.iv || !pickleKeyData.cryptoKey)) {\r\n        throw new Error(\"SW: Invalid pickle key loaded - ignoring\");\r\n    }\r\n\r\n    // Finally, try decrypting the thing and return that. This may fail, but that's okay.\r\n    try {\r\n        const pickleKey = await buildAndEncodePickleKey(pickleKeyData, userId, deviceId);\r\n        const accessToken = await tryDecryptToken(pickleKey, encryptedAccessToken, ACCESS_TOKEN_IV);\r\n        return { accessToken, homeserver };\r\n    } catch (e) {\r\n        throw new Error(\"SW: Error decrypting access token.\", { cause: e });\r\n    }\r\n}\r\n\r\n// Ideally we'd use the `Client` interface for `client`, but since it's not available (see 'fetch' listener), we use\r\n// unknown for now and force-cast it to something close enough inside the function.\r\nasync function askClientForUserIdParams(\r\n    client: unknown,\r\n): Promise<{ userId: string; deviceId: string; homeserver: string }> {\r\n    return new Promise((resolve, reject) => {\r\n        // Dev note: this uses postMessage, which is a highly insecure channel. postMessage is typically visible to other\r\n        // tabs, windows, browser extensions, etc, making it far from ideal for sharing sensitive information. This is\r\n        // why our service worker calculates/decrypts the access token manually: we don't want the user's access token\r\n        // to be available to (potentially) malicious listeners. We do require some information for that decryption to\r\n        // work though, and request that in the least sensitive way possible.\r\n        //\r\n        // We could also potentially use some version of TLS to encrypt postMessage, though that feels way more involved\r\n        // than just reading IndexedDB ourselves.\r\n\r\n        // Avoid stalling the tab in case something goes wrong.\r\n        const timeoutId = setTimeout(() => reject(new Error(\"timeout in postMessage\")), 1000);\r\n\r\n        // We don't need particularly good randomness here - we just use this to generate a request ID, so we know\r\n        // which postMessage reply is for our active request.\r\n        const responseKey = Math.random().toString(36);\r\n\r\n        // Add the listener first, just in case the tab is *really* fast.\r\n        const listener = (event: MessageEvent): void => {\r\n            if (event.data?.responseKey !== responseKey) return; // not for us\r\n            clearTimeout(timeoutId); // do this as soon as possible, avoiding a race between resolve and reject.\r\n            resolve(event.data); // \"unblock\" the remainder of the thread, if that were such a thing in JavaScript.\r\n            global.removeEventListener(\"message\", listener); // cleanup, since we're not going to do anything else.\r\n        };\r\n        global.addEventListener(\"message\", listener);\r\n\r\n        // Ask the tab for the information we need. This is handled by WebPlatform.\r\n        (client as Window).postMessage({ responseKey, type: \"userinfo\" });\r\n    });\r\n}\r\n\r\nfunction fetchConfigForToken(accessToken?: string): RequestInit | undefined {\r\n    if (!accessToken) {\r\n        return undefined; // no headers/config to specify\r\n    }\r\n\r\n    return {\r\n        headers: {\r\n            Authorization: `Bearer ${accessToken}`,\r\n        },\r\n    };\r\n}\r\n"],"names":["noop","undefinedType","isIE","window","navigator","test","userAgent","logMethods","_loggersByName","defaultLogger","bindMethod","obj","methodName","method","bind","Function","prototype","call","e","apply","arguments","traceForIE","console","log","trace","realMethod","undefined","replaceLoggingMethods","level","this","getLevel","i","length","methodFactory","name","debug","levels","SILENT","enableLoggingWhenConsoleArrives","defaultMethodFactory","_level","_loggerName","Logger","factory","inheritedLevel","defaultLevel","userLevel","self","storageKey","persistLevelIfPossible","levelNum","levelName","toUpperCase","localStorage","ignore","document","cookie","encodeURIComponent","getPersistedLevel","storedLevel","cookieName","location","indexOf","exec","slice","clearPersistedLevel","removeItem","normalizeLevel","input","TypeError","setLevel","persist","setDefaultLevel","resetLevel","enableAll","TRACE","disableAll","rebuild","childName","initialLevel","getLogger","logger","_log","noConflict","getLoggers","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","prop","hasOwnProperty","oldGetScript","u","oldLoadScript","queryMap","countMap","chunkId","catch","error","retries","realSrc","message","request","Promise","resolve","setTimeout","cacheBust","Date","now","getIDBFactory","_self","indexedDB","idb","async","idbInit","Error","reject","open","onerror","onsuccess","result","onupgradeneeded","db","createObjectStore","idbTransaction","table","mode","fn","txn","transaction","objectStore","idbLoad","loglevel","logLevel","loggerName","args","prefix","unshift","getPrefixedLogger","prefixLogger","getChild","childPrefix","childLogger","DEBUG","toBase64","uint8Array","options","base64","btoa","reduce","acc","current","String","fromCharCode","omitPadding","replace","alphabet","decodeBase64","Uint8Array","fromBase64","from","atob","c","charCodeAt","lastChunkHandling","zeroSalt","decryptAESSecretStorageItem","data","aesKey","hmacKey","hkdfkey","crypto","subtle","importKey","keybits","deriveBits","salt","info","TextEncoder","encode","hash","aesProm","hmacProm","all","deriveKeys","ciphertext","verify","mac","plaintext","decrypt","counter","iv","TextDecoder","decode","ACCESS_TOKEN_IV","pickleKeyToAesKey","pickleKey","pickleKeyBuffer","hkdfKey","fill","getPickleAdditionalData","userId","deviceId","additionalData","buildAndEncodePickleKey","_crypto2","encrypted","cryptoKey","pickleKeyBuf","serverSupportMap","fetchConfigForToken","accessToken","headers","Authorization","global","addEventListener","event","waitUntil","skipWaiting","clients","claim","url","URL","pathname","startsWith","respondWith","auth","csApi","origin","Math","random","client","clientId","encryptedAccessToken","homeserver","timeoutId","responseKey","toString","listener","_event$data","clearTimeout","removeEventListener","postMessage","type","askClientForUserIdParams","pickleKeyData","token","tokenName","encrKey","decryptedToken","tryDecryptToken","cause","getAuthData","clientApiUrl","_serverSupportMap$cli","_versions$versions","cacheExpiryTimeMs","getTime","config","versions","fetch","json","JSON","stringify","supportsAuthedMedia","Boolean","includes","tryUpdateServerSupportMap","href","err","_auth"],"sourceRoot":""}