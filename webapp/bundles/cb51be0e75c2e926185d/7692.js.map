{"version":3,"file":"bundles/cb51be0e75c2e926185d/7692.js","mappings":"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","sources":["webpack://element-web/./src/async-components/views/dialogs/security/ExportE2eKeysDialog.tsx","webpack://element-web/./src/utils/MegolmExportEncryption.ts"],"sourcesContent":["/*\r\nCopyright 2024 New Vector Ltd.\r\nCopyright 2022 The Matrix.org Foundation C.I.C.\r\nCopyright 2017 Vector Creations Ltd\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\nimport FileSaver from \"file-saver\";\r\nimport React, { type ChangeEvent } from \"react\";\r\nimport { type MatrixClient } from \"matrix-js-sdk/src/matrix\";\r\nimport { logger } from \"matrix-js-sdk/src/logger\";\r\n\r\nimport { _t, _td } from \"../../../../languageHandler\";\r\nimport * as MegolmExportEncryption from \"../../../../utils/MegolmExportEncryption\";\r\nimport BaseDialog from \"../../../../components/views/dialogs/BaseDialog\";\r\nimport { type KeysStartingWith } from \"../../../../@types/common\";\r\nimport PassphraseField from \"../../../../components/views/auth/PassphraseField\";\r\nimport PassphraseConfirmField from \"../../../../components/views/auth/PassphraseConfirmField\";\r\nimport type Field from \"../../../../components/views/elements/Field\";\r\n\r\nenum Phase {\r\n    Edit = \"edit\",\r\n    Exporting = \"exporting\",\r\n}\r\n\r\ninterface IProps {\r\n    matrixClient: MatrixClient;\r\n    onFinished(doExport?: boolean): void;\r\n}\r\n\r\ninterface IState {\r\n    phase: Phase;\r\n    errStr: string | null;\r\n    passphrase1: string;\r\n    passphrase2: string;\r\n}\r\n\r\ntype AnyPassphrase = KeysStartingWith<IState, \"passphrase\">;\r\n\r\nexport default class ExportE2eKeysDialog extends React.Component<IProps, IState> {\r\n    private fieldPassword: Field | null = null;\r\n    private fieldPasswordConfirm: Field | null = null;\r\n\r\n    private unmounted = false;\r\n\r\n    public constructor(props: IProps) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            phase: Phase.Edit,\r\n            errStr: null,\r\n            passphrase1: \"\",\r\n            passphrase2: \"\",\r\n        };\r\n    }\r\n\r\n    public componentDidMount(): void {\r\n        this.unmounted = false;\r\n    }\r\n\r\n    public componentWillUnmount(): void {\r\n        this.unmounted = true;\r\n    }\r\n\r\n    private async verifyFieldsBeforeSubmit(): Promise<boolean> {\r\n        const fieldsInDisplayOrder = [this.fieldPassword, this.fieldPasswordConfirm];\r\n\r\n        const invalidFields: Field[] = [];\r\n\r\n        for (const field of fieldsInDisplayOrder) {\r\n            if (!field) continue;\r\n\r\n            const valid = await field.validate({ allowEmpty: false });\r\n            if (!valid) {\r\n                invalidFields.push(field);\r\n            }\r\n        }\r\n\r\n        if (invalidFields.length === 0) {\r\n            return true;\r\n        }\r\n\r\n        // Focus on the first invalid field, then re-validate,\r\n        // which will result in the error tooltip being displayed for that field.\r\n        invalidFields[0].focus();\r\n        invalidFields[0].validate({ allowEmpty: false, focused: true });\r\n\r\n        return false;\r\n    }\r\n\r\n    private onPassphraseFormSubmit = async (ev: React.FormEvent): Promise<void> => {\r\n        ev.preventDefault();\r\n\r\n        if (!(await this.verifyFieldsBeforeSubmit())) return;\r\n        if (this.unmounted) return;\r\n\r\n        const passphrase = this.state.passphrase1;\r\n        this.startExport(passphrase);\r\n    };\r\n\r\n    private startExport(passphrase: string): void {\r\n        // extra Promise.resolve() to turn synchronous exceptions into\r\n        // asynchronous ones.\r\n        Promise.resolve()\r\n            .then(() => {\r\n                return this.props.matrixClient.getCrypto()!.exportRoomKeysAsJson();\r\n            })\r\n            .then((k) => {\r\n                return MegolmExportEncryption.encryptMegolmKeyFile(k, passphrase);\r\n            })\r\n            .then((f) => {\r\n                const blob = new Blob([f], {\r\n                    type: \"text/plain;charset=us-ascii\",\r\n                });\r\n                FileSaver.saveAs(blob, \"element-keys.txt\");\r\n                this.props.onFinished(true);\r\n            })\r\n            .catch((e) => {\r\n                logger.error(\"Error exporting e2e keys:\", e);\r\n                if (this.unmounted) {\r\n                    return;\r\n                }\r\n                const msg = e.friendlyText || _t(\"error|unknown\");\r\n                this.setState({\r\n                    errStr: msg,\r\n                    phase: Phase.Edit,\r\n                });\r\n            });\r\n\r\n        this.setState({\r\n            errStr: null,\r\n            phase: Phase.Exporting,\r\n        });\r\n    }\r\n\r\n    private onCancelClick = (ev: React.MouseEvent): boolean => {\r\n        ev.preventDefault();\r\n        this.props.onFinished(false);\r\n        return false;\r\n    };\r\n\r\n    private onPassphraseChange = (ev: React.ChangeEvent<HTMLInputElement>, phrase: AnyPassphrase): void => {\r\n        this.setState({\r\n            [phrase]: ev.target.value,\r\n        } as Pick<IState, AnyPassphrase>);\r\n    };\r\n\r\n    public render(): React.ReactNode {\r\n        const disableForm = this.state.phase === Phase.Exporting;\r\n\r\n        return (\r\n            <BaseDialog\r\n                className=\"mx_exportE2eKeysDialog\"\r\n                onFinished={this.props.onFinished}\r\n                title={_t(\"settings|key_export_import|export_title\")}\r\n            >\r\n                <form onSubmit={this.onPassphraseFormSubmit}>\r\n                    <div className=\"mx_Dialog_content\">\r\n                        <p>{_t(\"settings|key_export_import|export_description_1\")}</p>\r\n                        <p>{_t(\"settings|key_export_import|export_description_2\")}</p>\r\n                        <div className=\"error\">{this.state.errStr}</div>\r\n                        <div className=\"mx_E2eKeysDialog_inputTable\">\r\n                            <div className=\"mx_E2eKeysDialog_inputRow\">\r\n                                <PassphraseField\r\n                                    minScore={3}\r\n                                    label={_td(\"settings|key_export_import|enter_passphrase\")}\r\n                                    labelEnterPassword={_td(\"settings|key_export_import|enter_passphrase\")}\r\n                                    labelStrongPassword={_td(\"settings|key_export_import|phrase_strong_enough\")}\r\n                                    labelAllowedButUnsafe={_td(\"settings|key_export_import|phrase_strong_enough\")}\r\n                                    value={this.state.passphrase1}\r\n                                    onChange={(e: ChangeEvent<HTMLInputElement>) =>\r\n                                        this.onPassphraseChange(e, \"passphrase1\")\r\n                                    }\r\n                                    autoFocus={true}\r\n                                    size={64}\r\n                                    type=\"password\"\r\n                                    disabled={disableForm}\r\n                                    autoComplete=\"new-password\"\r\n                                    fieldRef={(field) => {\r\n                                        this.fieldPassword = field;\r\n                                    }}\r\n                                />\r\n                            </div>\r\n                            <div className=\"mx_E2eKeysDialog_inputRow\">\r\n                                <PassphraseConfirmField\r\n                                    password={this.state.passphrase1}\r\n                                    label={_td(\"settings|key_export_import|confirm_passphrase\")}\r\n                                    labelRequired={_td(\"settings|key_export_import|phrase_cannot_be_empty\")}\r\n                                    labelInvalid={_td(\"settings|key_export_import|phrase_must_match\")}\r\n                                    value={this.state.passphrase2}\r\n                                    onChange={(e: ChangeEvent<HTMLInputElement>) =>\r\n                                        this.onPassphraseChange(e, \"passphrase2\")\r\n                                    }\r\n                                    size={64}\r\n                                    type=\"password\"\r\n                                    disabled={disableForm}\r\n                                    autoComplete=\"new-password\"\r\n                                    fieldRef={(field) => {\r\n                                        this.fieldPasswordConfirm = field;\r\n                                    }}\r\n                                />\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                    <div className=\"mx_Dialog_buttons\">\r\n                        <input\r\n                            className=\"mx_Dialog_primary\"\r\n                            type=\"submit\"\r\n                            value={_t(\"action|export\")}\r\n                            disabled={disableForm}\r\n                        />\r\n                        <button onClick={this.onCancelClick} disabled={disableForm}>\r\n                            {_t(\"action|cancel\")}\r\n                        </button>\r\n                    </div>\r\n                </form>\r\n            </BaseDialog>\r\n        );\r\n    }\r\n}\r\n","/*\r\nCopyright 2024 New Vector Ltd.\r\nCopyright 2020 The Matrix.org Foundation C.I.C.\r\nCopyright 2017 Vector Creations Ltd\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\nimport { logger } from \"matrix-js-sdk/src/logger\";\r\n\r\nimport { _t } from \"../languageHandler\";\r\nimport SdkConfig from \"../SdkConfig\";\r\n\r\nconst subtleCrypto = window.crypto.subtle;\r\n\r\n/**\r\n * Make an Error object which has a friendlyText property which is already\r\n * translated and suitable for showing to the user.\r\n *\r\n * @param {string} message message for the exception\r\n * @param {string} friendlyText\r\n * @returns {{message: string, friendlyText: string}}\r\n */\r\nfunction friendlyError(message: string, friendlyText: string): { message: string; friendlyText: string } {\r\n    return { message, friendlyText };\r\n}\r\n\r\nfunction cryptoFailMsg(): string {\r\n    return _t(\"encryption|export_unsupported\");\r\n}\r\n\r\n/**\r\n * Decrypt a megolm key file\r\n *\r\n * @param {ArrayBuffer} data file to decrypt\r\n * @param {String} password\r\n * @return {Promise<String>} promise for decrypted output\r\n *\r\n *\r\n */\r\nexport async function decryptMegolmKeyFile(data: ArrayBuffer, password: string): Promise<string> {\r\n    const body = unpackMegolmKeyFile(data);\r\n    const brand = SdkConfig.get().brand;\r\n\r\n    // check we have a version byte\r\n    if (body.length < 1) {\r\n        throw friendlyError(\"Invalid file: too short\", _t(\"encryption|import_invalid_keyfile\", { brand }));\r\n    }\r\n\r\n    const version = body[0];\r\n    if (version !== 1) {\r\n        throw friendlyError(\"Unsupported version\", _t(\"encryption|import_invalid_keyfile\", { brand }));\r\n    }\r\n\r\n    const ciphertextLength = body.length - (1 + 16 + 16 + 4 + 32);\r\n    if (ciphertextLength < 0) {\r\n        throw friendlyError(\"Invalid file: too short\", _t(\"encryption|import_invalid_keyfile\", { brand }));\r\n    }\r\n\r\n    const salt = body.subarray(1, 1 + 16);\r\n    const iv = body.subarray(17, 17 + 16);\r\n    const iterations = (body[33] << 24) | (body[34] << 16) | (body[35] << 8) | body[36];\r\n    const ciphertext = body.subarray(37, 37 + ciphertextLength);\r\n    const hmac = body.subarray(-32);\r\n\r\n    const [aesKey, hmacKey] = await deriveKeys(salt, iterations, password);\r\n    const toVerify = body.subarray(0, -32);\r\n\r\n    let isValid;\r\n    try {\r\n        isValid = await subtleCrypto.verify({ name: \"HMAC\" }, hmacKey, hmac, toVerify);\r\n    } catch (e) {\r\n        throw friendlyError(\"subtleCrypto.verify failed: \" + e, cryptoFailMsg());\r\n    }\r\n    if (!isValid) {\r\n        throw friendlyError(\"hmac mismatch\", _t(\"encryption|import_invalid_passphrase\"));\r\n    }\r\n\r\n    let plaintext;\r\n    try {\r\n        plaintext = await subtleCrypto.decrypt(\r\n            {\r\n                name: \"AES-CTR\",\r\n                counter: iv,\r\n                length: 64,\r\n            },\r\n            aesKey,\r\n            ciphertext,\r\n        );\r\n    } catch (e) {\r\n        throw friendlyError(\"subtleCrypto.decrypt failed: \" + e, cryptoFailMsg());\r\n    }\r\n\r\n    return new TextDecoder().decode(new Uint8Array(plaintext));\r\n}\r\n\r\n/**\r\n * Encrypt a megolm key file\r\n *\r\n * @param {String} data\r\n * @param {String} password\r\n * @param {Object=} options\r\n * @param {Number=} options.kdf_rounds Number of iterations to perform of the\r\n *    key-derivation function.\r\n * @return {Promise<ArrayBuffer>} promise for encrypted output\r\n */\r\nexport async function encryptMegolmKeyFile(\r\n    data: string,\r\n    password: string,\r\n    options?: { kdf_rounds?: number }, // eslint-disable-line camelcase\r\n): Promise<ArrayBuffer> {\r\n    options = options || {};\r\n    const kdfRounds = options.kdf_rounds || 500000;\r\n\r\n    const salt = new Uint8Array(16);\r\n    window.crypto.getRandomValues(salt);\r\n\r\n    const iv = new Uint8Array(16);\r\n    window.crypto.getRandomValues(iv);\r\n\r\n    // clear bit 63 of the IV to stop us hitting the 64-bit counter boundary\r\n    // (which would mean we wouldn't be able to decrypt on Android). The loss\r\n    // of a single bit of iv is a price we have to pay.\r\n    iv[8] &= 0x7f;\r\n\r\n    const [aesKey, hmacKey] = await deriveKeys(salt, kdfRounds, password);\r\n    const encodedData = new TextEncoder().encode(data);\r\n\r\n    let ciphertext;\r\n    try {\r\n        ciphertext = await subtleCrypto.encrypt(\r\n            {\r\n                name: \"AES-CTR\",\r\n                counter: iv,\r\n                length: 64,\r\n            },\r\n            aesKey,\r\n            encodedData,\r\n        );\r\n    } catch (e) {\r\n        throw friendlyError(\"subtleCrypto.encrypt failed: \" + e, cryptoFailMsg());\r\n    }\r\n\r\n    const cipherArray = new Uint8Array(ciphertext);\r\n    const bodyLength = 1 + salt.length + iv.length + 4 + cipherArray.length + 32;\r\n    const resultBuffer = new Uint8Array(bodyLength);\r\n    let idx = 0;\r\n    resultBuffer[idx++] = 1; // version\r\n    resultBuffer.set(salt, idx);\r\n    idx += salt.length;\r\n    resultBuffer.set(iv, idx);\r\n    idx += iv.length;\r\n    resultBuffer[idx++] = kdfRounds >> 24;\r\n    resultBuffer[idx++] = (kdfRounds >> 16) & 0xff;\r\n    resultBuffer[idx++] = (kdfRounds >> 8) & 0xff;\r\n    resultBuffer[idx++] = kdfRounds & 0xff;\r\n    resultBuffer.set(cipherArray, idx);\r\n    idx += cipherArray.length;\r\n\r\n    const toSign = resultBuffer.subarray(0, idx);\r\n\r\n    let hmac;\r\n    try {\r\n        hmac = await subtleCrypto.sign({ name: \"HMAC\" }, hmacKey, toSign);\r\n    } catch (e) {\r\n        throw friendlyError(\"subtleCrypto.sign failed: \" + e, cryptoFailMsg());\r\n    }\r\n\r\n    const hmacArray = new Uint8Array(hmac);\r\n    resultBuffer.set(hmacArray, idx);\r\n    return packMegolmKeyFile(resultBuffer);\r\n}\r\n\r\n/**\r\n * Derive the AES and HMAC-SHA-256 keys for the file\r\n *\r\n * @param {Unit8Array} salt  salt for pbkdf\r\n * @param {Number} iterations number of pbkdf iterations\r\n * @param {String} password  password\r\n * @return {Promise<[CryptoKey, CryptoKey]>} promise for [aes key, hmac key]\r\n */\r\nasync function deriveKeys(salt: Uint8Array, iterations: number, password: string): Promise<[CryptoKey, CryptoKey]> {\r\n    const start = new Date();\r\n\r\n    let key;\r\n    try {\r\n        key = await subtleCrypto.importKey(\"raw\", new TextEncoder().encode(password), { name: \"PBKDF2\" }, false, [\r\n            \"deriveBits\",\r\n        ]);\r\n    } catch (e) {\r\n        throw friendlyError(\"subtleCrypto.importKey failed: \" + e, cryptoFailMsg());\r\n    }\r\n\r\n    let keybits;\r\n    try {\r\n        keybits = await subtleCrypto.deriveBits(\r\n            {\r\n                name: \"PBKDF2\",\r\n                salt: salt,\r\n                iterations: iterations,\r\n                hash: \"SHA-512\",\r\n            },\r\n            key,\r\n            512,\r\n        );\r\n    } catch (e) {\r\n        throw friendlyError(\"subtleCrypto.deriveBits failed: \" + e, cryptoFailMsg());\r\n    }\r\n\r\n    const now = new Date();\r\n    logger.log(\"E2e import/export: deriveKeys took \" + (now.getTime() - start.getTime()) + \"ms\");\r\n\r\n    const aesKey = keybits.slice(0, 32);\r\n    const hmacKey = keybits.slice(32);\r\n\r\n    const aesProm = subtleCrypto\r\n        .importKey(\"raw\", aesKey, { name: \"AES-CTR\" }, false, [\"encrypt\", \"decrypt\"])\r\n        .catch((e) => {\r\n            throw friendlyError(\"subtleCrypto.importKey failed for AES key: \" + e, cryptoFailMsg());\r\n        });\r\n\r\n    const hmacProm = subtleCrypto\r\n        .importKey(\r\n            \"raw\",\r\n            hmacKey,\r\n            {\r\n                name: \"HMAC\",\r\n                hash: { name: \"SHA-256\" },\r\n            },\r\n            false,\r\n            [\"sign\", \"verify\"],\r\n        )\r\n        .catch((e) => {\r\n            throw friendlyError(\"subtleCrypto.importKey failed for HMAC key: \" + e, cryptoFailMsg());\r\n        });\r\n\r\n    return Promise.all([aesProm, hmacProm]);\r\n}\r\n\r\nconst HEADER_LINE = \"-----BEGIN MEGOLM SESSION DATA-----\";\r\nconst TRAILER_LINE = \"-----END MEGOLM SESSION DATA-----\";\r\n\r\n/**\r\n * Unbase64 an ascii-armoured megolm key file\r\n *\r\n * Strips the header and trailer lines, and unbase64s the content\r\n *\r\n * @param {ArrayBuffer} data  input file\r\n * @return {Uint8Array} unbase64ed content\r\n */\r\nfunction unpackMegolmKeyFile(data: ArrayBuffer): Uint8Array {\r\n    // parse the file as a great big String. This should be safe, because there\r\n    // should be no non-ASCII characters, and it means that we can do string\r\n    // comparisons to find the header and footer, and feed it into window.atob.\r\n    const fileStr = new TextDecoder().decode(new Uint8Array(data));\r\n\r\n    // look for the start line\r\n    let lineStart = 0;\r\n    // eslint-disable-next-line no-constant-condition\r\n    while (1) {\r\n        const lineEnd = fileStr.indexOf(\"\\n\", lineStart);\r\n        if (lineEnd < 0) {\r\n            throw new Error(\"Header line not found\");\r\n        }\r\n        const line = fileStr.slice(lineStart, lineEnd).trim();\r\n\r\n        // start the next line after the newline\r\n        lineStart = lineEnd + 1;\r\n\r\n        if (line === HEADER_LINE) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    const dataStart = lineStart;\r\n\r\n    // look for the end line\r\n    // eslint-disable-next-line no-constant-condition\r\n    while (1) {\r\n        const lineEnd = fileStr.indexOf(\"\\n\", lineStart);\r\n        const line = fileStr.slice(lineStart, lineEnd < 0 ? undefined : lineEnd).trim();\r\n        if (line === TRAILER_LINE) {\r\n            break;\r\n        }\r\n\r\n        if (lineEnd < 0) {\r\n            throw new Error(\"Trailer line not found\");\r\n        }\r\n\r\n        // start the next line after the newline\r\n        lineStart = lineEnd + 1;\r\n    }\r\n\r\n    const dataEnd = lineStart;\r\n    return decodeBase64(fileStr.slice(dataStart, dataEnd));\r\n}\r\n\r\n/**\r\n * ascii-armour a  megolm key file\r\n *\r\n * base64s the content, and adds header and trailer lines\r\n *\r\n * @param {Uint8Array} data  raw data\r\n * @return {ArrayBuffer} formatted file\r\n */\r\nfunction packMegolmKeyFile(data: Uint8Array): ArrayBuffer {\r\n    // we split into lines before base64ing, because encodeBase64 doesn't deal\r\n    // terribly well with large arrays.\r\n    const LINE_LENGTH = (72 * 4) / 3;\r\n    const nLines = Math.ceil(data.length / LINE_LENGTH);\r\n    const lines = new Array(nLines + 3);\r\n    lines[0] = HEADER_LINE;\r\n    let o = 0;\r\n    let i;\r\n    for (i = 1; i <= nLines; i++) {\r\n        lines[i] = encodeBase64(data.subarray(o, o + LINE_LENGTH));\r\n        o += LINE_LENGTH;\r\n    }\r\n    lines[i++] = TRAILER_LINE;\r\n    lines[i] = \"\";\r\n    return new TextEncoder().encode(lines.join(\"\\n\")).buffer;\r\n}\r\n\r\n/**\r\n * Encode a typed array of uint8 as base64.\r\n * @param {Uint8Array} uint8Array The data to encode.\r\n * @return {string} The base64.\r\n */\r\nfunction encodeBase64(uint8Array: Uint8Array): string {\r\n    // Misinterpt the Uint8Array as Latin-1.\r\n    // window.btoa expects a unicode string with codepoints in the range 0-255.\r\n    const latin1String = String.fromCharCode.apply(null, Array.from(uint8Array));\r\n    // Use the builtin base64 encoder.\r\n    return window.btoa(latin1String);\r\n}\r\n\r\n/**\r\n * Decode a base64 string to a typed array of uint8.\r\n * @param {string} base64 The base64 to decode.\r\n * @return {Uint8Array} The decoded data.\r\n */\r\nfunction decodeBase64(base64: string): Uint8Array {\r\n    // window.atob returns a unicode string with codepoints in the range 0-255.\r\n    const latin1String = window.atob(base64);\r\n    // Encode the string as a Uint8Array\r\n    const uint8Array = new Uint8Array(latin1String.length);\r\n    for (let i = 0; i < latin1String.length; i++) {\r\n        uint8Array[i] = latin1String.charCodeAt(i);\r\n    }\r\n    return uint8Array;\r\n}\r\n"],"names":["Phase","ExportE2eKeysDialog","React","constructor","props","super","_defineProperty","async","ev","preventDefault","this","verifyFieldsBeforeSubmit","unmounted","passphrase","state","passphrase1","startExport","onFinished","phrase","setState","target","value","phase","Edit","errStr","passphrase2","componentDidMount","componentWillUnmount","fieldsInDisplayOrder","fieldPassword","fieldPasswordConfirm","invalidFields","field","validate","allowEmpty","push","length","focus","focused","Promise","resolve","then","matrixClient","getCrypto","exportRoomKeysAsJson","k","MegolmExportEncryption","f","blob","Blob","type","FileSaver","catch","e","logger","error","msg","friendlyText","_t","Exporting","render","disableForm","BaseDialog","className","title","onSubmit","onPassphraseFormSubmit","PassphraseField","minScore","label","_td","labelEnterPassword","labelStrongPassword","labelAllowedButUnsafe","onChange","onPassphraseChange","autoFocus","size","disabled","autoComplete","fieldRef","PassphraseConfirmField","password","labelRequired","labelInvalid","onClick","onCancelClick","subtleCrypto","window","crypto","subtle","friendlyError","message","cryptoFailMsg","decryptMegolmKeyFile","data","body","fileStr","TextDecoder","decode","Uint8Array","lineStart","lineEnd","indexOf","Error","line","slice","trim","HEADER_LINE","dataStart","undefined","TRAILER_LINE","dataEnd","base64","latin1String","atob","uint8Array","i","charCodeAt","decodeBase64","unpackMegolmKeyFile","brand","SdkConfig","get","ciphertextLength","salt","subarray","iv","iterations","ciphertext","hmac","aesKey","hmacKey","deriveKeys","toVerify","isValid","plaintext","verify","name","decrypt","counter","encryptMegolmKeyFile","options","kdfRounds","kdf_rounds","getRandomValues","encodedData","TextEncoder","encode","encrypt","cipherArray","bodyLength","resultBuffer","idx","set","toSign","sign","hmacArray","LINE_LENGTH","nLines","Math","ceil","lines","Array","o","encodeBase64","join","buffer","packMegolmKeyFile","start","Date","key","keybits","importKey","deriveBits","hash","now","log","getTime","aesProm","hmacProm","all","String","fromCharCode","apply","from","btoa"],"sourceRoot":""}