{"version":3,"file":"bundles/cb51be0e75c2e926185d/395.js","mappings":"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","sources":["webpack://element-web/./src/components/views/location/Map.tsx","webpack://element-web/./src/utils/location/useMap.ts","webpack://element-web/./src/utils/location/map.ts"],"sourcesContent":["/*\r\nCopyright 2024 New Vector Ltd.\r\nCopyright 2022 The Matrix.org Foundation C.I.C.\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\nimport React, { type ReactNode, useContext, useEffect, useState } from \"react\";\r\nimport classNames from \"classnames\";\r\nimport * as maplibregl from \"maplibre-gl\";\r\nimport { ClientEvent, type IClientWellKnown } from \"matrix-js-sdk/src/matrix\";\r\nimport { logger } from \"matrix-js-sdk/src/logger\";\r\n\r\nimport MatrixClientContext from \"../../../contexts/MatrixClientContext\";\r\nimport { useEventEmitterState } from \"../../../hooks/useEventEmitter\";\r\nimport { parseGeoUri, positionFailureMessage } from \"../../../utils/location\";\r\nimport { tileServerFromWellKnown } from \"../../../utils/WellKnownUtils\";\r\nimport { useMap } from \"../../../utils/location/useMap\";\r\nimport { type Bounds } from \"../../../utils/beacon/bounds\";\r\nimport Modal from \"../../../Modal\";\r\nimport ErrorDialog from \"../dialogs/ErrorDialog\";\r\nimport { _t } from \"../../../languageHandler\";\r\n\r\nconst useMapWithStyle = ({\r\n    id,\r\n    centerGeoUri,\r\n    onError,\r\n    interactive,\r\n    bounds,\r\n    allowGeolocate,\r\n}: {\r\n    id: string;\r\n    centerGeoUri?: string;\r\n    onError?(error: Error): void;\r\n    interactive?: boolean;\r\n    bounds?: Bounds;\r\n    allowGeolocate?: boolean;\r\n}): {\r\n    map: maplibregl.Map | undefined;\r\n    bodyId: string;\r\n} => {\r\n    const bodyId = `mx_Map_${id}`;\r\n\r\n    // style config\r\n    const context = useContext(MatrixClientContext);\r\n    const mapStyleUrl = useEventEmitterState(\r\n        context,\r\n        ClientEvent.ClientWellKnown,\r\n        (clientWellKnown: IClientWellKnown) => tileServerFromWellKnown(clientWellKnown)?.[\"map_style_url\"],\r\n    );\r\n\r\n    const map = useMap({ interactive, bodyId, onError });\r\n\r\n    useEffect(() => {\r\n        if (mapStyleUrl && map) {\r\n            map.setStyle(mapStyleUrl);\r\n        }\r\n    }, [mapStyleUrl, map]);\r\n\r\n    useEffect(() => {\r\n        if (map && centerGeoUri) {\r\n            try {\r\n                const coords = parseGeoUri(centerGeoUri);\r\n                if (!coords) {\r\n                    throw new Error(\"Invalid geo URI\");\r\n                }\r\n                map.setCenter({ lon: coords.longitude, lat: coords.latitude });\r\n            } catch (e) {\r\n                logger.error(\"Could not set map center\", e);\r\n            }\r\n        }\r\n    }, [map, centerGeoUri]);\r\n\r\n    useEffect(() => {\r\n        if (map && bounds) {\r\n            try {\r\n                const lngLatBounds = new maplibregl.LngLatBounds(\r\n                    [bounds.west, bounds.south],\r\n                    [bounds.east, bounds.north],\r\n                );\r\n                map.fitBounds(lngLatBounds, { padding: 100, maxZoom: 15 });\r\n            } catch (e) {\r\n                logger.error(\"Invalid map bounds\", e);\r\n            }\r\n        }\r\n    }, [map, bounds]);\r\n\r\n    const [geolocate, setGeolocate] = useState<maplibregl.GeolocateControl | null>(null);\r\n\r\n    useEffect(() => {\r\n        if (!map) {\r\n            return;\r\n        }\r\n        if (allowGeolocate && !geolocate) {\r\n            const geolocate = new maplibregl.GeolocateControl({\r\n                positionOptions: {\r\n                    enableHighAccuracy: true,\r\n                },\r\n                trackUserLocation: false,\r\n            });\r\n            setGeolocate(geolocate);\r\n            map.addControl(geolocate);\r\n        }\r\n        if (!allowGeolocate && geolocate) {\r\n            map.removeControl(geolocate);\r\n            setGeolocate(null);\r\n        }\r\n    }, [map, geolocate, allowGeolocate]);\r\n\r\n    useEffect(() => {\r\n        if (geolocate) {\r\n            geolocate.on(\"error\", onGeolocateError);\r\n            return () => {\r\n                geolocate.off(\"error\", onGeolocateError);\r\n            };\r\n        }\r\n    }, [geolocate]);\r\n\r\n    return {\r\n        map,\r\n        bodyId,\r\n    };\r\n};\r\n\r\nconst onGeolocateError = (e: GeolocationPositionError): void => {\r\n    logger.error(\"Could not fetch location\", e);\r\n    Modal.createDialog(ErrorDialog, {\r\n        title: _t(\"location_sharing|error_fetch_location\"),\r\n        description: positionFailureMessage(e.code) ?? \"\",\r\n    });\r\n};\r\n\r\nexport interface MapProps {\r\n    id: string;\r\n    interactive?: boolean;\r\n    /**\r\n     * set map center to geoUri coords\r\n     * Center will only be set to valid geoUri\r\n     * this prop is only simply diffed by useEffect, so to trigger *recentering* of the same geoUri\r\n     * append the uri with a var not used by the geoUri spec\r\n     * eg a timestamp: `geo:54,42;mxTs=123`\r\n     */\r\n    centerGeoUri?: string;\r\n    bounds?: Bounds;\r\n    className?: string;\r\n    allowGeolocate?: boolean;\r\n    onClick?: () => void;\r\n    onError?: (error: Error) => void;\r\n    children?: (renderProps: { map: maplibregl.Map }) => ReactNode;\r\n}\r\n\r\nconst MapComponent: React.FC<MapProps> = ({\r\n    bounds,\r\n    centerGeoUri,\r\n    children,\r\n    className,\r\n    allowGeolocate,\r\n    id,\r\n    interactive,\r\n    onError,\r\n    onClick,\r\n}) => {\r\n    const { map, bodyId } = useMapWithStyle({ centerGeoUri, onError, id, interactive, bounds, allowGeolocate });\r\n\r\n    const onMapClick = (event: React.MouseEvent<HTMLDivElement, MouseEvent>): void => {\r\n        // Eat click events when clicking the attribution button\r\n        const target = event.target as Element;\r\n        if (target.classList.contains(\"maplibregl-ctrl-attrib-button\")) {\r\n            return;\r\n        }\r\n\r\n        onClick?.();\r\n    };\r\n\r\n    return (\r\n        <div className={classNames(\"mx_Map\", className)} id={bodyId} onClick={onMapClick}>\r\n            {!!children && !!map && children({ map })}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default MapComponent;\r\n","/*\r\nCopyright 2024 New Vector Ltd.\r\nCopyright 2022 The Matrix.org Foundation C.I.C.\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\nimport { useEffect, useState } from \"react\";\r\n\r\nimport type { Map as MapLibreMap } from \"maplibre-gl\";\r\nimport { createMap } from \"./map\";\r\nimport { useMatrixClientContext } from \"../../contexts/MatrixClientContext\";\r\n\r\ninterface UseMapProps {\r\n    bodyId: string;\r\n    onError?: (error: Error) => void;\r\n    interactive?: boolean;\r\n}\r\n\r\n/**\r\n * Create a map instance\r\n * Add listeners for errors\r\n * Make sure `onError` has a stable reference\r\n * As map is recreated on changes to it\r\n */\r\nexport const useMap = ({ interactive, bodyId, onError }: UseMapProps): MapLibreMap | undefined => {\r\n    const cli = useMatrixClientContext();\r\n    const [map, setMap] = useState<MapLibreMap>();\r\n\r\n    useEffect(\r\n        () => {\r\n            let map: MapLibreMap | undefined;\r\n            try {\r\n                map = createMap(cli, !!interactive, bodyId, onError);\r\n                setMap(map);\r\n            } catch (error) {\r\n                console.error(\"Error encountered in useMap\", error);\r\n                if (error instanceof Error) {\r\n                    onError?.(error);\r\n                }\r\n            }\r\n            return () => {\r\n                if (map) {\r\n                    map.remove();\r\n                    setMap(undefined);\r\n                }\r\n            };\r\n        },\r\n        // map is excluded as a dependency\r\n        [cli, interactive, bodyId, onError],\r\n    );\r\n\r\n    return map;\r\n};\r\n","/*\r\nCopyright 2024 New Vector Ltd.\r\nCopyright 2022 The Matrix.org Foundation C.I.C.\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\nimport * as maplibregl from \"maplibre-gl\";\r\nimport { type MatrixClient } from \"matrix-js-sdk/src/matrix\";\r\nimport { logger } from \"matrix-js-sdk/src/logger\";\r\n\r\nimport { _t } from \"../../languageHandler\";\r\nimport { findMapStyleUrl } from \"./findMapStyleUrl\";\r\nimport { LocationShareError } from \"./LocationShareErrors\";\r\n\r\nexport const createMap = (\r\n    client: MatrixClient,\r\n    interactive: boolean,\r\n    bodyId: string,\r\n    onError?: (error: Error) => void,\r\n): maplibregl.Map => {\r\n    try {\r\n        const styleUrl = findMapStyleUrl(client);\r\n\r\n        const map = new maplibregl.Map({\r\n            container: bodyId,\r\n            style: styleUrl,\r\n            zoom: 15,\r\n            interactive,\r\n            attributionControl: false,\r\n            locale: {\r\n                \"AttributionControl.ToggleAttribution\": _t(\"location_sharing|toggle_attribution\"),\r\n                \"AttributionControl.MapFeedback\": _t(\"location_sharing|map_feedback\"),\r\n                \"FullscreenControl.Enter\": _t(\"action|enter_fullscreen\"),\r\n                \"FullscreenControl.Exit\": _t(\"action|exit_fullscreeen\"),\r\n                \"GeolocateControl.FindMyLocation\": _t(\"location_sharing|find_my_location\"),\r\n                \"GeolocateControl.LocationNotAvailable\": _t(\"location_sharing|location_not_available\"),\r\n                \"LogoControl.Title\": _t(\"location_sharing|mapbox_logo\"),\r\n                \"NavigationControl.ResetBearing\": _t(\"location_sharing|reset_bearing\"),\r\n                \"NavigationControl.ZoomIn\": _t(\"action|zoom_in\"),\r\n                \"NavigationControl.ZoomOut\": _t(\"action|zoom_out\"),\r\n            },\r\n        });\r\n        map.addControl(new maplibregl.AttributionControl(), \"top-right\");\r\n\r\n        map.on(\"error\", (e) => {\r\n            logger.error(\"Failed to load map: check map_style_url in config.json has a valid URL and API key\", e.error);\r\n            onError?.(new Error(LocationShareError.MapStyleUrlNotReachable));\r\n        });\r\n\r\n        return map;\r\n    } catch (e) {\r\n        logger.error(\"Failed to render map\", e);\r\n        const errorMessage = (e as Error)?.message;\r\n        if (errorMessage.includes(\"Failed to initialize WebGL\")) throw new Error(LocationShareError.WebGLNotEnabled);\r\n        throw e;\r\n    }\r\n};\r\n\r\nexport const createMarker = (coords: GeolocationCoordinates, element: HTMLElement): maplibregl.Marker => {\r\n    const marker = new maplibregl.Marker({\r\n        element,\r\n        anchor: \"bottom\",\r\n        offset: [0, -1],\r\n    }).setLngLat({ lon: coords.longitude, lat: coords.latitude });\r\n    return marker;\r\n};\r\n"],"names":["useMapWithStyle","id","centerGeoUri","onError","interactive","bounds","allowGeolocate","bodyId","context","useContext","MatrixClientContext","mapStyleUrl","useEventEmitterState","ClientEvent","ClientWellKnown","clientWellKnown","_tileServerFromWellKn","tileServerFromWellKnown","map","useMap","cli","useMatrixClientContext","setMap","useState","useEffect","createMap","error","console","Error","remove","undefined","setStyle","coords","parseGeoUri","setCenter","lon","longitude","lat","latitude","e","logger","lngLatBounds","maplibregl","west","south","east","north","fitBounds","padding","maxZoom","geolocate","setGeolocate","positionOptions","enableHighAccuracy","trackUserLocation","addControl","removeControl","on","onGeolocateError","off","_positionFailureMessa","Modal","createDialog","ErrorDialog","title","_t","description","positionFailureMessage","code","MapComponent","children","className","onClick","React","classNames","event","target","classList","contains","client","styleUrl","findMapStyleUrl","container","style","zoom","attributionControl","locale","LocationShareError","MapStyleUrlNotReachable","message","includes","WebGLNotEnabled","createMarker","element","anchor","offset","setLngLat"],"sourceRoot":""}