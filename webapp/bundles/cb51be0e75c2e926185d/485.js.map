{"version":3,"file":"bundles/cb51be0e75c2e926185d/485.js","mappings":"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","sources":["webpack://element-web/./node_modules/matrix-js-sdk/src/crypto/store/base.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/crypto/store/indexeddb-crypto-store-backend.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/crypto/store/indexeddb-crypto-store.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/crypto/store/localStorage-crypto-store.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/crypto/store/memory-crypto-store.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/device.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/types.ts"],"sourcesContent":["/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type Logger } from \"../../logger.ts\";\nimport { type CrossSigningKeyInfo } from \"../../crypto-api/index.ts\";\nimport { type AESEncryptedSecretStoragePayload } from \"../../@types/AESEncryptedSecretStoragePayload.ts\";\nimport { type ISignatures } from \"../../@types/signed.ts\";\n\n/**\n * Internal module. Definitions for storage for the crypto module\n */\n\nexport interface SecretStorePrivateKeys {\n    \"m.megolm_backup.v1\": AESEncryptedSecretStoragePayload;\n}\n\n/**\n * Abstraction of things that can store data required for end-to-end encryption\n */\nexport interface CryptoStore {\n    /**\n     * Returns true if this CryptoStore has ever been initialised (ie, it might contain data).\n     *\n     * Unlike the rest of the methods in this interface, can be called before {@link CryptoStore#startup}.\n     *\n     * @internal\n     */\n    containsData(): Promise<boolean>;\n\n    /**\n     * Initialise this crypto store.\n     *\n     * Typically, this involves provisioning storage, and migrating any existing data to the current version of the\n     * storage schema where appropriate.\n     *\n     * Must be called before any of the rest of the methods in this interface.\n     */\n    startup(): Promise<CryptoStore>;\n\n    deleteAllData(): Promise<void>;\n\n    /**\n     * Get data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * @internal\n     */\n    getMigrationState(): Promise<MigrationState>;\n\n    /**\n     * Set data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * @internal\n     */\n    setMigrationState(migrationState: MigrationState): Promise<void>;\n\n    // Olm Account\n    getAccount(txn: unknown, func: (accountPickle: string | null) => void): void;\n    storeAccount(txn: unknown, accountPickle: string): void;\n    getCrossSigningKeys(txn: unknown, func: (keys: Record<string, CrossSigningKeyInfo> | null) => void): void;\n    getSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: unknown,\n        func: (key: SecretStorePrivateKeys[K] | null) => void,\n        type: K,\n    ): void;\n    storeSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: unknown,\n        type: K,\n        key: SecretStorePrivateKeys[K],\n    ): void;\n\n    // Olm Sessions\n    countEndToEndSessions(txn: unknown, func: (count: number) => void): void;\n    getEndToEndSession(\n        deviceKey: string,\n        sessionId: string,\n        txn: unknown,\n        func: (session: ISessionInfo | null) => void,\n    ): void;\n    getEndToEndSessions(\n        deviceKey: string,\n        txn: unknown,\n        func: (sessions: { [sessionId: string]: ISessionInfo }) => void,\n    ): void;\n\n    storeEndToEndSession(deviceKey: string, sessionId: string, sessionInfo: ISessionInfo, txn: unknown): void;\n\n    /**\n     * Get a batch of end-to-end sessions from the database.\n     *\n     * @returns A batch of Olm Sessions, or `null` if no sessions are left.\n     * @internal\n     */\n    getEndToEndSessionsBatch(): Promise<ISessionInfo[] | null>;\n\n    /**\n     * Delete a batch of end-to-end sessions from the database.\n     *\n     * Any sessions in the list which are not found are silently ignored.\n     *\n     * @internal\n     */\n    deleteEndToEndSessionsBatch(sessions: { deviceKey?: string; sessionId?: string }[]): Promise<void>;\n\n    // Inbound Group Sessions\n    getEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        txn: unknown,\n        func: (groupSession: InboundGroupSessionData | null, groupSessionWithheld: IWithheld | null) => void,\n    ): void;\n    storeEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        sessionData: InboundGroupSessionData,\n        txn: unknown,\n    ): void;\n\n    /**\n     * Count the number of Megolm sessions in the database.\n     *\n     * @internal\n     */\n    countEndToEndInboundGroupSessions(): Promise<number>;\n\n    /**\n     * Get a batch of Megolm sessions from the database.\n     *\n     * @returns A batch of Megolm Sessions, or `null` if no sessions are left.\n     * @internal\n     */\n    getEndToEndInboundGroupSessionsBatch(): Promise<SessionExtended[] | null>;\n\n    /**\n     * Delete a batch of Megolm sessions from the database.\n     *\n     * Any sessions in the list which are not found are silently ignored.\n     *\n     * @internal\n     */\n    deleteEndToEndInboundGroupSessionsBatch(sessions: { senderKey: string; sessionId: string }[]): Promise<void>;\n\n    // Device Data\n    getEndToEndRooms(txn: unknown, func: (rooms: Record<string, IRoomEncryption>) => void): void;\n    markSessionsNeedingBackup(sessions: ISession[], txn?: unknown): Promise<void>;\n\n    // Session key backups\n    doTxn<T>(mode: Mode, stores: Iterable<string>, func: (txn: unknown) => T, log?: Logger): Promise<T>;\n}\n\nexport type Mode = \"readonly\" | \"readwrite\";\n\n/** Data on a Megolm session */\nexport interface ISession {\n    senderKey: string;\n    sessionId: string;\n    sessionData?: InboundGroupSessionData;\n}\n\n/** Extended data on a Megolm session */\nexport interface SessionExtended extends ISession {\n    needsBackup: boolean;\n}\n\n/** Data on an Olm session */\nexport interface ISessionInfo {\n    deviceKey?: string;\n    sessionId?: string;\n    session?: string;\n    lastReceivedMessageTs?: number;\n}\n\nexport interface IDeviceData {\n    devices: {\n        [userId: string]: {\n            [deviceId: string]: IDevice;\n        };\n    };\n    trackingStatus: {\n        [userId: string]: TrackingStatus;\n    };\n    crossSigningInfo?: Record<string, ICrossSigningInfo>;\n    syncToken?: string;\n}\n\nexport interface IWithheld {\n    // eslint-disable-next-line camelcase\n    room_id: string;\n    code: string;\n    reason: string;\n}\n\n/**\n * Represents an outgoing room key request\n */\nexport interface OutgoingRoomKeyRequest {\n    /**\n     * Unique id for this request. Used for both an id within the request for later pairing with a cancellation,\n     * and for the transaction id when sending the to_device messages to our local server.\n     */\n    requestId: string;\n    requestTxnId?: string;\n    /**\n     * Transaction id for the cancellation, if any\n     */\n    cancellationTxnId?: string;\n    /**\n     * List of recipients for the request\n     */\n    recipients: IRoomKeyRequestRecipient[];\n    /**\n     * Parameters for the request\n     */\n    requestBody: IRoomKeyRequestBody;\n    /**\n     * current state of this request\n     */\n    state: RoomKeyRequestState;\n}\n\n/**\n * Keys for the `account` object store to store the migration state.\n * Values are defined in `MigrationState`.\n * @internal\n */\nexport const ACCOUNT_OBJECT_KEY_MIGRATION_STATE = \"migrationState\";\n\n/**\n * A record of which steps have been completed in the libolm to Rust Crypto migration.\n *\n * Used by {@link CryptoStore#getMigrationState} and {@link CryptoStore#setMigrationState}.\n *\n * @internal\n */\nexport enum MigrationState {\n    /** No migration steps have yet been completed. */\n    NOT_STARTED,\n\n    /** We have migrated the account data, cross-signing keys, etc. */\n    INITIAL_DATA_MIGRATED,\n\n    /** INITIAL_DATA_MIGRATED, and in addition, we have migrated all the Olm sessions. */\n    OLM_SESSIONS_MIGRATED,\n\n    /** OLM_SESSIONS_MIGRATED, and in addition, we have migrated all the Megolm sessions. */\n    MEGOLM_SESSIONS_MIGRATED,\n\n    /** MEGOLM_SESSIONS_MIGRATED, and in addition, we have migrated all the room settings. */\n    ROOM_SETTINGS_MIGRATED,\n\n    /** ROOM_SETTINGS_MIGRATED, and in addition, we have done the first own keys query in order to\n     * load the public part of the keys that have been migrated */\n    INITIAL_OWN_KEY_QUERY_DONE,\n}\n\n/**\n * The size of batches to be returned by {@link CryptoStore#getEndToEndSessionsBatch} and\n * {@link CryptoStore#getEndToEndInboundGroupSessionsBatch}.\n */\nexport const SESSION_BATCH_SIZE = 50;\n\nexport interface InboundGroupSessionData {\n    room_id: string; // eslint-disable-line camelcase\n    /** pickled Olm.InboundGroupSession */\n    session: string;\n    keysClaimed?: Record<string, string>;\n    /** Devices involved in forwarding this session to us (normally empty). */\n    forwardingCurve25519KeyChain: string[];\n    /** whether this session is untrusted. */\n    untrusted?: boolean;\n    /** whether this session exists during the room being set to shared history. */\n    sharedHistory?: boolean;\n}\n\nexport interface ICrossSigningInfo {\n    keys: Record<string, CrossSigningKeyInfo>;\n    firstUse: boolean;\n    crossSigningVerifiedBefore: boolean;\n}\n\n/* eslint-disable camelcase */\nexport interface IRoomEncryption {\n    algorithm: string;\n    rotation_period_ms?: number;\n    rotation_period_msgs?: number;\n}\n/* eslint-enable camelcase */\n\nexport enum TrackingStatus {\n    NotTracked,\n    PendingDownload,\n    DownloadInProgress,\n    UpToDate,\n}\n\n/**\n *  possible states for a room key request\n *\n * The state machine looks like:\n * ```\n *\n *     |         (cancellation sent)\n *     | .-------------------------------------------------.\n *     | |                                                 |\n *     V V       (cancellation requested)                  |\n *   UNSENT  -----------------------------+                |\n *     |                                  |                |\n *     |                                  |                |\n *     | (send successful)                |  CANCELLATION_PENDING_AND_WILL_RESEND\n *     V                                  |                Î›\n *    SENT                                |                |\n *     |--------------------------------  |  --------------'\n *     |                                  |  (cancellation requested with intent\n *     |                                  |   to resend the original request)\n *     |                                  |\n *     | (cancellation requested)         |\n *     V                                  |\n * CANCELLATION_PENDING                   |\n *     |                                  |\n *     | (cancellation sent)              |\n *     V                                  |\n * (deleted)  <---------------------------+\n * ```\n */\nexport enum RoomKeyRequestState {\n    /** request not yet sent */\n    Unsent,\n    /** request sent, awaiting reply */\n    Sent,\n    /** reply received, cancellation not yet sent */\n    CancellationPending,\n    /**\n     * Cancellation not yet sent and will transition to UNSENT instead of\n     * being deleted once the cancellation has been sent.\n     */\n    CancellationPendingAndWillResend,\n}\n\n/* eslint-disable camelcase */\ninterface IRoomKey {\n    room_id: string;\n    algorithm: string;\n}\n\n/**\n * The parameters of a room key request. The details of the request may\n * vary with the crypto algorithm, but the management and storage layers for\n * outgoing requests expect it to have 'room_id' and 'session_id' properties.\n */\nexport interface IRoomKeyRequestBody extends IRoomKey {\n    session_id: string;\n    sender_key: string;\n}\n\n/* eslint-enable camelcase */\n\nexport interface IRoomKeyRequestRecipient {\n    userId: string;\n    deviceId: string;\n}\n\ninterface IDevice {\n    keys: Record<string, string>;\n    algorithms: string[];\n    verified: DeviceVerification;\n    known: boolean;\n    unsigned?: Record<string, any>;\n    signatures?: ISignatures;\n}\n\n/** State of the verification of the device. */\nexport enum DeviceVerification {\n    Blocked = -1,\n    Unverified = 0,\n    Verified = 1,\n}\n","/*\nCopyright 2017 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type Logger, logger } from \"../../logger.ts\";\nimport {\n    type CryptoStore,\n    type IDeviceData,\n    type ISession,\n    type SessionExtended,\n    type ISessionInfo,\n    type IWithheld,\n    MigrationState,\n    type Mode,\n    type SecretStorePrivateKeys,\n    SESSION_BATCH_SIZE,\n    ACCOUNT_OBJECT_KEY_MIGRATION_STATE,\n    type InboundGroupSessionData,\n    type IRoomEncryption,\n} from \"./base.ts\";\nimport { IndexedDBCryptoStore } from \"./indexeddb-crypto-store.ts\";\nimport { type CrossSigningKeyInfo } from \"../../crypto-api/index.ts\";\n\nconst PROFILE_TRANSACTIONS = false;\n\n/**\n * Implementation of a CryptoStore which is backed by an existing\n * IndexedDB connection. Generally you want IndexedDBCryptoStore\n * which connects to the database and defers to one of these.\n *\n * @internal\n */\nexport class Backend implements CryptoStore {\n    private nextTxnId = 0;\n\n    /**\n     */\n    public constructor(private db: IDBDatabase) {\n        // make sure we close the db on `onversionchange` - otherwise\n        // attempts to delete the database will block (and subsequent\n        // attempts to re-create it will also block).\n        db.onversionchange = (): void => {\n            logger.log(`versionchange for indexeddb ${this.db.name}: closing`);\n            db.close();\n        };\n    }\n\n    public async containsData(): Promise<boolean> {\n        throw Error(\"Not implemented for Backend\");\n    }\n\n    public async startup(): Promise<CryptoStore> {\n        // No work to do, as the startup is done by the caller (e.g IndexedDBCryptoStore)\n        // by passing us a ready IDBDatabase instance\n        return this;\n    }\n\n    public async deleteAllData(): Promise<void> {\n        throw Error(\"This is not implemented, call IDBFactory::deleteDatabase(dbName) instead.\");\n    }\n\n    /**\n     * Get data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * Implementation of {@link CryptoStore.getMigrationState}.\n     */\n    public async getMigrationState(): Promise<MigrationState> {\n        let migrationState = MigrationState.NOT_STARTED;\n        await this.doTxn(\"readonly\", [IndexedDBCryptoStore.STORE_ACCOUNT], (txn) => {\n            const objectStore = txn.objectStore(IndexedDBCryptoStore.STORE_ACCOUNT);\n            const getReq = objectStore.get(ACCOUNT_OBJECT_KEY_MIGRATION_STATE);\n            getReq.onsuccess = (): void => {\n                migrationState = getReq.result ?? MigrationState.NOT_STARTED;\n            };\n        });\n        return migrationState;\n    }\n\n    /**\n     * Set data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * Implementation of {@link CryptoStore.setMigrationState}.\n     */\n    public async setMigrationState(migrationState: MigrationState): Promise<void> {\n        await this.doTxn(\"readwrite\", [IndexedDBCryptoStore.STORE_ACCOUNT], (txn) => {\n            const objectStore = txn.objectStore(IndexedDBCryptoStore.STORE_ACCOUNT);\n            objectStore.put(migrationState, ACCOUNT_OBJECT_KEY_MIGRATION_STATE);\n        });\n    }\n\n    // Olm Account\n\n    public getAccount(txn: IDBTransaction, func: (accountPickle: string | null) => void): void {\n        const objectStore = txn.objectStore(\"account\");\n        const getReq = objectStore.get(\"-\");\n        getReq.onsuccess = function (): void {\n            try {\n                func(getReq.result || null);\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        };\n    }\n\n    public storeAccount(txn: IDBTransaction, accountPickle: string): void {\n        const objectStore = txn.objectStore(\"account\");\n        objectStore.put(accountPickle, \"-\");\n    }\n\n    public getCrossSigningKeys(\n        txn: IDBTransaction,\n        func: (keys: Record<string, CrossSigningKeyInfo> | null) => void,\n    ): void {\n        const objectStore = txn.objectStore(\"account\");\n        const getReq = objectStore.get(\"crossSigningKeys\");\n        getReq.onsuccess = function (): void {\n            try {\n                func(getReq.result || null);\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        };\n    }\n\n    public getSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: IDBTransaction,\n        func: (key: SecretStorePrivateKeys[K] | null) => void,\n        type: K,\n    ): void {\n        const objectStore = txn.objectStore(\"account\");\n        const getReq = objectStore.get(`ssss_cache:${type}`);\n        getReq.onsuccess = function (): void {\n            try {\n                func(getReq.result || null);\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        };\n    }\n\n    public storeSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: IDBTransaction,\n        type: K,\n        key: SecretStorePrivateKeys[K],\n    ): void {\n        const objectStore = txn.objectStore(\"account\");\n        objectStore.put(key, `ssss_cache:${type}`);\n    }\n\n    // Olm Sessions\n\n    public countEndToEndSessions(txn: IDBTransaction, func: (count: number) => void): void {\n        const objectStore = txn.objectStore(\"sessions\");\n        const countReq = objectStore.count();\n        countReq.onsuccess = function (): void {\n            try {\n                func(countReq.result);\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        };\n    }\n\n    public getEndToEndSessions(\n        deviceKey: string,\n        txn: IDBTransaction,\n        func: (sessions: { [sessionId: string]: ISessionInfo }) => void,\n    ): void {\n        const objectStore = txn.objectStore(\"sessions\");\n        const idx = objectStore.index(\"deviceKey\");\n        const getReq = idx.openCursor(deviceKey);\n        const results: Parameters<Parameters<Backend[\"getEndToEndSessions\"]>[2]>[0] = {};\n        getReq.onsuccess = function (): void {\n            const cursor = getReq.result;\n            if (cursor) {\n                results[cursor.value.sessionId] = {\n                    session: cursor.value.session,\n                    lastReceivedMessageTs: cursor.value.lastReceivedMessageTs,\n                };\n                cursor.continue();\n            } else {\n                try {\n                    func(results);\n                } catch (e) {\n                    abortWithException(txn, <Error>e);\n                }\n            }\n        };\n    }\n\n    public getEndToEndSession(\n        deviceKey: string,\n        sessionId: string,\n        txn: IDBTransaction,\n        func: (session: ISessionInfo | null) => void,\n    ): void {\n        const objectStore = txn.objectStore(\"sessions\");\n        const getReq = objectStore.get([deviceKey, sessionId]);\n        getReq.onsuccess = function (): void {\n            try {\n                if (getReq.result) {\n                    func({\n                        session: getReq.result.session,\n                        lastReceivedMessageTs: getReq.result.lastReceivedMessageTs,\n                    });\n                } else {\n                    func(null);\n                }\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        };\n    }\n\n    public storeEndToEndSession(\n        deviceKey: string,\n        sessionId: string,\n        sessionInfo: ISessionInfo,\n        txn: IDBTransaction,\n    ): void {\n        const objectStore = txn.objectStore(\"sessions\");\n        objectStore.put({\n            deviceKey,\n            sessionId,\n            session: sessionInfo.session,\n            lastReceivedMessageTs: sessionInfo.lastReceivedMessageTs,\n        });\n    }\n\n    /**\n     * Fetch a batch of Olm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.getEndToEndSessionsBatch}.\n     */\n    public async getEndToEndSessionsBatch(): Promise<null | ISessionInfo[]> {\n        const result: ISessionInfo[] = [];\n        await this.doTxn(\"readonly\", [IndexedDBCryptoStore.STORE_SESSIONS], (txn) => {\n            const objectStore = txn.objectStore(IndexedDBCryptoStore.STORE_SESSIONS);\n            const getReq = objectStore.openCursor();\n            getReq.onsuccess = function (): void {\n                try {\n                    const cursor = getReq.result;\n                    if (cursor) {\n                        result.push(cursor.value);\n                        if (result.length < SESSION_BATCH_SIZE) {\n                            cursor.continue();\n                        }\n                    }\n                } catch (e) {\n                    abortWithException(txn, <Error>e);\n                }\n            };\n        });\n\n        if (result.length === 0) {\n            // No sessions left.\n            return null;\n        }\n\n        return result;\n    }\n\n    /**\n     * Delete a batch of Olm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.deleteEndToEndSessionsBatch}.\n     *\n     * @internal\n     */\n    public async deleteEndToEndSessionsBatch(sessions: { deviceKey: string; sessionId: string }[]): Promise<void> {\n        await this.doTxn(\"readwrite\", [IndexedDBCryptoStore.STORE_SESSIONS], async (txn) => {\n            try {\n                const objectStore = txn.objectStore(IndexedDBCryptoStore.STORE_SESSIONS);\n                for (const { deviceKey, sessionId } of sessions) {\n                    const req = objectStore.delete([deviceKey, sessionId]);\n                    await new Promise((resolve) => {\n                        req.onsuccess = resolve;\n                    });\n                }\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        });\n    }\n\n    // Inbound group sessions\n\n    public getEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        txn: IDBTransaction,\n        func: (groupSession: InboundGroupSessionData | null, groupSessionWithheld: IWithheld | null) => void,\n    ): void {\n        let session: InboundGroupSessionData | null | boolean = false;\n        let withheld: IWithheld | null | boolean = false;\n        const objectStore = txn.objectStore(\"inbound_group_sessions\");\n        const getReq = objectStore.get([senderCurve25519Key, sessionId]);\n        getReq.onsuccess = function (): void {\n            try {\n                if (getReq.result) {\n                    session = getReq.result.session;\n                } else {\n                    session = null;\n                }\n                if (withheld !== false) {\n                    func(session as InboundGroupSessionData, withheld as IWithheld);\n                }\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        };\n\n        const withheldObjectStore = txn.objectStore(\"inbound_group_sessions_withheld\");\n        const withheldGetReq = withheldObjectStore.get([senderCurve25519Key, sessionId]);\n        withheldGetReq.onsuccess = function (): void {\n            try {\n                if (withheldGetReq.result) {\n                    withheld = withheldGetReq.result.session;\n                } else {\n                    withheld = null;\n                }\n                if (session !== false) {\n                    func(session as InboundGroupSessionData, withheld as IWithheld);\n                }\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        };\n    }\n\n    public storeEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        sessionData: InboundGroupSessionData,\n        txn: IDBTransaction,\n    ): void {\n        const objectStore = txn.objectStore(\"inbound_group_sessions\");\n        objectStore.put({\n            senderCurve25519Key,\n            sessionId,\n            session: sessionData,\n        });\n    }\n\n    /**\n     * Count the number of Megolm sessions in the database.\n     *\n     * Implementation of {@link CryptoStore.countEndToEndInboundGroupSessions}.\n     *\n     * @internal\n     */\n    public async countEndToEndInboundGroupSessions(): Promise<number> {\n        let result = 0;\n        await this.doTxn(\"readonly\", [IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS], (txn) => {\n            const sessionStore = txn.objectStore(IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS);\n            const countReq = sessionStore.count();\n            countReq.onsuccess = (): void => {\n                result = countReq.result;\n            };\n        });\n        return result;\n    }\n\n    /**\n     * Fetch a batch of Megolm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.getEndToEndInboundGroupSessionsBatch}.\n     */\n    public async getEndToEndInboundGroupSessionsBatch(): Promise<null | SessionExtended[]> {\n        const result: SessionExtended[] = [];\n        await this.doTxn(\n            \"readonly\",\n            [IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, IndexedDBCryptoStore.STORE_BACKUP],\n            (txn) => {\n                const sessionStore = txn.objectStore(IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS);\n                const backupStore = txn.objectStore(IndexedDBCryptoStore.STORE_BACKUP);\n\n                const getReq = sessionStore.openCursor();\n                getReq.onsuccess = function (): void {\n                    try {\n                        const cursor = getReq.result;\n                        if (cursor) {\n                            const backupGetReq = backupStore.get(cursor.key);\n                            backupGetReq.onsuccess = (): void => {\n                                result.push({\n                                    senderKey: cursor.value.senderCurve25519Key,\n                                    sessionId: cursor.value.sessionId,\n                                    sessionData: cursor.value.session,\n                                    needsBackup: backupGetReq.result !== undefined,\n                                });\n                                if (result.length < SESSION_BATCH_SIZE) {\n                                    cursor.continue();\n                                }\n                            };\n                        }\n                    } catch (e) {\n                        abortWithException(txn, <Error>e);\n                    }\n                };\n            },\n        );\n\n        if (result.length === 0) {\n            // No sessions left.\n            return null;\n        }\n\n        return result;\n    }\n\n    /**\n     * Delete a batch of Megolm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.deleteEndToEndInboundGroupSessionsBatch}.\n     *\n     * @internal\n     */\n    public async deleteEndToEndInboundGroupSessionsBatch(\n        sessions: { senderKey: string; sessionId: string }[],\n    ): Promise<void> {\n        await this.doTxn(\"readwrite\", [IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS], async (txn) => {\n            try {\n                const objectStore = txn.objectStore(IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS);\n                for (const { senderKey, sessionId } of sessions) {\n                    const req = objectStore.delete([senderKey, sessionId]);\n                    await new Promise((resolve) => {\n                        req.onsuccess = resolve;\n                    });\n                }\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        });\n    }\n\n    public getEndToEndDeviceData(txn: IDBTransaction, func: (deviceData: IDeviceData | null) => void): void {\n        const objectStore = txn.objectStore(\"device_data\");\n        const getReq = objectStore.get(\"-\");\n        getReq.onsuccess = function (): void {\n            try {\n                func(getReq.result || null);\n            } catch (e) {\n                abortWithException(txn, <Error>e);\n            }\n        };\n    }\n\n    public getEndToEndRooms(txn: IDBTransaction, func: (rooms: Record<string, IRoomEncryption>) => void): void {\n        const rooms: Parameters<Parameters<Backend[\"getEndToEndRooms\"]>[1]>[0] = {};\n        const objectStore = txn.objectStore(\"rooms\");\n        const getReq = objectStore.openCursor();\n        getReq.onsuccess = function (): void {\n            const cursor = getReq.result;\n            if (cursor) {\n                rooms[cursor.key as string] = cursor.value;\n                cursor.continue();\n            } else {\n                try {\n                    func(rooms);\n                } catch (e) {\n                    abortWithException(txn, <Error>e);\n                }\n            }\n        };\n    }\n\n    public async markSessionsNeedingBackup(sessions: ISession[], txn?: IDBTransaction): Promise<void> {\n        if (!txn) {\n            txn = this.db.transaction(\"sessions_needing_backup\", \"readwrite\");\n        }\n        const objectStore = txn.objectStore(\"sessions_needing_backup\");\n        await Promise.all(\n            sessions.map((session) => {\n                return new Promise((resolve, reject) => {\n                    const req = objectStore.put({\n                        senderCurve25519Key: session.senderKey,\n                        sessionId: session.sessionId,\n                    });\n                    req.onsuccess = resolve;\n                    req.onerror = reject;\n                });\n            }),\n        );\n    }\n\n    public doTxn<T>(\n        mode: Mode,\n        stores: string | string[],\n        func: (txn: IDBTransaction) => T,\n        log: Logger = logger,\n    ): Promise<T> {\n        let startTime: number;\n        let description: string;\n        if (PROFILE_TRANSACTIONS) {\n            const txnId = this.nextTxnId++;\n            startTime = Date.now();\n            description = `${mode} crypto store transaction ${txnId} in ${stores}`;\n            log.debug(`Starting ${description}`);\n        }\n        const txn = this.db.transaction(stores, mode);\n        const promise = promiseifyTxn(txn);\n        const result = func(txn);\n        if (PROFILE_TRANSACTIONS) {\n            promise.then(\n                () => {\n                    const elapsedTime = Date.now() - startTime;\n                    log.debug(`Finished ${description}, took ${elapsedTime} ms`);\n                },\n                () => {\n                    const elapsedTime = Date.now() - startTime;\n                    log.error(`Failed ${description}, took ${elapsedTime} ms`);\n                },\n            );\n        }\n        return promise.then(() => {\n            return result;\n        });\n    }\n}\n\ntype DbMigration = (db: IDBDatabase) => void;\nconst DB_MIGRATIONS: DbMigration[] = [\n    (db): void => {\n        createDatabase(db);\n    },\n    (db): void => {\n        db.createObjectStore(\"account\");\n    },\n    (db): void => {\n        const sessionsStore = db.createObjectStore(\"sessions\", {\n            keyPath: [\"deviceKey\", \"sessionId\"],\n        });\n        sessionsStore.createIndex(\"deviceKey\", \"deviceKey\");\n    },\n    (db): void => {\n        db.createObjectStore(\"inbound_group_sessions\", {\n            keyPath: [\"senderCurve25519Key\", \"sessionId\"],\n        });\n    },\n    (db): void => {\n        db.createObjectStore(\"device_data\");\n    },\n    (db): void => {\n        db.createObjectStore(\"rooms\");\n    },\n    (db): void => {\n        db.createObjectStore(\"sessions_needing_backup\", {\n            keyPath: [\"senderCurve25519Key\", \"sessionId\"],\n        });\n    },\n    (db): void => {\n        db.createObjectStore(\"inbound_group_sessions_withheld\", {\n            keyPath: [\"senderCurve25519Key\", \"sessionId\"],\n        });\n    },\n    (db): void => {\n        const problemsStore = db.createObjectStore(\"session_problems\", {\n            keyPath: [\"deviceKey\", \"time\"],\n        });\n        problemsStore.createIndex(\"deviceKey\", \"deviceKey\");\n\n        db.createObjectStore(\"notified_error_devices\", {\n            keyPath: [\"userId\", \"deviceId\"],\n        });\n    },\n    (db): void => {\n        db.createObjectStore(\"shared_history_inbound_group_sessions\", {\n            keyPath: [\"roomId\"],\n        });\n    },\n    (db): void => {\n        db.createObjectStore(\"parked_shared_history\", {\n            keyPath: [\"roomId\"],\n        });\n    },\n    // Expand as needed.\n];\nexport const VERSION = DB_MIGRATIONS.length;\n\nexport function upgradeDatabase(db: IDBDatabase, oldVersion: number): void {\n    logger.log(`Upgrading IndexedDBCryptoStore from version ${oldVersion}` + ` to ${VERSION}`);\n    DB_MIGRATIONS.forEach((migration, index) => {\n        if (oldVersion <= index) migration(db);\n    });\n}\n\nfunction createDatabase(db: IDBDatabase): void {\n    const outgoingRoomKeyRequestsStore = db.createObjectStore(\"outgoingRoomKeyRequests\", { keyPath: \"requestId\" });\n\n    // we assume that the RoomKeyRequestBody will have room_id and session_id\n    // properties, to make the index efficient.\n    outgoingRoomKeyRequestsStore.createIndex(\"session\", [\"requestBody.room_id\", \"requestBody.session_id\"]);\n\n    outgoingRoomKeyRequestsStore.createIndex(\"state\", \"state\");\n}\n\ninterface IWrappedIDBTransaction extends IDBTransaction {\n    _mx_abortexception: Error; // eslint-disable-line camelcase\n}\n\n/*\n * Aborts a transaction with a given exception\n * The transaction promise will be rejected with this exception.\n */\nfunction abortWithException(txn: IDBTransaction, e: Error): void {\n    // We cheekily stick our exception onto the transaction object here\n    // We could alternatively make the thing we pass back to the app\n    // an object containing the transaction and exception.\n    (txn as IWrappedIDBTransaction)._mx_abortexception = e;\n    try {\n        txn.abort();\n    } catch {\n        // sometimes we won't be able to abort the transaction\n        // (ie. if it's aborted or completed)\n    }\n}\n\nfunction promiseifyTxn<T>(txn: IDBTransaction): Promise<T | null> {\n    return new Promise((resolve, reject) => {\n        txn.oncomplete = (): void => {\n            if ((txn as IWrappedIDBTransaction)._mx_abortexception !== undefined) {\n                reject((txn as IWrappedIDBTransaction)._mx_abortexception);\n            }\n            resolve(null);\n        };\n        txn.onerror = (event): void => {\n            if ((txn as IWrappedIDBTransaction)._mx_abortexception !== undefined) {\n                reject((txn as IWrappedIDBTransaction)._mx_abortexception);\n            } else {\n                logger.log(\"Error performing indexeddb txn\", event);\n                reject(txn.error);\n            }\n        };\n        txn.onabort = (event): void => {\n            if ((txn as IWrappedIDBTransaction)._mx_abortexception !== undefined) {\n                reject((txn as IWrappedIDBTransaction)._mx_abortexception);\n            } else {\n                logger.log(\"Error performing indexeddb txn\", event);\n                reject(txn.error);\n            }\n        };\n    });\n}\n","/*\nCopyright 2017 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { logger, type Logger } from \"../../logger.ts\";\nimport { LocalStorageCryptoStore } from \"./localStorage-crypto-store.ts\";\nimport { MemoryCryptoStore } from \"./memory-crypto-store.ts\";\nimport * as IndexedDBCryptoStoreBackend from \"./indexeddb-crypto-store-backend.ts\";\nimport { InvalidCryptoStoreError, InvalidCryptoStoreState } from \"../../errors.ts\";\nimport * as IndexedDBHelpers from \"../../indexeddb-helpers.ts\";\nimport {\n    type CryptoStore,\n    type ISession,\n    type SessionExtended,\n    type ISessionInfo,\n    type IWithheld,\n    MigrationState,\n    type Mode,\n    type SecretStorePrivateKeys,\n    ACCOUNT_OBJECT_KEY_MIGRATION_STATE,\n    type InboundGroupSessionData,\n    type IRoomEncryption,\n} from \"./base.ts\";\nimport { type CrossSigningKeyInfo } from \"../../crypto-api/index.ts\";\n\n/*\n * Internal module. indexeddb storage for e2e.\n */\n\n/**\n * An implementation of CryptoStore, which is normally backed by an indexeddb,\n * but with fallback to MemoryCryptoStore.\n */\nexport class IndexedDBCryptoStore implements CryptoStore {\n    public static STORE_ACCOUNT = \"account\";\n    public static STORE_SESSIONS = \"sessions\";\n    public static STORE_INBOUND_GROUP_SESSIONS = \"inbound_group_sessions\";\n    public static STORE_INBOUND_GROUP_SESSIONS_WITHHELD = \"inbound_group_sessions_withheld\";\n    public static STORE_SHARED_HISTORY_INBOUND_GROUP_SESSIONS = \"shared_history_inbound_group_sessions\";\n    public static STORE_PARKED_SHARED_HISTORY = \"parked_shared_history\";\n    public static STORE_DEVICE_DATA = \"device_data\";\n    public static STORE_ROOMS = \"rooms\";\n    public static STORE_BACKUP = \"sessions_needing_backup\";\n\n    public static exists(indexedDB: IDBFactory, dbName: string): Promise<boolean> {\n        return IndexedDBHelpers.exists(indexedDB, dbName);\n    }\n\n    /**\n     * Utility to check if a legacy crypto store exists and has not been migrated.\n     * Returns true if the store exists and has not been migrated, false otherwise.\n     */\n    public static existsAndIsNotMigrated(indexedDb: IDBFactory, dbName: string): Promise<boolean> {\n        return new Promise<boolean>((resolve, reject) => {\n            let exists = true;\n            const openDBRequest = indexedDb.open(dbName);\n            openDBRequest.onupgradeneeded = (): void => {\n                // Since we did not provide an explicit version when opening, this event\n                // should only fire if the DB did not exist before at any version.\n                exists = false;\n            };\n            openDBRequest.onblocked = (): void => reject(openDBRequest.error);\n            openDBRequest.onsuccess = (): void => {\n                const db = openDBRequest.result;\n                if (!exists) {\n                    db.close();\n                    // The DB did not exist before, but has been created as part of this\n                    // existence check. Delete it now to restore previous state. Delete can\n                    // actually take a while to complete in some browsers, so don't wait for\n                    // it. This won't block future open calls that a store might issue next to\n                    // properly set up the DB.\n                    indexedDb.deleteDatabase(dbName);\n                    resolve(false);\n                } else {\n                    const tx = db.transaction([IndexedDBCryptoStore.STORE_ACCOUNT], \"readonly\");\n                    const objectStore = tx.objectStore(IndexedDBCryptoStore.STORE_ACCOUNT);\n                    const getReq = objectStore.get(ACCOUNT_OBJECT_KEY_MIGRATION_STATE);\n\n                    getReq.onsuccess = (): void => {\n                        const migrationState = getReq.result ?? MigrationState.NOT_STARTED;\n                        resolve(migrationState === MigrationState.NOT_STARTED);\n                    };\n\n                    getReq.onerror = (): void => {\n                        reject(getReq.error);\n                    };\n\n                    db.close();\n                }\n            };\n            openDBRequest.onerror = (): void => reject(openDBRequest.error);\n        });\n    }\n\n    private backendPromise?: Promise<CryptoStore>;\n    private backend?: CryptoStore;\n\n    /**\n     * Create a new IndexedDBCryptoStore\n     *\n     * @param indexedDB -  global indexedDB instance\n     * @param dbName -   name of db to connect to\n     */\n    public constructor(\n        private readonly indexedDB: IDBFactory,\n        private readonly dbName: string,\n    ) {}\n\n    /**\n     * Returns true if this CryptoStore has ever been initialised (ie, it might contain data).\n     *\n     * Implementation of {@link CryptoStore.containsData}.\n     *\n     * @internal\n     */\n    public async containsData(): Promise<boolean> {\n        return IndexedDBCryptoStore.exists(this.indexedDB, this.dbName);\n    }\n\n    /**\n     * Ensure the database exists and is up-to-date, or fall back to\n     * a local storage or in-memory store.\n     *\n     * This must be called before the store can be used.\n     *\n     * @returns resolves to either an IndexedDBCryptoStoreBackend.Backend,\n     * or a MemoryCryptoStore\n     */\n    public startup(): Promise<CryptoStore> {\n        if (this.backendPromise) {\n            return this.backendPromise;\n        }\n\n        this.backendPromise = new Promise<CryptoStore>((resolve, reject) => {\n            if (!this.indexedDB) {\n                reject(new Error(\"no indexeddb support available\"));\n                return;\n            }\n\n            logger.log(`connecting to indexeddb ${this.dbName}`);\n\n            const req = this.indexedDB.open(this.dbName, IndexedDBCryptoStoreBackend.VERSION);\n\n            req.onupgradeneeded = (ev): void => {\n                const db = req.result;\n                const oldVersion = ev.oldVersion;\n                IndexedDBCryptoStoreBackend.upgradeDatabase(db, oldVersion);\n            };\n\n            req.onblocked = (): void => {\n                logger.log(`can't yet open IndexedDBCryptoStore because it is open elsewhere`);\n            };\n\n            req.onerror = (ev): void => {\n                logger.log(\"Error connecting to indexeddb\", ev);\n                reject(req.error);\n            };\n\n            req.onsuccess = (): void => {\n                const db = req.result;\n\n                logger.log(`connected to indexeddb ${this.dbName}`);\n                resolve(new IndexedDBCryptoStoreBackend.Backend(db));\n            };\n        })\n            .then((backend) => {\n                // Edge has IndexedDB but doesn't support compund keys which we use fairly extensively.\n                // Try a dummy query which will fail if the browser doesn't support compund keys, so\n                // we can fall back to a different backend.\n                return backend\n                    .doTxn(\n                        \"readonly\",\n                        [\n                            IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS,\n                            IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD,\n                        ],\n                        (txn) => {\n                            backend.getEndToEndInboundGroupSession(\"\", \"\", txn, () => {});\n                        },\n                    )\n                    .then(() => backend);\n            })\n            .catch((e) => {\n                if (e.name === \"VersionError\") {\n                    logger.warn(\"Crypto DB is too new for us to use!\", e);\n                    // don't fall back to a different store: the user has crypto data\n                    // in this db so we should use it or nothing at all.\n                    throw new InvalidCryptoStoreError(InvalidCryptoStoreState.TooNew);\n                }\n                logger.warn(\n                    `unable to connect to indexeddb ${this.dbName}` + `: falling back to localStorage store: ${e}`,\n                );\n\n                try {\n                    if (!(globalThis.localStorage instanceof Storage)) {\n                        throw new Error(\"localStorage is not available\");\n                    }\n                    return new LocalStorageCryptoStore(globalThis.localStorage);\n                } catch (e) {\n                    logger.warn(`Unable to open localStorage: falling back to in-memory store: ${e}`);\n                    return new MemoryCryptoStore();\n                }\n            })\n            .then((backend) => {\n                this.backend = backend;\n                return backend;\n            });\n\n        return this.backendPromise;\n    }\n\n    /**\n     * Delete all data from this store.\n     *\n     * @returns resolves when the store has been cleared.\n     */\n    public deleteAllData(): Promise<void> {\n        return new Promise<void>((resolve, reject) => {\n            if (!this.indexedDB) {\n                reject(new Error(\"no indexeddb support available\"));\n                return;\n            }\n\n            logger.log(`Removing indexeddb instance: ${this.dbName}`);\n            const req = this.indexedDB.deleteDatabase(this.dbName);\n\n            req.onblocked = (): void => {\n                logger.log(`can't yet delete IndexedDBCryptoStore because it is open elsewhere`);\n            };\n\n            req.onerror = (ev): void => {\n                logger.log(\"Error deleting data from indexeddb\", ev);\n                reject(req.error);\n            };\n\n            req.onsuccess = (): void => {\n                logger.log(`Removed indexeddb instance: ${this.dbName}`);\n                resolve();\n            };\n        }).catch((e) => {\n            // in firefox, with indexedDB disabled, this fails with a\n            // DOMError. We treat this as non-fatal, so that people can\n            // still use the app.\n            logger.warn(`unable to delete IndexedDBCryptoStore: ${e}`);\n        });\n    }\n\n    /**\n     * Get data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * Implementation of {@link CryptoStore.getMigrationState}.\n     *\n     * @internal\n     */\n    public getMigrationState(): Promise<MigrationState> {\n        return this.backend!.getMigrationState();\n    }\n\n    /**\n     * Set data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * Implementation of {@link CryptoStore.setMigrationState}.\n     *\n     * @internal\n     */\n    public setMigrationState(migrationState: MigrationState): Promise<void> {\n        return this.backend!.setMigrationState(migrationState);\n    }\n\n    // Olm Account\n\n    /*\n     * Get the account pickle from the store.\n     * This requires an active transaction. See doTxn().\n     *\n     * @param txn - An active transaction. See doTxn().\n     * @param func - Called with the account pickle\n     */\n    public getAccount(txn: IDBTransaction, func: (accountPickle: string | null) => void): void {\n        this.backend!.getAccount(txn, func);\n    }\n\n    /**\n     * Write the account pickle to the store.\n     * This requires an active transaction. See doTxn().\n     *\n     * @param txn - An active transaction. See doTxn().\n     * @param accountPickle - The new account pickle to store.\n     */\n    public storeAccount(txn: IDBTransaction, accountPickle: string): void {\n        this.backend!.storeAccount(txn, accountPickle);\n    }\n\n    /**\n     * Get the public part of the cross-signing keys (eg. self-signing key,\n     * user signing key).\n     *\n     * @param txn - An active transaction. See doTxn().\n     * @param func - Called with the account keys object:\n     *        `{ key_type: base64 encoded seed }` where key type = user_signing_key_seed or self_signing_key_seed\n     */\n    public getCrossSigningKeys(\n        txn: IDBTransaction,\n        func: (keys: Record<string, CrossSigningKeyInfo> | null) => void,\n    ): void {\n        this.backend!.getCrossSigningKeys(txn, func);\n    }\n\n    /**\n     * @param txn - An active transaction. See doTxn().\n     * @param func - Called with the private key\n     * @param type - A key type\n     */\n    public getSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: IDBTransaction,\n        func: (key: SecretStorePrivateKeys[K] | null) => void,\n        type: K,\n    ): void {\n        this.backend!.getSecretStorePrivateKey(txn, func, type);\n    }\n\n    /**\n     * Write the cross-signing private keys back to the store\n     *\n     * @param txn - An active transaction. See doTxn().\n     * @param type - The type of cross-signing private key to store\n     * @param key - keys object as getCrossSigningKeys()\n     */\n    public storeSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: IDBTransaction,\n        type: K,\n        key: SecretStorePrivateKeys[K],\n    ): void {\n        this.backend!.storeSecretStorePrivateKey(txn, type, key);\n    }\n\n    // Olm sessions\n\n    /**\n     * Returns the number of end-to-end sessions in the store\n     * @param txn - An active transaction. See doTxn().\n     * @param func - Called with the count of sessions\n     */\n    public countEndToEndSessions(txn: IDBTransaction, func: (count: number) => void): void {\n        this.backend!.countEndToEndSessions(txn, func);\n    }\n\n    /**\n     * Retrieve a specific end-to-end session between the logged-in user\n     * and another device.\n     * @param deviceKey - The public key of the other device.\n     * @param sessionId - The ID of the session to retrieve\n     * @param txn - An active transaction. See doTxn().\n     * @param func - Called with A map from sessionId\n     *     to session information object with 'session' key being the\n     *     Base64 end-to-end session and lastReceivedMessageTs being the\n     *     timestamp in milliseconds at which the session last received\n     *     a message.\n     */\n    public getEndToEndSession(\n        deviceKey: string,\n        sessionId: string,\n        txn: IDBTransaction,\n        func: (session: ISessionInfo | null) => void,\n    ): void {\n        this.backend!.getEndToEndSession(deviceKey, sessionId, txn, func);\n    }\n\n    /**\n     * Retrieve the end-to-end sessions between the logged-in user and another\n     * device.\n     * @param deviceKey - The public key of the other device.\n     * @param txn - An active transaction. See doTxn().\n     * @param func - Called with A map from sessionId\n     *     to session information object with 'session' key being the\n     *     Base64 end-to-end session and lastReceivedMessageTs being the\n     *     timestamp in milliseconds at which the session last received\n     *     a message.\n     */\n    public getEndToEndSessions(\n        deviceKey: string,\n        txn: IDBTransaction,\n        func: (sessions: { [sessionId: string]: ISessionInfo }) => void,\n    ): void {\n        this.backend!.getEndToEndSessions(deviceKey, txn, func);\n    }\n\n    /**\n     * Store a session between the logged-in user and another device\n     * @param deviceKey - The public key of the other device.\n     * @param sessionId - The ID for this end-to-end session.\n     * @param sessionInfo - Session information object\n     * @param txn - An active transaction. See doTxn().\n     */\n    public storeEndToEndSession(\n        deviceKey: string,\n        sessionId: string,\n        sessionInfo: ISessionInfo,\n        txn: IDBTransaction,\n    ): void {\n        this.backend!.storeEndToEndSession(deviceKey, sessionId, sessionInfo, txn);\n    }\n\n    /**\n     * Count the number of Megolm sessions in the database.\n     *\n     * Implementation of {@link CryptoStore.countEndToEndInboundGroupSessions}.\n     *\n     * @internal\n     */\n    public countEndToEndInboundGroupSessions(): Promise<number> {\n        return this.backend!.countEndToEndInboundGroupSessions();\n    }\n\n    /**\n     * Fetch a batch of Olm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.getEndToEndSessionsBatch}.\n     *\n     * @internal\n     */\n    public getEndToEndSessionsBatch(): Promise<null | ISessionInfo[]> {\n        return this.backend!.getEndToEndSessionsBatch();\n    }\n\n    /**\n     * Delete a batch of Olm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.deleteEndToEndSessionsBatch}.\n     *\n     * @internal\n     */\n    public deleteEndToEndSessionsBatch(sessions: { deviceKey: string; sessionId: string }[]): Promise<void> {\n        return this.backend!.deleteEndToEndSessionsBatch(sessions);\n    }\n\n    // Inbound group sessions\n\n    /**\n     * Retrieve the end-to-end inbound group session for a given\n     * server key and session ID\n     * @param senderCurve25519Key - The sender's curve 25519 key\n     * @param sessionId - The ID of the session\n     * @param txn - An active transaction. See doTxn().\n     * @param func - Called with A map from sessionId\n     *     to Base64 end-to-end session.\n     */\n    public getEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        txn: IDBTransaction,\n        func: (groupSession: InboundGroupSessionData | null, groupSessionWithheld: IWithheld | null) => void,\n    ): void {\n        this.backend!.getEndToEndInboundGroupSession(senderCurve25519Key, sessionId, txn, func);\n    }\n\n    /**\n     * Writes an end-to-end inbound group session to the store.\n     * If there already exists an inbound group session with the same\n     * senderCurve25519Key and sessionID, it will be overwritten.\n     * @param senderCurve25519Key - The sender's curve 25519 key\n     * @param sessionId - The ID of the session\n     * @param sessionData - The session data structure\n     * @param txn - An active transaction. See doTxn().\n     */\n    public storeEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        sessionData: InboundGroupSessionData,\n        txn: IDBTransaction,\n    ): void {\n        this.backend!.storeEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn);\n    }\n\n    /**\n     * Fetch a batch of Megolm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.getEndToEndInboundGroupSessionsBatch}.\n     *\n     * @internal\n     */\n    public getEndToEndInboundGroupSessionsBatch(): Promise<SessionExtended[] | null> {\n        return this.backend!.getEndToEndInboundGroupSessionsBatch();\n    }\n\n    /**\n     * Delete a batch of Megolm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.deleteEndToEndInboundGroupSessionsBatch}.\n     *\n     * @internal\n     */\n    public deleteEndToEndInboundGroupSessionsBatch(\n        sessions: { senderKey: string; sessionId: string }[],\n    ): Promise<void> {\n        return this.backend!.deleteEndToEndInboundGroupSessionsBatch(sessions);\n    }\n\n    /**\n     * Get an object of `roomId->roomInfo` for all e2e rooms in the store\n     * @param txn - An active transaction. See doTxn().\n     * @param func - Function called with the end-to-end encrypted rooms\n     */\n    public getEndToEndRooms(txn: IDBTransaction, func: (rooms: Record<string, IRoomEncryption>) => void): void {\n        this.backend!.getEndToEndRooms(txn, func);\n    }\n\n    /**\n     * Mark sessions as needing to be backed up.\n     * @param sessions - The sessions that need to be backed up.\n     * @param txn - An active transaction. See doTxn(). (optional)\n     * @returns resolves when the sessions are marked\n     */\n    public markSessionsNeedingBackup(sessions: ISession[], txn?: IDBTransaction): Promise<void> {\n        return this.backend!.markSessionsNeedingBackup(sessions, txn);\n    }\n\n    /**\n     * Perform a transaction on the crypto store. Any store methods\n     * that require a transaction (txn) object to be passed in may\n     * only be called within a callback of either this function or\n     * one of the store functions operating on the same transaction.\n     *\n     * @param mode - 'readwrite' if you need to call setter\n     *     functions with this transaction. Otherwise, 'readonly'.\n     * @param stores - List IndexedDBCryptoStore.STORE_*\n     *     options representing all types of object that will be\n     *     accessed or written to with this transaction.\n     * @param func - Function called with the\n     *     transaction object: an opaque object that should be passed\n     *     to store functions.\n     * @param log - A possibly customised log\n     * @returns Promise that resolves with the result of the `func`\n     *     when the transaction is complete. If the backend is\n     *     async (ie. the indexeddb backend) any of the callback\n     *     functions throwing an exception will cause this promise to\n     *     reject with that exception. On synchronous backends, the\n     *     exception will propagate to the caller of the getFoo method.\n     */\n    public doTxn<T>(mode: Mode, stores: Iterable<string>, func: (txn: IDBTransaction) => T, log?: Logger): Promise<T> {\n        return this.backend!.doTxn<T>(mode, stores, func as (txn: unknown) => T, log);\n    }\n}\n","/*\nCopyright 2017 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { logger } from \"../../logger.ts\";\nimport { MemoryCryptoStore } from \"./memory-crypto-store.ts\";\nimport {\n    type CryptoStore,\n    type ISession,\n    type SessionExtended,\n    type ISessionInfo,\n    type IWithheld,\n    MigrationState,\n    type Mode,\n    type SecretStorePrivateKeys,\n    SESSION_BATCH_SIZE,\n    type InboundGroupSessionData,\n    type IRoomEncryption,\n} from \"./base.ts\";\nimport { type CrossSigningKeyInfo } from \"../../crypto-api/index.ts\";\n\n/**\n * Internal module. Partial localStorage backed storage for e2e.\n * This is not a full crypto store, just the in-memory store with\n * some things backed by localStorage. It exists because indexedDB\n * is broken in Firefox private mode or set to, \"will not remember\n * history\".\n */\n\nconst E2E_PREFIX = \"crypto.\";\nconst KEY_END_TO_END_MIGRATION_STATE = E2E_PREFIX + \"migration\";\nconst KEY_END_TO_END_ACCOUNT = E2E_PREFIX + \"account\";\nconst KEY_CROSS_SIGNING_KEYS = E2E_PREFIX + \"cross_signing_keys\";\nconst KEY_INBOUND_SESSION_PREFIX = E2E_PREFIX + \"inboundgroupsessions/\";\nconst KEY_INBOUND_SESSION_WITHHELD_PREFIX = E2E_PREFIX + \"inboundgroupsessions.withheld/\";\nconst KEY_ROOMS_PREFIX = E2E_PREFIX + \"rooms/\";\nconst KEY_SESSIONS_NEEDING_BACKUP = E2E_PREFIX + \"sessionsneedingbackup\";\n\nfunction keyEndToEndSessions(deviceKey: string): string {\n    return E2E_PREFIX + \"sessions/\" + deviceKey;\n}\n\nfunction keyEndToEndInboundGroupSession(senderKey: string, sessionId: string): string {\n    return KEY_INBOUND_SESSION_PREFIX + senderKey + \"/\" + sessionId;\n}\n\nfunction keyEndToEndInboundGroupSessionWithheld(senderKey: string, sessionId: string): string {\n    return KEY_INBOUND_SESSION_WITHHELD_PREFIX + senderKey + \"/\" + sessionId;\n}\n\nfunction keyEndToEndRoomsPrefix(roomId: string): string {\n    return KEY_ROOMS_PREFIX + roomId;\n}\n\nexport class LocalStorageCryptoStore extends MemoryCryptoStore implements CryptoStore {\n    public static exists(store: Storage): boolean {\n        const length = store.length;\n        for (let i = 0; i < length; i++) {\n            if (store.key(i)?.startsWith(E2E_PREFIX)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public constructor(private readonly store: Storage) {\n        super();\n    }\n\n    /**\n     * Returns true if this CryptoStore has ever been initialised (ie, it might contain data).\n     *\n     * Implementation of {@link CryptoStore.containsData}.\n     *\n     * @internal\n     */\n    public async containsData(): Promise<boolean> {\n        return LocalStorageCryptoStore.exists(this.store);\n    }\n\n    /**\n     * Get data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * Implementation of {@link CryptoStore.getMigrationState}.\n     *\n     * @internal\n     */\n    public async getMigrationState(): Promise<MigrationState> {\n        return getJsonItem(this.store, KEY_END_TO_END_MIGRATION_STATE) ?? MigrationState.NOT_STARTED;\n    }\n\n    /**\n     * Set data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * Implementation of {@link CryptoStore.setMigrationState}.\n     *\n     * @internal\n     */\n    public async setMigrationState(migrationState: MigrationState): Promise<void> {\n        setJsonItem(this.store, KEY_END_TO_END_MIGRATION_STATE, migrationState);\n    }\n\n    // Olm Sessions\n\n    public countEndToEndSessions(txn: unknown, func: (count: number) => void): void {\n        let count = 0;\n        for (let i = 0; i < this.store.length; ++i) {\n            const key = this.store.key(i);\n            if (key?.startsWith(keyEndToEndSessions(\"\"))) {\n                const sessions = getJsonItem(this.store, key);\n                count += Object.keys(sessions ?? {}).length;\n            }\n        }\n        func(count);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private _getEndToEndSessions(deviceKey: string): Record<string, ISessionInfo> {\n        const sessions = getJsonItem(this.store, keyEndToEndSessions(deviceKey));\n        const fixedSessions: Record<string, ISessionInfo> = {};\n\n        // fix up any old sessions to be objects rather than just the base64 pickle\n        for (const [sid, val] of Object.entries(sessions || {})) {\n            if (typeof val === \"string\") {\n                fixedSessions[sid] = {\n                    session: val,\n                };\n            } else {\n                fixedSessions[sid] = val;\n            }\n        }\n\n        return fixedSessions;\n    }\n\n    public getEndToEndSession(\n        deviceKey: string,\n        sessionId: string,\n        txn: unknown,\n        func: (session: ISessionInfo) => void,\n    ): void {\n        const sessions = this._getEndToEndSessions(deviceKey);\n        func(sessions[sessionId] ?? {});\n    }\n\n    public getEndToEndSessions(\n        deviceKey: string,\n        txn: unknown,\n        func: (sessions: { [sessionId: string]: ISessionInfo }) => void,\n    ): void {\n        func(this._getEndToEndSessions(deviceKey) ?? {});\n    }\n\n    public storeEndToEndSession(deviceKey: string, sessionId: string, sessionInfo: ISessionInfo, txn: unknown): void {\n        const sessions = this._getEndToEndSessions(deviceKey) || {};\n        sessions[sessionId] = sessionInfo;\n        setJsonItem(this.store, keyEndToEndSessions(deviceKey), sessions);\n    }\n\n    /**\n     * Fetch a batch of Olm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.getEndToEndSessionsBatch}.\n     *\n     * @internal\n     */\n    public async getEndToEndSessionsBatch(): Promise<null | ISessionInfo[]> {\n        const result: ISessionInfo[] = [];\n        for (let i = 0; i < this.store.length; ++i) {\n            if (this.store.key(i)?.startsWith(keyEndToEndSessions(\"\"))) {\n                const deviceKey = this.store.key(i)!.split(\"/\")[1];\n                for (const session of Object.values(this._getEndToEndSessions(deviceKey))) {\n                    result.push(session);\n                    if (result.length >= SESSION_BATCH_SIZE) {\n                        return result;\n                    }\n                }\n            }\n        }\n\n        if (result.length === 0) {\n            // No sessions left.\n            return null;\n        }\n\n        // There are fewer sessions than the batch size; return the final batch of sessions.\n        return result;\n    }\n\n    /**\n     * Delete a batch of Olm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.deleteEndToEndSessionsBatch}.\n     *\n     * @internal\n     */\n    public async deleteEndToEndSessionsBatch(sessions: { deviceKey: string; sessionId: string }[]): Promise<void> {\n        for (const { deviceKey, sessionId } of sessions) {\n            const deviceSessions = this._getEndToEndSessions(deviceKey) || {};\n            delete deviceSessions[sessionId];\n            if (Object.keys(deviceSessions).length === 0) {\n                // No more sessions for this device.\n                this.store.removeItem(keyEndToEndSessions(deviceKey));\n            } else {\n                setJsonItem(this.store, keyEndToEndSessions(deviceKey), deviceSessions);\n            }\n        }\n    }\n\n    // Inbound Group Sessions\n\n    public getEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        txn: unknown,\n        func: (groupSession: InboundGroupSessionData | null, groupSessionWithheld: IWithheld | null) => void,\n    ): void {\n        func(\n            getJsonItem(this.store, keyEndToEndInboundGroupSession(senderCurve25519Key, sessionId)),\n            getJsonItem(this.store, keyEndToEndInboundGroupSessionWithheld(senderCurve25519Key, sessionId)),\n        );\n    }\n\n    public storeEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        sessionData: InboundGroupSessionData,\n        txn: unknown,\n    ): void {\n        setJsonItem(this.store, keyEndToEndInboundGroupSession(senderCurve25519Key, sessionId), sessionData);\n    }\n\n    /**\n     * Count the number of Megolm sessions in the database.\n     *\n     * Implementation of {@link CryptoStore.countEndToEndInboundGroupSessions}.\n     *\n     * @internal\n     */\n    public async countEndToEndInboundGroupSessions(): Promise<number> {\n        let count = 0;\n        for (let i = 0; i < this.store.length; ++i) {\n            const key = this.store.key(i);\n            if (key?.startsWith(KEY_INBOUND_SESSION_PREFIX)) {\n                count += 1;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Fetch a batch of Megolm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.getEndToEndInboundGroupSessionsBatch}.\n     *\n     * @internal\n     */\n    public async getEndToEndInboundGroupSessionsBatch(): Promise<SessionExtended[] | null> {\n        const sessionsNeedingBackup = getJsonItem<string[]>(this.store, KEY_SESSIONS_NEEDING_BACKUP) || {};\n        const result: SessionExtended[] = [];\n        for (let i = 0; i < this.store.length; ++i) {\n            const key = this.store.key(i);\n            if (key?.startsWith(KEY_INBOUND_SESSION_PREFIX)) {\n                const key2 = key.slice(KEY_INBOUND_SESSION_PREFIX.length);\n\n                // we can't use split, as the components we are trying to split out\n                // might themselves contain '/' characters. We rely on the\n                // senderKey being a (32-byte) curve25519 key, base64-encoded\n                // (hence 43 characters long).\n\n                result.push({\n                    senderKey: key2.slice(0, 43),\n                    sessionId: key2.slice(44),\n                    sessionData: getJsonItem(this.store, key)!,\n                    needsBackup: key2 in sessionsNeedingBackup,\n                });\n\n                if (result.length >= SESSION_BATCH_SIZE) {\n                    return result;\n                }\n            }\n        }\n\n        if (result.length === 0) {\n            // No sessions left.\n            return null;\n        }\n\n        // There are fewer sessions than the batch size; return the final batch of sessions.\n        return result;\n    }\n\n    /**\n     * Delete a batch of Megolm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.deleteEndToEndInboundGroupSessionsBatch}.\n     *\n     * @internal\n     */\n    public async deleteEndToEndInboundGroupSessionsBatch(\n        sessions: { senderKey: string; sessionId: string }[],\n    ): Promise<void> {\n        for (const { senderKey, sessionId } of sessions) {\n            const k = keyEndToEndInboundGroupSession(senderKey, sessionId);\n            this.store.removeItem(k);\n        }\n    }\n\n    public getEndToEndRooms(txn: unknown, func: (rooms: Record<string, IRoomEncryption>) => void): void {\n        const result: Record<string, IRoomEncryption> = {};\n        const prefix = keyEndToEndRoomsPrefix(\"\");\n\n        for (let i = 0; i < this.store.length; ++i) {\n            const key = this.store.key(i);\n            if (key?.startsWith(prefix)) {\n                const roomId = key.slice(prefix.length);\n                result[roomId] = getJsonItem(this.store, key)!;\n            }\n        }\n        func(result);\n    }\n\n    public markSessionsNeedingBackup(sessions: ISession[]): Promise<void> {\n        const sessionsNeedingBackup =\n            getJsonItem<{\n                [senderKeySessionId: string]: boolean;\n            }>(this.store, KEY_SESSIONS_NEEDING_BACKUP) || {};\n        for (const session of sessions) {\n            sessionsNeedingBackup[session.senderKey + \"/\" + session.sessionId] = true;\n        }\n        setJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP, sessionsNeedingBackup);\n        return Promise.resolve();\n    }\n\n    /**\n     * Delete all data from this store.\n     *\n     * @returns Promise which resolves when the store has been cleared.\n     */\n    public deleteAllData(): Promise<void> {\n        this.store.removeItem(KEY_END_TO_END_ACCOUNT);\n        return Promise.resolve();\n    }\n\n    // Olm account\n\n    public getAccount(txn: unknown, func: (accountPickle: string | null) => void): void {\n        const accountPickle = getJsonItem<string>(this.store, KEY_END_TO_END_ACCOUNT);\n        func(accountPickle);\n    }\n\n    public storeAccount(txn: unknown, accountPickle: string): void {\n        setJsonItem(this.store, KEY_END_TO_END_ACCOUNT, accountPickle);\n    }\n\n    public getCrossSigningKeys(txn: unknown, func: (keys: Record<string, CrossSigningKeyInfo> | null) => void): void {\n        const keys = getJsonItem<Record<string, CrossSigningKeyInfo>>(this.store, KEY_CROSS_SIGNING_KEYS);\n        func(keys);\n    }\n\n    public getSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: unknown,\n        func: (key: SecretStorePrivateKeys[K] | null) => void,\n        type: K,\n    ): void {\n        const key = getJsonItem<SecretStorePrivateKeys[K]>(this.store, E2E_PREFIX + `ssss_cache.${type}`);\n        func(key);\n    }\n\n    public storeSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: unknown,\n        type: K,\n        key: SecretStorePrivateKeys[K],\n    ): void {\n        setJsonItem(this.store, E2E_PREFIX + `ssss_cache.${type}`, key);\n    }\n\n    public doTxn<T>(mode: Mode, stores: Iterable<string>, func: (txn: unknown) => T): Promise<T> {\n        return Promise.resolve(func(null));\n    }\n}\n\nfunction getJsonItem<T>(store: Storage, key: string): T | null {\n    try {\n        // if the key is absent, store.getItem() returns null, and\n        // JSON.parse(null) === null, so this returns null.\n        return JSON.parse(store.getItem(key)!);\n    } catch (e) {\n        logger.log(\"Error: Failed to get key %s: %s\", key, (<Error>e).message);\n        logger.log((<Error>e).stack);\n    }\n    return null;\n}\n\nfunction setJsonItem<T>(store: Storage, key: string, val: T): void {\n    store.setItem(key, JSON.stringify(val));\n}\n","/*\nCopyright 2017 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { safeSet } from \"../../utils.ts\";\nimport {\n    type CryptoStore,\n    type ISession,\n    type SessionExtended,\n    type ISessionInfo,\n    type IWithheld,\n    MigrationState,\n    type Mode,\n    type SecretStorePrivateKeys,\n    SESSION_BATCH_SIZE,\n    type InboundGroupSessionData,\n    type IRoomEncryption,\n} from \"./base.ts\";\nimport { type CrossSigningKeyInfo } from \"../../crypto-api/index.ts\";\n\nfunction encodeSessionKey(senderCurve25519Key: string, sessionId: string): string {\n    return encodeURIComponent(senderCurve25519Key) + \"/\" + encodeURIComponent(sessionId);\n}\n\nfunction decodeSessionKey(key: string): { senderKey: string; sessionId: string } {\n    const keyParts = key.split(\"/\");\n    const senderKey = decodeURIComponent(keyParts[0]);\n    const sessionId = decodeURIComponent(keyParts[1]);\n    return { senderKey, sessionId };\n}\n\n/**\n * Internal module. in-memory storage for e2e.\n */\n\nexport class MemoryCryptoStore implements CryptoStore {\n    private migrationState: MigrationState = MigrationState.NOT_STARTED;\n    private account: string | null = null;\n    private crossSigningKeys: Record<string, CrossSigningKeyInfo> | null = null;\n    private privateKeys: Partial<SecretStorePrivateKeys> = {};\n\n    private sessions: { [deviceKey: string]: { [sessionId: string]: ISessionInfo } } = {};\n    private inboundGroupSessions: { [sessionKey: string]: InboundGroupSessionData } = {};\n    private inboundGroupSessionsWithheld: Record<string, IWithheld> = {};\n    // Opaque device data object\n    private rooms: { [roomId: string]: IRoomEncryption } = {};\n    private sessionsNeedingBackup: { [sessionKey: string]: boolean } = {};\n\n    /**\n     * Returns true if this CryptoStore has ever been initialised (ie, it might contain data).\n     *\n     * Implementation of {@link CryptoStore.containsData}.\n     *\n     * @internal\n     */\n    public async containsData(): Promise<boolean> {\n        // If it contains anything, it should contain an account.\n        return this.account !== null;\n    }\n\n    /**\n     * Ensure the database exists and is up-to-date.\n     *\n     * This must be called before the store can be used.\n     *\n     * @returns resolves to the store.\n     */\n    public async startup(): Promise<CryptoStore> {\n        // No startup work to do for the memory store.\n        return this;\n    }\n\n    /**\n     * Delete all data from this store.\n     *\n     * @returns Promise which resolves when the store has been cleared.\n     */\n    public deleteAllData(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    /**\n     * Get data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * Implementation of {@link CryptoStore.getMigrationState}.\n     *\n     * @internal\n     */\n    public async getMigrationState(): Promise<MigrationState> {\n        return this.migrationState;\n    }\n\n    /**\n     * Set data on how much of the libolm to Rust Crypto migration has been done.\n     *\n     * Implementation of {@link CryptoStore.setMigrationState}.\n     *\n     * @internal\n     */\n    public async setMigrationState(migrationState: MigrationState): Promise<void> {\n        this.migrationState = migrationState;\n    }\n\n    // Olm Account\n\n    public getAccount(txn: unknown, func: (accountPickle: string | null) => void): void {\n        func(this.account);\n    }\n\n    public storeAccount(txn: unknown, accountPickle: string): void {\n        this.account = accountPickle;\n    }\n\n    public getCrossSigningKeys(txn: unknown, func: (keys: Record<string, CrossSigningKeyInfo> | null) => void): void {\n        func(this.crossSigningKeys);\n    }\n\n    public getSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: unknown,\n        func: (key: SecretStorePrivateKeys[K] | null) => void,\n        type: K,\n    ): void {\n        const result = this.privateKeys[type] as SecretStorePrivateKeys[K] | undefined;\n        func(result || null);\n    }\n\n    public storeSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: unknown,\n        type: K,\n        key: SecretStorePrivateKeys[K],\n    ): void {\n        this.privateKeys[type] = key;\n    }\n\n    // Olm Sessions\n\n    public countEndToEndSessions(txn: unknown, func: (count: number) => void): void {\n        let count = 0;\n        for (const deviceSessions of Object.values(this.sessions)) {\n            count += Object.keys(deviceSessions).length;\n        }\n        func(count);\n    }\n\n    public getEndToEndSession(\n        deviceKey: string,\n        sessionId: string,\n        txn: unknown,\n        func: (session: ISessionInfo) => void,\n    ): void {\n        const deviceSessions = this.sessions[deviceKey] || {};\n        func(deviceSessions[sessionId] || null);\n    }\n\n    public getEndToEndSessions(\n        deviceKey: string,\n        txn: unknown,\n        func: (sessions: { [sessionId: string]: ISessionInfo }) => void,\n    ): void {\n        func(this.sessions[deviceKey] || {});\n    }\n\n    public storeEndToEndSession(deviceKey: string, sessionId: string, sessionInfo: ISessionInfo, txn: unknown): void {\n        let deviceSessions = this.sessions[deviceKey];\n        if (deviceSessions === undefined) {\n            deviceSessions = {};\n            this.sessions[deviceKey] = deviceSessions;\n        }\n        safeSet(deviceSessions, sessionId, sessionInfo);\n    }\n\n    /**\n     * Fetch a batch of Olm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.getEndToEndSessionsBatch}.\n     *\n     * @internal\n     */\n    public async getEndToEndSessionsBatch(): Promise<null | ISessionInfo[]> {\n        const result: ISessionInfo[] = [];\n        for (const deviceSessions of Object.values(this.sessions)) {\n            for (const session of Object.values(deviceSessions)) {\n                result.push(session);\n                if (result.length >= SESSION_BATCH_SIZE) {\n                    return result;\n                }\n            }\n        }\n\n        if (result.length === 0) {\n            // No sessions left.\n            return null;\n        }\n\n        // There are fewer sessions than the batch size; return the final batch of sessions.\n        return result;\n    }\n\n    /**\n     * Delete a batch of Olm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.deleteEndToEndSessionsBatch}.\n     *\n     * @internal\n     */\n    public async deleteEndToEndSessionsBatch(sessions: { deviceKey: string; sessionId: string }[]): Promise<void> {\n        for (const { deviceKey, sessionId } of sessions) {\n            const deviceSessions = this.sessions[deviceKey] || {};\n            delete deviceSessions[sessionId];\n            if (Object.keys(deviceSessions).length === 0) {\n                // No more sessions for this device.\n                delete this.sessions[deviceKey];\n            }\n        }\n    }\n\n    // Inbound Group Sessions\n\n    public getEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        txn: unknown,\n        func: (groupSession: InboundGroupSessionData | null, groupSessionWithheld: IWithheld | null) => void,\n    ): void {\n        const k = encodeSessionKey(senderCurve25519Key, sessionId);\n        func(this.inboundGroupSessions[k] || null, this.inboundGroupSessionsWithheld[k] || null);\n    }\n\n    public storeEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        sessionData: InboundGroupSessionData,\n        txn: unknown,\n    ): void {\n        const k = encodeSessionKey(senderCurve25519Key, sessionId);\n        this.inboundGroupSessions[k] = sessionData;\n    }\n\n    /**\n     * Count the number of Megolm sessions in the database.\n     *\n     * Implementation of {@link CryptoStore.countEndToEndInboundGroupSessions}.\n     *\n     * @internal\n     */\n    public async countEndToEndInboundGroupSessions(): Promise<number> {\n        return Object.keys(this.inboundGroupSessions).length;\n    }\n\n    /**\n     * Fetch a batch of Megolm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.getEndToEndInboundGroupSessionsBatch}.\n     *\n     * @internal\n     */\n    public async getEndToEndInboundGroupSessionsBatch(): Promise<null | SessionExtended[]> {\n        const result: SessionExtended[] = [];\n        for (const [key, session] of Object.entries(this.inboundGroupSessions)) {\n            result.push({\n                ...decodeSessionKey(key),\n                sessionData: session,\n                needsBackup: key in this.sessionsNeedingBackup,\n            });\n            if (result.length >= SESSION_BATCH_SIZE) {\n                return result;\n            }\n        }\n\n        if (result.length === 0) {\n            // No sessions left.\n            return null;\n        }\n\n        // There are fewer sessions than the batch size; return the final batch of sessions.\n        return result;\n    }\n\n    /**\n     * Delete a batch of Megolm sessions from the database.\n     *\n     * Implementation of {@link CryptoStore.deleteEndToEndInboundGroupSessionsBatch}.\n     *\n     * @internal\n     */\n    public async deleteEndToEndInboundGroupSessionsBatch(\n        sessions: { senderKey: string; sessionId: string }[],\n    ): Promise<void> {\n        for (const { senderKey, sessionId } of sessions) {\n            const k = encodeSessionKey(senderKey, sessionId);\n            delete this.inboundGroupSessions[k];\n        }\n    }\n\n    // E2E rooms\n\n    public getEndToEndRooms(txn: unknown, func: (rooms: Record<string, IRoomEncryption>) => void): void {\n        func(this.rooms);\n    }\n\n    public markSessionsNeedingBackup(sessions: ISession[]): Promise<void> {\n        for (const session of sessions) {\n            const sessionKey = encodeSessionKey(session.senderKey, session.sessionId);\n            this.sessionsNeedingBackup[sessionKey] = true;\n        }\n        return Promise.resolve();\n    }\n\n    // Session key backups\n\n    public doTxn<T>(mode: Mode, stores: Iterable<string>, func: (txn?: unknown) => T): Promise<T> {\n        return Promise.resolve(func(null));\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/** State of the verification of the device. */\nexport enum DeviceVerification {\n    Blocked = -1,\n    Unverified = 0,\n    Verified = 1,\n}\n\n/** A map from user ID to device ID to Device */\nexport type DeviceMap = Map<string, Map<string, Device>>;\n\ntype DeviceParameters = Pick<Device, \"deviceId\" | \"userId\" | \"algorithms\" | \"keys\"> & Partial<Device>;\n\n/**\n *  Information on a user's device, as returned by {@link crypto-api!CryptoApi.getUserDeviceInfo}.\n */\nexport class Device {\n    /** id of the device */\n    public readonly deviceId: string;\n\n    /** id of the user that owns the device */\n    public readonly userId: string;\n\n    /** list of algorithms supported by this device */\n    public readonly algorithms: string[];\n\n    /** a map from `<key type>:<id> -> <base64-encoded key>` */\n    public readonly keys: Map<string, string>;\n\n    /** whether the device has been verified/blocked by the user */\n    public readonly verified: DeviceVerification;\n\n    /** a map `<userId, map<algorithm:device_id, signature>>` */\n    public readonly signatures: Map<string, Map<string, string>>;\n\n    /** display name of the device */\n    public readonly displayName?: string;\n\n    /** whether the device is a dehydrated device */\n    public readonly dehydrated: boolean = false;\n\n    public constructor(opts: DeviceParameters) {\n        this.deviceId = opts.deviceId;\n        this.userId = opts.userId;\n        this.algorithms = opts.algorithms;\n        this.keys = opts.keys;\n        this.verified = opts.verified || DeviceVerification.Unverified;\n        this.signatures = opts.signatures || new Map();\n        this.displayName = opts.displayName;\n        this.dehydrated = !!opts.dehydrated;\n    }\n\n    /**\n     * Get the fingerprint for this device (ie, the Ed25519 key)\n     *\n     * @returns base64-encoded fingerprint of this device\n     */\n    public getFingerprint(): string | undefined {\n        return this.keys.get(`ed25519:${this.deviceId}`);\n    }\n\n    /**\n     * Get the identity key for this device (ie, the Curve25519 key)\n     *\n     * @returns base64-encoded identity key of this device\n     */\n    public getIdentityKey(): string | undefined {\n        return this.keys.get(`curve25519:${this.deviceId}`);\n    }\n}\n","/*\nCopyright 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/*\n * This file is a secondary entrypoint for the js-sdk library, for use by Typescript projects.\n * It exposes low-level types and interfaces reflecting structures defined in the Matrix specification.\n *\n * Remember to only export *public* types from this file.\n */\n\nexport type * from \"./@types/media.ts\";\nexport * from \"./@types/membership.ts\";\nexport type * from \"./@types/event.ts\";\nexport type * from \"./@types/events.ts\";\nexport type * from \"./@types/state_events.ts\";\nexport type * from \"./@types/AESEncryptedSecretStoragePayload.ts\";\n\n/** The different methods for device and user verification */\nexport enum VerificationMethod {\n    /** Short authentication string (emoji or decimals).\n     *\n     * @see https://spec.matrix.org/v1.9/client-server-api/#short-authentication-string-sas-verification\n     */\n    Sas = \"m.sas.v1\",\n\n    /**\n     * Verification by showing a QR code which is scanned by the other device.\n     *\n     * @see https://spec.matrix.org/v1.9/client-server-api/#qr-codes\n     */\n    ShowQrCode = \"m.qr_code.show.v1\",\n\n    /**\n     * Verification by scanning a QR code that is shown by the other device.\n     *\n     * @see https://spec.matrix.org/v1.9/client-server-api/#qr-codes\n     */\n    ScanQrCode = \"m.qr_code.scan.v1\",\n\n    /**\n     * Verification by confirming that we have scanned a QR code.\n     *\n     * @see https://spec.matrix.org/v1.9/client-server-api/#qr-codes\n     */\n    Reciprocate = \"m.reciprocate.v1\",\n}\n"],"names":["ACCOUNT_OBJECT_KEY_MIGRATION_STATE","MigrationState","SESSION_BATCH_SIZE","Backend","constructor","db","_defineProperty","onversionchange","logger","log","this","name","close","containsData","Error","startup","deleteAllData","getMigrationState","migrationState","NOT_STARTED","doTxn","IndexedDBCryptoStore","STORE_ACCOUNT","txn","getReq","objectStore","get","onsuccess","_getReq$result","result","setMigrationState","put","getAccount","func","e","abortWithException","storeAccount","accountPickle","getCrossSigningKeys","getSecretStorePrivateKey","type","storeSecretStorePrivateKey","key","countEndToEndSessions","countReq","count","getEndToEndSessions","deviceKey","index","openCursor","results","cursor","value","sessionId","session","lastReceivedMessageTs","continue","getEndToEndSession","storeEndToEndSession","sessionInfo","getEndToEndSessionsBatch","STORE_SESSIONS","push","length","deleteEndToEndSessionsBatch","sessions","async","req","delete","Promise","resolve","getEndToEndInboundGroupSession","senderCurve25519Key","withheld","withheldGetReq","storeEndToEndInboundGroupSession","sessionData","countEndToEndInboundGroupSessions","STORE_INBOUND_GROUP_SESSIONS","getEndToEndInboundGroupSessionsBatch","STORE_BACKUP","sessionStore","backupStore","backupGetReq","senderKey","needsBackup","undefined","deleteEndToEndInboundGroupSessionsBatch","getEndToEndDeviceData","getEndToEndRooms","rooms","markSessionsNeedingBackup","transaction","all","map","reject","onerror","mode","stores","promise","oncomplete","_mx_abortexception","event","error","onabort","promiseifyTxn","then","DB_MIGRATIONS","outgoingRoomKeyRequestsStore","createObjectStore","keyPath","createIndex","createDatabase","VERSION","abort","exists","indexedDB","dbName","IndexedDBHelpers","existsAndIsNotMigrated","indexedDb","openDBRequest","open","onupgradeneeded","onblocked","deleteDatabase","backendPromise","IndexedDBCryptoStoreBackend","ev","oldVersion","forEach","migration","backend","STORE_INBOUND_GROUP_SESSIONS_WITHHELD","catch","warn","InvalidCryptoStoreError","InvalidCryptoStoreState","TooNew","globalThis","localStorage","Storage","LocalStorageCryptoStore","MemoryCryptoStore","E2E_PREFIX","KEY_END_TO_END_MIGRATION_STATE","KEY_END_TO_END_ACCOUNT","KEY_CROSS_SIGNING_KEYS","KEY_INBOUND_SESSION_PREFIX","KEY_INBOUND_SESSION_WITHHELD_PREFIX","KEY_ROOMS_PREFIX","KEY_SESSIONS_NEEDING_BACKUP","keyEndToEndSessions","keyEndToEndInboundGroupSession","store","i","_store$key","startsWith","super","_getJsonItem","getJsonItem","setJsonItem","Object","keys","_getEndToEndSessions","fixedSessions","sid","val","entries","_sessions$sessionId","_this$_getEndToEndSes","_this$store$key","split","values","deviceSessions","removeItem","keyEndToEndInboundGroupSessionWithheld","sessionsNeedingBackup","key2","slice","k","prefix","JSON","parse","getItem","message","stack","setItem","stringify","encodeSessionKey","encodeURIComponent","decodeSessionKey","keyParts","decodeURIComponent","account","crossSigningKeys","privateKeys","safeSet","inboundGroupSessions","inboundGroupSessionsWithheld","_objectSpread","sessionKey","DeviceVerification","Device","opts","deviceId","userId","algorithms","verified","Unverified","signatures","Map","displayName","dehydrated","getFingerprint","getIdentityKey","VerificationMethod"],"sourceRoot":""}