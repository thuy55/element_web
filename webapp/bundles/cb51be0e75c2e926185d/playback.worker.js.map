{"version":3,"file":"bundles/cb51be0e75c2e926185d/playback.worker.js","mappings":"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","sources":["webpack://element-web/./src/utils/arrays.ts","webpack://element-web/./packages/shared-components/src/utils/numbers.ts","webpack://element-web/webpack/runtime/compat","webpack://element-web/./src/audio/consts.ts","webpack://element-web/./src/workers/playback.worker.ts"],"sourcesContent":["/*\r\nCopyright 2024 New Vector Ltd.\r\nCopyright 2020, 2021 The Matrix.org Foundation C.I.C.\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\nimport { percentageOf, percentageWithin } from \"../../packages/shared-components/src/utils/numbers\";\r\n\r\n/**\r\n * Quickly resample an array to have less/more data points. If an input which is larger\r\n * than the desired size is provided, it will be downsampled. Similarly, if the input\r\n * is smaller than the desired size then it will be upsampled.\r\n * @param {number[]} input The input array to resample.\r\n * @param {number} points The number of samples to end up with.\r\n * @returns {number[]} The resampled array.\r\n */\r\nexport function arrayFastResample(input: number[], points: number): number[] {\r\n    if (input.length === points) return input; // short-circuit a complicated call\r\n\r\n    // Heavily inspired by matrix-media-repo (used with permission)\r\n    // https://github.com/turt2live/matrix-media-repo/blob/abe72c87d2e29/util/util_audio/fastsample.go#L10\r\n    const samples: number[] = [];\r\n    if (input.length > points) {\r\n        // Danger: this loop can cause out of memory conditions if the input is too small.\r\n        const everyNth = Math.round(input.length / points);\r\n        for (let i = 0; i < input.length; i += everyNth) {\r\n            samples.push(input[i]);\r\n        }\r\n    } else {\r\n        // Smaller inputs mean we have to spread the values over the desired length. We\r\n        // end up overshooting the target length in doing this, but we're not looking to\r\n        // be super accurate so we'll let the sanity trims do their job.\r\n        const spreadFactor = Math.ceil(points / input.length);\r\n        for (const val of input) {\r\n            samples.push(...arraySeed(val, spreadFactor));\r\n        }\r\n    }\r\n\r\n    // Trim to size & return\r\n    return arrayTrimFill(samples, points, arraySeed(input[input.length - 1], points));\r\n}\r\n\r\n/**\r\n * Attempts a smooth resample of the given array. This is functionally similar to arrayFastResample\r\n * though can take longer due to the smoothing of data.\r\n * @param {number[]} input The input array to resample.\r\n * @param {number} points The number of samples to end up with.\r\n * @returns {number[]} The resampled array.\r\n */\r\nexport function arraySmoothingResample(input: number[], points: number): number[] {\r\n    if (input.length === points) return input; // short-circuit a complicated call\r\n\r\n    let samples: number[] = [];\r\n    if (input.length > points) {\r\n        // We're downsampling. To preserve the curve we'll actually reduce our sample\r\n        // selection and average some points between them.\r\n\r\n        // All we're doing here is repeatedly averaging the waveform down to near our\r\n        // target value. We don't average down to exactly our target as the loop might\r\n        // never end, and we can over-average the data. Instead, we'll get as far as\r\n        // we can and do a followup fast resample (the neighbouring points will be close\r\n        // to the actual waveform, so we can get away with this safely).\r\n        while (samples.length > points * 2 || samples.length === 0) {\r\n            samples = [];\r\n            for (let i = 1; i < input.length - 1; i += 2) {\r\n                const prevPoint = input[i - 1];\r\n                const nextPoint = input[i + 1];\r\n                const currPoint = input[i];\r\n                const average = (prevPoint + nextPoint + currPoint) / 3;\r\n                samples.push(average);\r\n            }\r\n            input = samples;\r\n        }\r\n\r\n        return arrayFastResample(samples, points);\r\n    } else {\r\n        // In practice there's not much purpose in burning CPU for short arrays only to\r\n        // end up with a result that can't possibly look much different than the fast\r\n        // resample, so just skip ahead to the fast resample.\r\n        return arrayFastResample(input, points);\r\n    }\r\n}\r\n\r\n/**\r\n * Rescales the input array to have values that are inclusively within the provided\r\n * minimum and maximum.\r\n * @param {number[]} input The array to rescale.\r\n * @param {number} newMin The minimum value to scale to.\r\n * @param {number} newMax The maximum value to scale to.\r\n * @returns {number[]} The rescaled array.\r\n */\r\nexport function arrayRescale(input: number[], newMin: number, newMax: number): number[] {\r\n    const min: number = Math.min(...input);\r\n    const max: number = Math.max(...input);\r\n    return input.map((v) => percentageWithin(percentageOf(v, min, max), newMin, newMax));\r\n}\r\n\r\n/**\r\n * Creates an array of the given length, seeded with the given value.\r\n * @param {T} val The value to seed the array with.\r\n * @param {number} length The length of the array to create.\r\n * @returns {T[]} The array.\r\n */\r\nexport function arraySeed<T>(val: T, length: number): T[] {\r\n    // Size the array up front for performance, and use `fill` to let the browser\r\n    // optimize the operation better than we can with a `for` loop, if it wants.\r\n    return new Array<T>(length).fill(val);\r\n}\r\n\r\n/**\r\n * Trims or fills the array to ensure it meets the desired length. The seed array\r\n * given is pulled from to fill any missing slots - it is recommended that this be\r\n * at least `len` long. The resulting array will be exactly `len` long, either\r\n * trimmed from the source or filled with the some/all of the seed array.\r\n * @param {T[]} a The array to trim/fill.\r\n * @param {number} len The length to trim or fill to, as needed.\r\n * @param {T[]} seed Values to pull from if the array needs filling.\r\n * @returns {T[]} The resulting array of `len` length.\r\n */\r\nexport function arrayTrimFill<T>(a: T[], len: number, seed: T[]): T[] {\r\n    // Dev note: we do length checks because the spread operator can result in some\r\n    // performance penalties in more critical code paths. As a utility, it should be\r\n    // as fast as possible to not cause a problem for the call stack, no matter how\r\n    // critical that stack is.\r\n    if (a.length === len) return a;\r\n    if (a.length > len) return a.slice(0, len);\r\n    return a.concat(seed.slice(0, len - a.length));\r\n}\r\n\r\n/**\r\n * Clones an array as fast as possible, retaining references of the array's values.\r\n * @param a The array to clone. Must be defined.\r\n * @returns A copy of the array.\r\n */\r\nexport function arrayFastClone<T>(a: T[]): T[] {\r\n    return a.slice(0, a.length);\r\n}\r\n\r\n/**\r\n * Determines if the two arrays are different either in length, contents,\r\n * or order of those contents.\r\n * @param a The first array. Must be defined.\r\n * @param b The second array. Must be defined.\r\n * @returns True if they are different, false otherwise.\r\n */\r\nexport function arrayHasOrderChange(a: any[], b: any[]): boolean {\r\n    if (a.length === b.length) {\r\n        for (let i = 0; i < a.length; i++) {\r\n            if (a[i] !== b[i]) return true;\r\n        }\r\n        return false;\r\n    } else {\r\n        return true; // like arrayHasDiff, a difference in length is a natural change\r\n    }\r\n}\r\n\r\n/**\r\n * Determines if two arrays are different through a shallow comparison.\r\n * @param a The first array. Must be defined.\r\n * @param b The second array. Must be defined.\r\n * @returns True if they are different, false otherwise.\r\n */\r\nexport function arrayHasDiff(a: any[], b: any[]): boolean {\r\n    if (a.length === b.length) {\r\n        // When the lengths are equal, check to see if either array is missing\r\n        // an element from the other.\r\n        if (b.some((i) => !a.includes(i))) return true;\r\n        if (a.some((i) => !b.includes(i))) return true;\r\n\r\n        // if all the keys are common, say so\r\n        return false;\r\n    } else {\r\n        return true; // different lengths means they are naturally diverged\r\n    }\r\n}\r\n\r\nexport type Diff<T> = { added: T[]; removed: T[] };\r\n\r\n/**\r\n * Performs a diff on two arrays. The result is what is different with the\r\n * first array (`added` in the returned object means objects in B that aren't\r\n * in A). Shallow comparisons are used to perform the diff.\r\n * @param a The first array. Must be defined.\r\n * @param b The second array. Must be defined.\r\n * @returns The diff between the arrays.\r\n */\r\nexport function arrayDiff<T>(a: T[], b: T[]): Diff<T> {\r\n    return {\r\n        added: b.filter((i) => !a.includes(i)),\r\n        removed: a.filter((i) => !b.includes(i)),\r\n    };\r\n}\r\n\r\n/**\r\n * Returns the intersection of two arrays.\r\n * @param a The first array. Must be defined.\r\n * @param b The second array. Must be defined.\r\n * @returns The intersection of the arrays.\r\n */\r\nexport function arrayIntersection<T>(a: T[], b: T[]): T[] {\r\n    return a.filter((i) => b.includes(i));\r\n}\r\n\r\n/**\r\n * Unions arrays, deduping contents using a Set.\r\n * @param a The arrays to merge.\r\n * @returns The union of all given arrays.\r\n */\r\nexport function arrayUnion<T>(...a: T[][]): T[] {\r\n    return Array.from(\r\n        a.reduce((c, v) => {\r\n            v.forEach((i) => c.add(i));\r\n            return c;\r\n        }, new Set<T>()),\r\n    );\r\n}\r\n\r\n/**\r\n * Moves a single element from fromIndex to toIndex.\r\n * @param {array} list the list from which to construct the new list.\r\n * @param {number} fromIndex the index of the element to move.\r\n * @param {number} toIndex the index of where to put the element.\r\n * @returns {array} A new array with the requested value moved.\r\n */\r\nexport function moveElement<T>(list: T[], fromIndex: number, toIndex: number): T[] {\r\n    const result = Array.from(list);\r\n    const [removed] = result.splice(fromIndex, 1);\r\n    result.splice(toIndex, 0, removed);\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Helper functions to perform LINQ-like queries on arrays.\r\n */\r\nexport class ArrayUtil<T> {\r\n    /**\r\n     * Create a new array helper.\r\n     * @param a The array to help. Can be modified in-place.\r\n     */\r\n    public constructor(private a: T[]) {}\r\n\r\n    /**\r\n     * The value of this array, after all appropriate alterations.\r\n     */\r\n    public get value(): T[] {\r\n        return this.a;\r\n    }\r\n\r\n    /**\r\n     * Groups an array by keys.\r\n     * @param fn The key-finding function.\r\n     * @returns This.\r\n     */\r\n    public groupBy<K>(fn: (a: T) => K): GroupedArray<K, T> {\r\n        const obj = this.a.reduce((rv: Map<K, T[]>, val: T) => {\r\n            const k = fn(val);\r\n            if (!rv.has(k)) rv.set(k, []);\r\n            rv.get(k)!.push(val);\r\n            return rv;\r\n        }, new Map<K, T[]>());\r\n        return new GroupedArray(obj);\r\n    }\r\n}\r\n\r\n/**\r\n * Helper functions to perform LINQ-like queries on groups (maps).\r\n */\r\nexport class GroupedArray<K, T> {\r\n    /**\r\n     * Creates a new group helper.\r\n     * @param val The group to help. Can be modified in-place.\r\n     */\r\n    public constructor(private val: Map<K, T[]>) {}\r\n\r\n    /**\r\n     * The value of this group, after all applicable alterations.\r\n     */\r\n    public get value(): Map<K, T[]> {\r\n        return this.val;\r\n    }\r\n\r\n    /**\r\n     * Orders the grouping into an array using the provided key order.\r\n     * @param keyOrder The key order.\r\n     * @returns An array helper of the result.\r\n     */\r\n    public orderBy(keyOrder: K[]): ArrayUtil<T> {\r\n        const a: T[] = [];\r\n        for (const k of keyOrder) {\r\n            if (!this.val.has(k)) continue;\r\n            a.push(...this.val.get(k)!);\r\n        }\r\n        return new ArrayUtil(a);\r\n    }\r\n}\r\n\r\nexport const concat = (...arrays: Uint8Array[]): Uint8Array => {\r\n    return arrays.reduce((concatenatedSoFar: Uint8Array, toBeConcatenated: Uint8Array) => {\r\n        const concatenated = new Uint8Array(concatenatedSoFar.length + toBeConcatenated.length);\r\n        concatenated.set(concatenatedSoFar, 0);\r\n        concatenated.set(toBeConcatenated, concatenatedSoFar.length);\r\n        return concatenated;\r\n    }, new Uint8Array(0));\r\n};\r\n\r\n/**\r\n * Async version of Array.every.\r\n */\r\nexport async function asyncEvery<T>(values: Iterable<T>, predicate: (value: T) => Promise<boolean>): Promise<boolean> {\r\n    for (const value of values) {\r\n        if (!(await predicate(value))) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n/**\r\n * Async version of Array.some.\r\n */\r\nexport async function asyncSome<T>(values: Iterable<T>, predicate: (value: T) => Promise<boolean>): Promise<boolean> {\r\n    for (const value of values) {\r\n        if (await predicate(value)) return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Async version of Array.some that runs all promises in parallel.\r\n * @param values\r\n * @param predicate\r\n */\r\nexport async function asyncSomeParallel<T>(\r\n    values: Array<T>,\r\n    predicate: (value: T) => Promise<boolean>,\r\n): Promise<boolean> {\r\n    try {\r\n        return await Promise.any<boolean>(\r\n            values.map((value) =>\r\n                predicate(value).then((result) => (result ? Promise.resolve(true) : Promise.reject(false))),\r\n            ),\r\n        );\r\n    } catch (e) {\r\n        // If the array is empty or all the promises are false, Promise.any will reject an AggregateError\r\n        if (e instanceof AggregateError) return false;\r\n        throw e;\r\n    }\r\n}\r\n\r\n/**\r\n * Async version of Array.filter.\r\n * If one of the promises rejects, the whole operation will reject.\r\n * @param values\r\n * @param predicate\r\n */\r\nexport async function asyncFilter<T>(values: Array<T>, predicate: (value: T) => Promise<boolean>): Promise<Array<T>> {\r\n    const results = await Promise.all(values.map(predicate));\r\n    return values.filter((_, i) => results[i]);\r\n}\r\n\r\nexport function filterBoolean<T>(values: Array<T | null | undefined>): T[] {\r\n    return values.filter(Boolean) as T[];\r\n}\r\n","/*\r\nCopyright 2024 New Vector Ltd.\r\nCopyright 2021 The Matrix.org Foundation C.I.C.\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\n/**\r\n * Returns the default number if the given value, i, is not a number. Otherwise\r\n * returns the given value.\r\n * @param {*} i The value to check.\r\n * @param {number} def The default value.\r\n * @returns {number} Either the value or the default value, whichever is a number.\r\n */\r\nexport function defaultNumber(i: unknown, def: number): number {\r\n    return Number.isFinite(i) ? Number(i) : def;\r\n}\r\n\r\nexport function clamp(i: number, min: number, max: number): number {\r\n    return Math.min(Math.max(i, min), max);\r\n}\r\n\r\nexport function sum(...i: number[]): number {\r\n    return [...i].reduce((p, c) => c + p, 0);\r\n}\r\n\r\nexport function percentageWithin(pct: number, min: number, max: number): number {\r\n    return pct * (max - min) + min;\r\n}\r\n\r\nexport function percentageOf(val: number, min: number, max: number): number {\r\n    const percentage = (val - min) / (max - min);\r\n    return Number.isNaN(percentage) ? 0 : percentage;\r\n}\r\n","(() => {\n  if (typeof __webpack_require__ !== 'undefined') {\n    var oldGetScript = __webpack_require__.u;\n    var oldLoadScript = __webpack_require__.e;\n    var queryMap = {};\n    var countMap = {};\n    var getRetryDelay = function () {\n      return 500;\n    };\n    __webpack_require__.u = function (chunkId) {\n      var result = oldGetScript(chunkId);\n      return (\n        result +\n        (queryMap.hasOwnProperty(chunkId) ? '?' + queryMap[chunkId] : '')\n      );\n    };\n    __webpack_require__.e = function (chunkId) {\n      var result = oldLoadScript(chunkId);\n      return result.catch(function (error) {\n        var retries = countMap.hasOwnProperty(chunkId) ? countMap[chunkId] : 3;\n        if (retries < 1) {\n          var realSrc = oldGetScript(chunkId);\n          error.message =\n            'Loading chunk ' +\n            chunkId +\n            ' failed after 3 retries.\\n(' +\n            realSrc +\n            ')';\n          error.request = realSrc;\n          throw error;\n        }\n        return new Promise(function (resolve) {\n          var retryAttempt = 3 - retries + 1;\n          setTimeout(function () {\n            var retryAttemptString = '&retry-attempt=' + retryAttempt;\n            var cacheBust = (() => Date.now())();\n            +retryAttemptString;\n            queryMap[chunkId] = cacheBust;\n            countMap[chunkId] = retries - 1;\n            resolve(__webpack_require__.e(chunkId));\n          }, getRetryDelay(retryAttempt));\n        });\n      });\n    };\n  }\n})();\n","/*\r\nCopyright 2024 New Vector Ltd.\r\nCopyright 2021 The Matrix.org Foundation C.I.C.\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\nimport { arraySeed } from \"../utils/arrays\";\r\n\r\nexport const WORKLET_NAME = \"mx-voice-worklet\";\r\n\r\nexport enum PayloadEvent {\r\n    Timekeep = \"timekeep\",\r\n    AmplitudeMark = \"amplitude_mark\",\r\n}\r\n\r\nexport interface IPayload {\r\n    ev: PayloadEvent;\r\n}\r\n\r\nexport interface ITimingPayload extends IPayload {\r\n    ev: PayloadEvent.Timekeep;\r\n    timeSeconds: number;\r\n}\r\n\r\nexport interface IAmplitudePayload extends IPayload {\r\n    ev: PayloadEvent.AmplitudeMark;\r\n    forIndex: number;\r\n    amplitude: number;\r\n}\r\n\r\nexport const PLAYBACK_WAVEFORM_SAMPLES = 39;\r\nexport const DEFAULT_WAVEFORM = arraySeed(0, PLAYBACK_WAVEFORM_SAMPLES);\r\n","/*\r\nCopyright 2024 New Vector Ltd.\r\nCopyright 2022 The Matrix.org Foundation C.I.C.\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\nimport { type WorkerPayload } from \"./worker\";\r\nimport { arrayRescale, arraySmoothingResample } from \"../utils/arrays\";\r\nimport { PLAYBACK_WAVEFORM_SAMPLES } from \"../audio/consts\";\r\n\r\nconst ctx: Worker = self as any;\r\n\r\nexport interface Request {\r\n    data: number[];\r\n}\r\n\r\nexport interface Response {\r\n    waveform: number[];\r\n}\r\n\r\nctx.addEventListener(\"message\", async (event: MessageEvent<Request & WorkerPayload>): Promise<void> => {\r\n    const { seq, data } = event.data;\r\n\r\n    // First, convert negative amplitudes to positive so we don't detect zero as \"noisy\".\r\n    const noiseWaveform = data.map((v) => Math.abs(v));\r\n\r\n    // Then, we'll resample the waveform using a smoothing approach so we can keep the same rough shape.\r\n    // We also rescale the waveform to be 0-1 so we end up with a clamped waveform to rely upon.\r\n    const waveform = arrayRescale(arraySmoothingResample(noiseWaveform, PLAYBACK_WAVEFORM_SAMPLES), 0, 1);\r\n\r\n    ctx.postMessage({ seq, waveform });\r\n});\r\n"],"names":["arrayFastResample","input","points","length","samples","everyNth","Math","round","i","push","spreadFactor","ceil","val","arraySeed","a","len","seed","slice","concat","arrayRescale","newMin","newMax","min","max","map","v","pct","percentageWithin","percentage","Number","isNaN","percentageOf","Array","fill","__webpack_require__","oldGetScript","u","oldLoadScript","e","queryMap","countMap","chunkId","hasOwnProperty","catch","error","retries","realSrc","message","request","Promise","resolve","setTimeout","cacheBust","Date","now","ctx","self","addEventListener","async","seq","data","event","waveform","average","arraySmoothingResample","abs","postMessage"],"sourceRoot":""}